<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java,scala,big data,javascript" />





  <link rel="alternate" href="/atom.xml" title="Format's Notes" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="吃饭睡觉撸代码">
<meta property="og:type" content="website">
<meta property="og:title" content="Format's Notes">
<meta property="og:url" content="http://fangjian0423.github.io/page/8/index.html">
<meta property="og:site_name" content="Format's Notes">
<meta property="og:description" content="吃饭睡觉撸代码">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Format's Notes">
<meta name="twitter:description" content="吃饭睡觉撸代码">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'always',
    motion: true
  };
</script>

  <title> Format's Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?b4a6a45360609483811f20bc2c62654c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Format's Notes</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">吃饭睡觉撸代码</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/02/13/jdk_hashmap/" itemprop="url">
                  jdk源码分析之HashMap
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-02-13T12:47:32+08:00" content="2015-02-13">
              2015-02-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/jdk/" itemprop="url" rel="index">
                    <span itemprop="name">jdk</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/02/13/jdk_hashmap/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/02/13/jdk_hashmap/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="前言">前言</h2><p>Map是一个映射键和值的对象。类似于Python中的字典。</p>
<p>HashMap为什么会出现呢?</p>
<p>因为数组这种数据结构，虽然遍历简单，但是插入和删除操作复杂，需要移动数组内部的元素；链表这种数据结构，插入和删除操作简单，但是查找复杂，只能一个一个地遍历。</p>
<p>有没有一种新的数据结构，插入数据简单，同时查找也简单？ 这个时候就出现了哈希表这种数据结构。 这是一种折中的方式，插入没数组快，插入没链表快。</p>
<p>哈希表这个东西，学过数据结构的都应该知道。</p>
<p>下图是用拉链法实现的哈希表，Java中的HashMap就是使用这种数据结构。</p>
<p>一个数组，数组上的各个项存储着链表的表头。</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/fangjian0423/603237/o_HashMap.png" alt=""></p>
<h2 id="HashMap的源码分析">HashMap的源码分析</h2><p>HashMap是Map接口的重要实现类之一。</p>
<p>HashMap中的key和value都可以为null，且它的方法都没有synchronized。 其他方法的实现大部分跟HashTable一致。HashTable的相关源码不在这里介绍，基本上跟HashTable一致。</p>
<p>HashMap有个内部静态类Node，这个Node就是拉链法哈希表上的数组上存储的链表节点，它有4个属性，hash表示哈希值，key表示键，value表示值, next表示这个节点的下一个节点，它并没有prev节点，这点与之前的截图一致：</p>
<pre><code><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>{
    <span class="keyword">final</span> <span class="keyword">int</span> hash;
    <span class="keyword">final</span> K key;
    V value;
    Node&lt;K,V&gt; next;

    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) {
        <span class="keyword">this</span>.hash = hash;
        <span class="keyword">this</span>.key = key;
        <span class="keyword">this</span>.value = value;
        <span class="keyword">this</span>.next = next;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>{ <span class="keyword">return</span> key; }
    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>{ <span class="keyword">return</span> value; }
    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>{ <span class="keyword">return</span> key + <span class="string">"="</span> + value; }

    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>{
        V oldValue = value;
        value = newValue;
        <span class="keyword">return</span> oldValue;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>{
        <span class="keyword">if</span> (o == <span class="keyword">this</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) {
            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;
                Objects.equals(value, e.getValue()))
                <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
}
</code></pre><p>这个Node节点类的属性有一个hash值，一个键值key，一个value还有一个表示下一个节点的Node类属性。它实现了Map接口内部的Entry接口。</p>
<h3 id="HashMap的属性">HashMap的属性</h3><p>然后是HashMap的几个重要的属性:</p>
<pre><code><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;

<span class="keyword">transient</span> <span class="keyword">int</span> <span class="keyword">size</span>;

<span class="keyword">transient</span> <span class="keyword">int</span> modCount;

<span class="keyword">int</span> threshold;

<span class="keyword">final</span> <span class="keyword">float</span> loadFactor;
</code></pre><p>table属性是一个数组，是一个Node类型数组，这就是之前分析的哈希表的结构。size表示这个map中键值对的个数。modCount跟迭代器相关，关于迭代器部分的知识到时候会在一篇文章中介绍。threshold表示阀值，它的值是容量*加载因子。loadFactor表示加载因子。</p>
<h3 id="HashMap的重要方法">HashMap的重要方法</h3><h4 id="V_put(K_key,_V_value)">V put(K key, V value)</h4><p><strong> 把一对键值对丢入到HashMap中 </strong></p>
<pre><code><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>{
    <span class="keyword">return</span> putVal(hash(key), key, <span class="keyword">value</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);
}
</code></pre><p>put方法调用putVal方法，并调用了一个hash方法将key转换成了一个hash值。</p>
<pre><code><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> hash(<span class="keyword">Object</span> <span class="variable">key</span>) {
    <span class="built_in">int</span> h;
    <span class="keyword">return</span> (<span class="variable">key</span> == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = <span class="variable">key</span>.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);
}
</code></pre><p>这个hash方法会算出这个key的hash值。</p>
<pre><code><span class="keyword">final</span> V putVal(<span class="built_in">int</span> hash, K <span class="variable">key</span>, V value, <span class="built_in">boolean</span> onlyIfAbsent,
               <span class="built_in">boolean</span> evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="built_in">int</span> n, i;
    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)
        n = (tab = resize()).length;
    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)
        tab[i] = newNode(hash, <span class="variable">key</span>, value, <span class="keyword">null</span>);
    <span class="keyword">else</span> {
        Node&lt;K,V&gt; e; K k;
        <span class="keyword">if</span> (p.hash == hash &amp;&amp;
            ((k = p.<span class="variable">key</span>) == <span class="variable">key</span> || (<span class="variable">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="variable">key</span>.equals(k))))
            e = p;
        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, <span class="variable">key</span>, value);
        <span class="keyword">else</span> {
            <span class="keyword">for</span> (<span class="built_in">int</span> binCount = <span class="number">0</span>; ; ++binCount) {
                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) {
                    p.next = newNode(hash, <span class="variable">key</span>, value, <span class="keyword">null</span>);
                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span>
                        treeifyBin(tab, hash);
                    <span class="keyword">break</span>;
                }
                <span class="keyword">if</span> (e.hash == hash &amp;&amp;
                    ((k = e.<span class="variable">key</span>) == <span class="variable">key</span> || (<span class="variable">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="variable">key</span>.equals(k))))
                    <span class="keyword">break</span>;
                p = e;
            }
        }
        <span class="keyword">if</span> (e != <span class="keyword">null</span>) { <span class="comment">// existing mapping for key</span>
            V oldValue = e.value;
            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)
                e.value = value;
            afterNodeAccess(e);
            <span class="keyword">return</span> oldValue;
        }
    }
    ++modCount;
    <span class="keyword">if</span> (++<span class="built_in">size</span> &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</code></pre><p>putVal方法首先会判断哈希表内部的数组是否已存在，不存在的话会调用resize方法扩大哈希表内部的数组长度。</p>
<p>接下来会使用 (n - 1) &amp; hash 的方式得到数组的索引值，这里的n就是HashMap内部数组的length长度，使用n-1可以避免数组长度跃界。</p>
<p>然后判断这个索引下是否有节点。</p>
<p>没有的话使用newNode方法构造一个新的节点作为开始节点，这个新的节点是起始节点，所以下一个节点为null(next属性为null)。 newNode方法如下， 就是直接构造一个节点，然后赋值给对应数组下标下的项。</p>
<pre><code><span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; newNode(int hash, K key, V value, <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; next) {
    return new <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;&gt;(hash</span>, key, value, next);
}
</code></pre><p>有的话执行else下的代码。</p>
<p>else下的代码的意思：</p>
<p>if：如果新的key值和数组上第一个节点的key值和新的key的hash值和第一个节点的hash值或者两者key值equals。 那么说明这个新的key跟第一个节点的key一致，然后把第一个节点的引用赋值给变量e。</p>
<p>else if：如果第一个节点是一个红黑树的节点，那么使用putTreeVal方法将节点的引用赋值给变量e。</p>
<p>else：开始各个节点，如果发现遍历节点的下一个节点为null，那么构造一个新的节点并作为当前遍历节点的next节点。否则判断遍历节点的hash值是否重复，重复的话赋值给变量e。接下来处理哈希值重复的数据。</p>
<p>如果put方法新增了节点，判断判断Map中总的键值对个数是否大于阀值(threshold)，大于的话调用resize方法扩展长度。</p>
<p>resize方法会扩展数组的长度，增大为两倍， 还会扩展threshold为原来的两倍。</p>
<h4 id="V_get(Object_key)">V get(Object key)</h4><p><strong> 根据键值，得到这个键值上对应的value </strong></p>
<pre><code><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="variable">key</span>) {
    Node&lt;K,V&gt; e;
    <span class="keyword">return</span> (e = getNode(hash(<span class="variable">key</span>), <span class="variable">key</span>)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;
}
</code></pre><p>使用getNode方法得带这个键值上对应的节点， getNode方法的参数是键值的hash值和键值自身。</p>
<pre><code><span class="keyword">final</span> Node&lt;K,V&gt; getNode(<span class="built_in">int</span> hash, <span class="keyword">Object</span> <span class="variable">key</span>) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="built_in">int</span> n; K k;
    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;
        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) {
        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span>
            ((k = first.<span class="variable">key</span>) == <span class="variable">key</span> || (<span class="variable">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="variable">key</span>.equals(k))))
            <span class="keyword">return</span> first;
        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) {
            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)
                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, <span class="variable">key</span>);
            do {
                <span class="keyword">if</span> (e.hash == hash &amp;&amp;
                    ((k = e.<span class="variable">key</span>) == <span class="variable">key</span> || (<span class="variable">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="variable">key</span>.equals(k))))
                    <span class="keyword">return</span> e;
            } <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);
        }
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</code></pre><p>很明显，这个getNode方法的作用就是根据hash值得到数组上的链表，然后遍历这个链表进行比较，最终拿到对应的值，没找到符合条件的值的话返回null。</p>
<p>这里键值比较的方法如下：</p>
<pre><code>(k = <span class="built_in">first</span>.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="built_in">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))
</code></pre><p><strong> 键值的hash值相等或者键值的hash值不等并且equals方法相等 </strong></p>
<h4 id="int_size()">int size()</h4><p><strong> 返回map内部键值对的个数 </strong></p>
<pre><code><span class="keyword">public</span> <span class="built_in">int</span> <span class="built_in">size</span>() {
    <span class="keyword">return</span> <span class="built_in">size</span>;
}
</code></pre><h4 id="boolean_containsKey(Object_key)">boolean containsKey(Object key)</h4><p><strong> 根据键值判断是否存在对应的节点 </strong></p>
<pre><code><span class="keyword">public</span> <span class="built_in">boolean</span> containsKey(<span class="keyword">Object</span> <span class="variable">key</span>) {
    <span class="keyword">return</span> getNode(hash(<span class="variable">key</span>), <span class="variable">key</span>) != <span class="keyword">null</span>;
}
</code></pre><p>根据键值使用getNode方法得到节点，然后判断节点是否存在</p>
<h4 id="boolean_containsValue(Object_value)">boolean containsValue(Object value)</h4><p><strong> 根据值判断是否存在对应的节点 </strong></p>
<pre><code><span class="function"><span class="keyword">public</span> boolean <span class="title">containsValue</span>(<span class="params">Object <span class="keyword">value</span></span>) </span>{
    Node&lt;K,V&gt;[] tab; V v;
    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) {
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) {
            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) {
                <span class="keyword">if</span> ((v = e.<span class="keyword">value</span>) == <span class="keyword">value</span> ||
                    (<span class="keyword">value</span> != <span class="keyword">null</span> &amp;&amp; <span class="keyword">value</span>.equals(v)))
                    <span class="keyword">return</span> <span class="keyword">true</span>;
            }
        }
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><p>遍历map内部数组和链表，然后判断各个链表上键值对的值是否与参数相等。</p>
<p>判断条件：</p>
<pre><code>(v = e.<span class="keyword">value</span>) == <span class="keyword">value</span> || (<span class="keyword">value</span> != <span class="keyword">null</span> &amp;&amp; <span class="keyword">value</span>.equals(v))
</code></pre><p>判断是根据值的内存地址是否相等或者值的equals方法是否相等。</p>
<h4 id="V_remove(Object_key)">V remove(Object key)</h4><p><strong> 根据键值移除节点 </strong></p>
<pre><code><span class="keyword">public</span> V remove(<span class="keyword">Object</span> <span class="variable">key</span>) {
    Node&lt;K,V&gt; e;
    <span class="keyword">return</span> (e = removeNode(hash(<span class="variable">key</span>), <span class="variable">key</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?
        <span class="keyword">null</span> : e.value;
}
</code></pre><p>remove方法内部调用removeNode方法。</p>
<pre><code>final <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) {
    <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt;[] tab; <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; p; int n, index;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;
        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != null) {
        <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; <span class="keyword">node</span><span class="identifier"> </span><span class="title">= null</span>, e; K k; V v;
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            <span class="keyword">node</span><span class="identifier"> </span><span class="title">= p</span>;
        else if ((e = p.next) != null) {
            if (p instanceof TreeNode)
                <span class="keyword">node</span><span class="identifier"> </span><span class="title">= ((TreeNode</span><span class="tag">&lt;K,V&gt;</span>)p).getTreeNode(hash, key);
            else {
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key ||
                         (key != null &amp;&amp; key.equals(k)))) {
                        <span class="keyword">node</span><span class="identifier"> </span><span class="title">= e</span>;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        if (<span class="keyword">node</span><span class="identifier"> </span><span class="title">!= null</span> &amp;&amp; (!matchValue || (v = <span class="keyword">node</span>.<span class="identifier"></span><span class="title">value</span>) == value ||
                             (value != null &amp;&amp; value.equals(v)))) {
            if (<span class="keyword">node</span><span class="identifier"> </span><span class="title">instanceof</span> TreeNode)
                ((TreeNode<span class="tag">&lt;K,V&gt;</span>)<span class="keyword">node</span><span class="identifier"></span><span class="title">).removeTreeNode</span>(this, tab, movable);
            else if (<span class="keyword">node</span><span class="identifier"> </span><span class="title">== p</span>)
                tab[index] = <span class="keyword">node</span>.<span class="identifier"></span><span class="title">next</span>;
            else
                p.next = <span class="keyword">node</span>.<span class="identifier"></span><span class="title">next</span>;
            ++modCount;
            --size;
            afterNodeRemoval(<span class="keyword">node</span><span class="identifier"></span><span class="title">);
            return</span> <span class="keyword">node</span><span class="identifier"></span><span class="title">;
        }
    }
    return</span> null;
}
</code></pre><p>先根据键的hash值找到对应的链表表头，然后遍历链表找出对应的节点，找到之后处理对应的链表顺序。 size减一，也就是键值对的个数减一。</p>
<h2 id="HashMap注意的地方">HashMap注意的地方</h2><ol>
<li>HashMap采用的是拉链式哈希表数据结构</li>
<li>HashMap内部存储的数据是无序的，这是因为HashMap内部的数组的下表是根据hash值算出来的</li>
</ol>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/02/06/groovy_note/" itemprop="url">
                  groovy基本概念学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-02-06T23:43:57+08:00" content="2015-02-06">
              2015-02-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/jvm/" itemprop="url" rel="index">
                    <span itemprop="name">jvm</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/02/06/groovy_note/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/02/06/groovy_note/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>groovy是一种基于JVM的动态语言，能够与java代码很好地结合，可以使用Java语言编写的库。 </p>
<p>这里记录一下groovy的一些学习笔记。</p>
<p>1.groovy可以使用def定义一个变量，使用def其实就是表示这个对象的类型是Object：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">num</span> =</span> <span class="number">1</span>
<span class="function"><span class="keyword">def</span> <span class="title">str</span> =</span> <span class="string">"format"</span>
<span class="function"><span class="keyword">def</span> <span class="title">today</span> =</span> <span class="keyword">new</span> <span class="type">Date</span>()
</code></pre><p>而在java中，由于java是静态语言，因此java定义变量的时候必须指明变量的类型。</p>
<p>2.groovy中 “==” 符号相当于java中的 “equals” 方法， groovy中的 “is” 方法相当于java中的 “==”</p>
<pre><code>new <span class="function"><span class="title">Date</span><span class="params">()</span></span> == new <span class="function"><span class="title">Date</span><span class="params">()</span></span>   <span class="comment">// true</span>
new <span class="function"><span class="title">Date</span><span class="params">()</span></span>.<span class="function"><span class="title">is</span><span class="params">(new Date()</span></span>)  <span class="comment">// false</span>
</code></pre><p>3.groovy中可以使用 “[]” 表示数组或链表， “[:]” 表示map。</p>
<pre><code>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// 表示包含一个ArrayList实例</span>
[<span class="string">"1"</span>:<span class="string">"a"</span>, <span class="string">"2"</span>:<span class="string">"b"</span>] <span class="comment">// 表示一个map</span>
</code></pre><p>4.可以使用dump方法查看当前实例的具体信息</p>
<pre><code>["1":"a", "2":"b"] // <span class="tag">&lt;<span class="title">java.util.LinkedHashMap@a0</span> <span class="attribute">head</span>=<span class="value">1=a</span> <span class="attribute">tail</span>=<span class="value">2=b</span> <span class="attribute">accessOrder</span>=<span class="value">false</span> <span class="attribute">table</span>=<span class="value">[null,</span> <span class="attribute">1</span>=<span class="value">a,</span> <span class="attribute">2</span>=<span class="value">b,</span> <span class="attribute">null</span>] <span class="attribute">entrySet</span>=<span class="value">[1=a,</span> <span class="attribute">2</span>=<span class="value">b]</span> <span class="attribute">size</span>=<span class="value">2</span> <span class="attribute">modCount</span>=<span class="value">2</span> <span class="attribute">threshold</span>=<span class="value">3</span> <span class="attribute">loadFactor</span>=<span class="value">0.75</span> <span class="attribute">keySet</span>=<span class="value">null</span> <span class="attribute">values</span>=<span class="value">null</span>&gt;</span>
</code></pre><p>5.groovy会默认import一些包。</p>
<pre><code><span class="tag">java</span><span class="class">.io</span>.*
<span class="tag">java</span><span class="class">.lang</span>.*
<span class="tag">java</span><span class="class">.math</span><span class="class">.BigDecimal</span>
<span class="tag">java</span><span class="class">.math</span><span class="class">.BigInteger</span>
<span class="tag">java</span><span class="class">.net</span>.*
<span class="tag">java</span><span class="class">.util</span>.*
<span class="tag">groovy</span><span class="class">.lang</span>.*
<span class="tag">groovy</span><span class="class">.util</span>.*
</code></pre><p>而java只会默认import    java.lang.*</p>
<p>6.java空对象调用方法会报错，因此需要加上逻辑判断一些非null对象，而groovy可以使用?.符号：</p>
<pre><code>instance?.<span class="keyword">method</span>()
</code></pre><p>而在java中需要这么写：</p>
<pre><code><span class="keyword">if</span>(instance != null)
    instance.<span class="keyword">method</span>()
</code></pre><p>7.groovy提供了一种叫做GString的概念。</p>
<pre><code><span class="string">"<span class="variable">${name}</span>, nice to meet you!"</span>
</code></pre><p>上面这段字符串就是个GString，字符串中的${name}会被自动解析成name变量所表示的值。</p>
<p>8.闭包</p>
<p>闭包应该是最大的区别了。 动态语言都有闭包这个概念，而静态语言没有。 </p>
<p>java遍历map的时候需要得到map的keySet，然后使用for遍历：</p>
<pre><code><span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; keySet = <span class="built_in">map</span><span class="built_in">.</span>keySet();
f<span class="subst">or</span>(<span class="built_in">String</span> str : keySet) {
    <span class="attribute">...</span>
}
</code></pre><p>groovy中的闭包：</p>
<pre><code><span class="built_in">map</span><span class="built_in">.</span>each {
    key, value <span class="subst">-&gt; </span><span class="attribute">...</span><span class="built_in">.
</span>}  
</code></pre><p>list也可以使用闭包：</p>
<pre><code><span class="built_in">list</span><span class="built_in">.</span>eachWithIndex {
    value, index <span class="subst">-&gt; </span><span class="attribute">...</span>
}
</code></pre><p>如果闭包内只有1个属性，那么这个属性可以不写，默认为it：</p>
<pre><code>[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>].each {
    println it
}
</code></pre><p>等于：</p>
<pre><code>[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>].each {
    num -&gt; println num
}
</code></pre><p>9.范围range</p>
<p>groovy中可以使用1..3这个range，表示[1,2,3]。 1..3也可以写成 1..&lt;4 </p>
<p>10.list实用方法</p>
<p>list的findAll方法，find方法，groupBy方法。</p>
<p>找出30岁的人，返回值也是一个List</p>
<pre><code><span class="built_in">list</span>.each {
  it.age == <span class="number">30</span>  <span class="comment">// 注意是==。 如果用=的话不会报错，但是有时候会出现莫名其妙的错误，很难找。</span>
}
</code></pre><p>根据年龄分组，返回值是一个Map，key是age，也就是年龄，value是一个list</p>
<pre><code><span class="type">list</span>.groupBy {
  <span class="keyword">it</span>.age
}
</code></pre><p>11.日期实用方法</p>
<p>昨天和明天的获取：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">now</span> = <span class="title">new</span> <span class="title">Date</span><span class="params">()</span></span>
<span class="function"><span class="keyword">def</span> <span class="title">tomorrow</span> = <span class="title">now</span> <span class="title">+</span> 1</span>
<span class="function"><span class="keyword">def</span> <span class="title">yesterday</span> = <span class="title">now</span> <span class="title">-</span> 1</span>
</code></pre><p>根据时分秒设置时间：</p>
<pre><code>def <span class="built_in">now</span> = <span class="keyword">new</span> <span class="built_in">Date</span>()
<span class="built_in">now</span>.<span class="keyword">set</span>([hourOfDay: <span class="number">1</span>, <span class="built_in">minute</span>: <span class="number">30</span>, <span class="built_in">second</span>: <span class="number">45</span>])
</code></pre><p>12.metaClass的使用</p>
<p>groovy不像javascript，javascript中定义一个对象，然后可以给这个对象的实例动态地插入任何属性和方法。</p>
<p>groovy定义好了一个类，如何给这个类的实例动态地添加属性和方法呢， 那就是使用metaClass。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{
  <span class="built_in">String</span> name
  <span class="built_in">int</span> age
}

Person p = <span class="keyword">new</span> Person()
p.hobby = <span class="string">'music'</span> <span class="comment">// 会报错，因为Person类没有hobby属性</span>
p.metaClass.hobby = <span class="string">'music'</span> <span class="comment">// 不会报错，动态添加属性</span>
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/01/17/jdk_linkedlist/" itemprop="url">
                  jdk源码分析之LinkedList
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-01-17T16:43:37+08:00" content="2015-01-17">
              2015-01-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/jdk/" itemprop="url" rel="index">
                    <span itemprop="name">jdk</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/01/17/jdk_linkedlist/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/01/17/jdk_linkedlist/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="前言">前言</h2><p>ArrayList是一个单向链表，LinkedList则是一个双向链表。</p>
<p>双向链表的设计跟单项链表不一样，单项链表只是在内部维护一个数组属性即可。</p>
<p>双向链表不使用数组这个概念，而是在内部定义了一个叫做Node类型的内部类，这个Node就是一个节点，这个节点有3个属性，分别是元素(当前节点要表示的值), 前节点(当前节点之前位置上的一个节点)，后节点(当前节点后面位置的一个节点)。 </p>
<p>LinkedList关于数据的插入，删除操作都会处理这些节点的前后关系。</p>
<p>这是两者最大的区别。</p>
<h2 id="源码分析">源码分析</h2><p>在分析LinkedList之前，我们先看下它里面的内部类Node，也就是节点类：</p>
<pre><code>private static class <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; {
    E item;
    <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; next;
    <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; prev;

    <span class="keyword">Node</span><span class="identifier"></span><span class="title">(Node</span><span class="tag">&lt;E&gt;</span> prev, E element, <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
</code></pre><p>构造函数有3个参数，分别是前一个节点，元素值，后一个节点。</p>
<p>3个属性，元素代表的值，前一个节点，后一个节点。</p>
<p>LinkedList的3个属性：</p>
<pre><code>transient int size = <span class="number">0</span>;

transient <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; first;

transient <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; last;
</code></pre><p>size表示这个列表当前的长度, first属性和last属性都是一个Node类型的实例，也就是一个节点。 看名字也知道，一个是第一个节点，另外一个是最后一个节点。</p>
<h3 id="add(E_e)">add(E e)</h3><p><strong> 添加元素到列表的最后一个位置 </strong></p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{
    linkLast(e);
    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</code></pre><p>add方法内部调用linkLast方法。</p>
<pre><code>void linkLast(E e) {
    final <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; l = last;
    final <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; newNode = new <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;&gt;(l</span>, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
}
</code></pre><p>首先先拿到列表中的最后一个节点，然后构造一个新的节点，这个新的节点的前一个元素就是刚才拿到的列表中的最后一个节点，然后属性last也就是最后一个节点赋值成新构造的这个节点，接下来做了一个判断，如果当前列表的最后一个节点为null，那么说明这个列表当前没有元素，于是这个新构造的节点赋值给了第一个节点。否则的话，最后一个节点的下一个节点就是这个新构造的节点。之后列表长度+1(size++)。</p>
<p>总体来说，这个add方法的速度很快，几乎不消耗时间。</p>
<h3 id="add(int_index,_E_element)">add(int index, E element)</h3><p><strong> 添加元素到列表中的指定位置 </strong></p>
<pre><code><span class="keyword">public</span> <span class="keyword">void</span> add(<span class="keyword">int</span> <span class="keyword">index</span>, E element) {
    checkPositionIndex(<span class="keyword">index</span>);

    <span class="keyword">if</span> (<span class="keyword">index</span> == size)
        linkLast(element);
    <span class="keyword">else</span>
        linkBefore(element, node(<span class="keyword">index</span>));
}
</code></pre><p>首先会判断当前的索引位置是否合法。接下来判断参数索引是否跟列表长度相等， 相等的话说明这个位置就是最后一个位置，那么执行linkLast方法，这个方法之前刚分析过。 如果不是最后一个位置，那么执行linkBefore方法。先看下执行linkBefore方法传入参数的时候调用的一个node方法。</p>
<pre><code>Node&lt;E&gt; node(<span class="keyword">int</span> <span class="keyword">index</span>) {
    <span class="regexp">//</span> assert isElementIndex(<span class="keyword">index</span>);

    <span class="keyword">if</span> (<span class="keyword">index</span> &lt; (size &gt;&gt; <span class="number">1</span>)) {
        Node&lt;E&gt; <span class="keyword">x</span> = first;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">index</span>; i++)
            <span class="keyword">x</span> = <span class="keyword">x</span>.<span class="keyword">next</span>;
        <span class="keyword">return</span> <span class="keyword">x</span>;
    } <span class="keyword">else</span> {
        Node&lt;E&gt; <span class="keyword">x</span> = <span class="keyword">last</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; <span class="keyword">index</span>; i--)
            <span class="keyword">x</span> = <span class="keyword">x</span>.prev;
        <span class="keyword">return</span> <span class="keyword">x</span>;
    }
}
</code></pre><p>node(index)方法的作用是根据索引值，得到该索引下的那个节点。</p>
<p>这个使用了一个小算法：<strong>如果索引值比当前列表长度的一半还要小，那么从第一个元素开始遍历，找到index位置上的元素；否则从最后一个元素开始遍历，找到index位置上的元素</strong></p>
<pre><code>void linkBefore(E e, <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; succ) {
    // assert succ != null;
    final <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; pred = succ.prev;
    final <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; newNode = new <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;&gt;(pred</span>, e, succ);
    succ.prev = newNode;
    if (pred == null)
        first = newNode;
    else
        pred.next = newNode;
    size++;
    modCount++;
}    
</code></pre><p>这个方法的参数e就是新节点的元素值，succ参数是要新插入的节点的那个位置上的现有节点。</p>
<p>处理过程：没啥好说的，处理的就是节点位置的一系列变化。</p>
<p>addAll方法也就是处理一些位置的变化，有兴趣的读者可自行查看源码。</p>
<p>LinkedList还提供了2个不一样的add方法，分别是addFirst和addLast方法，作用分别是插入第一个节点和插入最后一个节点。</p>
<h3 id="remove(int_index)">remove(int index)</h3><p><strong> 移除指定位置上的节点 </strong></p>
<pre><code><span class="keyword">public</span> E remove(<span class="keyword">int</span> <span class="keyword">index</span>) {
    checkElementIndex(<span class="keyword">index</span>);
    <span class="keyword">return</span> unlink(node(<span class="keyword">index</span>));
}
</code></pre><p>首先会检查下标值的合法性，然后调用unlink方法:</p>
<pre><code>E unlink(Node&lt;E&gt; x) {
    <span class="comment">// assert x != null;</span>
    <span class="keyword">final</span> E element = x.item;
    <span class="keyword">final</span> Node&lt;E&gt; <span class="keyword">next</span> = x.<span class="keyword">next</span>;
    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;

    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) {
        first = <span class="keyword">next</span>;
    } <span class="keyword">else</span> {
        prev.<span class="keyword">next</span> = <span class="keyword">next</span>;
        x.prev = <span class="keyword">null</span>;
    }

    <span class="keyword">if</span> (<span class="keyword">next</span> == <span class="keyword">null</span>) {
        last = prev;
    } <span class="keyword">else</span> {
        <span class="keyword">next</span>.prev = prev;
        x.<span class="keyword">next</span> = <span class="keyword">null</span>;
    }

    x.item = <span class="keyword">null</span>;
    <span class="keyword">size</span>--;
    modCount++;
    <span class="keyword">return</span> element;
}
</code></pre><p>把要移除的节点的前后节点处理一下。移除节点的前一个节点的后一个节点是移除节点的后一个节点。移除节点的后一个节点的前一个节点是移除节点的前一个节点。然后判断一下是否是第一个节点的问题，之后将移除节点上的前后节点的属性值和它的元素值都设置为null。列表长度-1(size–)。</p>
<h3 id="get(int_index)">get(int index)</h3><p><strong> 得到索引位置上的元素 </strong></p>
<pre><code><span class="keyword">public</span> E get(<span class="keyword">int</span> <span class="keyword">index</span>) {
    checkElementIndex(<span class="keyword">index</span>);
    <span class="keyword">return</span> node(<span class="keyword">index</span>).item;
}
</code></pre><p>找到对应的节点，拿出元素值即可。</p>
<p>先讲这么多吧，其他方法就不一一看了。数据结构了解就行了。</p>
<h2 id="LinkedList和ArrayList的比较">LinkedList和ArrayList的比较</h2><ol>
<li>LinkedList和ArrayList的设计理念完全不一样，ArrayList基于数组，而LinkedList基于节点。</li>
<li>两者的使用场景不同，ArrayList适用于频繁遍历，但是不怎么操作数据的场合。LinkedList适用于频繁操作数据，不频繁遍历的场合。 刚好相反。 为什么说LinkedList不适合频繁遍历，那是因为LinkedList要遍历节点的话只能从第一个或最后一个节点开始遍历，一个一个找。而ArrayList完全不需要，因为ArrayList内部维护着一个数组，遍历的话仅仅从数组上的索引开始找即可。</li>
<li>两者的数据结构不同，ArrayList是一个单项的链表，而LinkedList是一个双向的链表。</li>
</ol>
<h2 id="使用LinkedList要注意的点">使用LinkedList要注意的点</h2><p>LinkedList在频繁遍历数据的场合下不适合使用。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/01/16/jdk_arraylist/" itemprop="url">
                  jdk源码分析之ArrayList
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-01-16T21:07:44+08:00" content="2015-01-16">
              2015-01-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/jdk/" itemprop="url" rel="index">
                    <span itemprop="name">jdk</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/01/16/jdk_arraylist/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/01/16/jdk_arraylist/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="前言">前言</h2><p>list是一种有序的集合(an ordered collection), 通常也会被称为序列(sequence)，使用list可以精确地控制每个元素的插入，可以通过索引值找到对应list中的各个项，也可以在list中查询元素。</p>
<p>list跟set不同，list允许出现重复的数据，list还允许内部出现null的项。</p>
<p>以前的几段话摘自jdk文档的说明。</p>
<p>其实list就相当于一个动态的数组，也就是链表，普通的数组长度大小都是固定的，而list是一个动态的数组，当list的长度满了，再次插入数据到list当中的时候，list会自动地扩展它的长度。</p>
<p>C，C++中有链表的概念，它们可以使用结构体和指针来定义一个链表。 这样链表插入数据的时候可以加入新的结构体。 但是Java中没有指针这个概念，只能通过其他方式来实现。 比如数组。</p>
<h2 id="ArrayList源码分析">ArrayList源码分析</h2><p>首先我们先分析一个List接口的实现类之一，也是最常用的ArrayList的源码。</p>
<p>ArrayList其实就是一个单向链表。</p>
<p>这里分析的代码是基于jdk1.8的。</p>
<p>ArrayList类的属性如下：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span>[] EMPTY_ELEMENTDATA = {};
  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span>[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
<span class="keyword">transient</span> <span class="keyword">Object</span>[] elementData;
<span class="keyword">private</span> <span class="built_in">int</span> <span class="built_in">size</span>;
</code></pre><p>属性size表示这个集合的有效长度；Object[] elementData这个数组是这个集合的全部元素；EMPTY_ELEMENTDATA表示一个共享的空数组，主要是为了让所有的空集合共享使用的；DEFAULTCAPACITY_EMPTY_ELEMENTDATA表示共享的空数组，是为了给有默认大小的空集合使用的。<br>(transient关键字表示这个属性不会被序列化)</p>
<p>接下来是ArrayList的构造函数分析：</p>
<p>ArrayList有3个构造函数，分别是</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{
  <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) {
    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];
  } <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) {
    <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;
  } <span class="keyword">else</span> {
      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+
                                          initialCapacity);
  }
}
</code></pre><p>简单分析一下，这个构造函数的参数是一个initialCapacity整型类型的参数。这个initialCapacity看名字也知道，就是个初始化容量的意思。 如果这个值比0大，那么内部的elementData数组属性会被初始化；如果这个值等于0，那么内部的elementData会被赋值成EMPTY_ELEMENTDATA，也就是之前分析属性的时候说的让空集合共享使用的一个空数组；如果这个值小于0，抛异常。</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>{
    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
</code></pre><p>如果构造ArrayList没有传递任何参数，那么内部的elementData属性会被赋值成DEFAULTCAPACITY_EMPTY_ELEMENTDATA。</p>
<pre><code><span class="keyword">public</span> ArrayList(Collection&lt;? <span class="keyword">extends</span> E&gt; c) {
    elementData ArrayList= c.toArray();
    <span class="keyword">if</span> ((<span class="keyword">size</span> = elementData.length) != <span class="number">0</span>) {
        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>
        <span class="keyword">if</span> (elementData.getClass() != Object[].<span class="keyword">class</span>)
            elementData = Arrays.copyOf(elementData, <span class="keyword">size</span>, Object[].<span class="keyword">class</span>);
    } <span class="keyword">else</span> {
        <span class="comment">// replace with empty array.</span>
        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;
    }
}
</code></pre><p>这个构造函数的参数是一个集合接口类型。如果这个集合内部的元素大于0，那么这些元素会被拷贝到ArrayList内部的elementData属性中，否则elementData属性使用共享的空数组。</p>
<p>接下来我们比较一下jdk1.6的ArrayList。</p>
<p>jdk1.6的ArrayList只有两个属性：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">Object</span>[] elementData;
<span class="keyword">private</span> <span class="built_in">int</span> <span class="built_in">size</span>;
</code></pre><p>它的构造函数：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{
  <span class="keyword">super</span>();
  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)
  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>
  + initialCapacity);
  <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];
}
</code></pre><p>这个构造函数跟1.8版本的区别不大，就是空list的时候，1.8版本的把共享的空数组赋值给elementData。</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>{
  <span class="keyword">this</span>(<span class="number">10</span>);
}
</code></pre><p>这个构造函数跟1.8版本的相差就大了。他会在内部默认初始化一个10个长度的数组，而1.8版本的是使用一个空的数组赋值给elementData。</p>
<pre><code><span class="component">public ArrayList(Collection&lt;? <span class="keyword">extends</span> E&gt; c) {
  elementData = c<span class="string">.toArray()</span>;
  size = elementData<span class="string">.length</span>;
  // c<span class="string">.toArray</span> might (incorrectly) not return Object[] (see 6260652)
  if (elementData<span class="string">.getClass()</span> != Object[]<span class="string">.class)</span>
  elementData = Arrays<span class="string">.copyOf(elementData</span>, size, Object[]<span class="string">.class)</span>;
}</span>
</code></pre><p>这个构造函数跟1.8版本的差别是1.8版本下如果这个Collection参数中元素个数为0,那么elementData会被赋值成共享的空数组。</p>
<p>接下来挑几个重要的方法讲解一下：</p>
<h3 id="add(E_e)_方法">add(E e) 方法</h3><p>这个方法的作用就是把 <strong>元素添加到列表的最后面</strong> ，我先把add方法的结论讲一下(由于ArrayList是一个动态的数组，当添加元素当数组的时候，肯定需要判断一下数组的长度是否够长，不够长的话会做一些处理)：</p>
<p>我觉得可以使用下面这个公式来表示ArrayList内部数组长度的增加算法：</p>
<p><strong>新的长度 = max(数组长度 + 数组长度 / 2, 新的长度)</strong></p>
<p>这个算法有个前提条件：<strong>新的长度 &gt; 数组长度</strong></p>
<p><strong>这里新的长度不固定，比如add方法: 这个新的长度的就是当前数组有效长度+1; 比如addAll方法: 这个新的长度就是当前数组有效长度+Collection集合长度</strong></p>
<p><strong>这里的有效数组长度指的是ArrayList内部的size属性。</strong></p>
<p>源码：</p>
<p>add方法jdk1.8版本：</p>
<pre><code><span class="keyword">public</span> <span class="built_in">boolean</span> <span class="built_in">add</span>(E e) {
  ensureCapacityInternal(<span class="built_in">size</span> + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span>
  elementData[<span class="built_in">size</span>++] = e;
  <span class="keyword">return</span> <span class="keyword">true</span>;
}
</code></pre><p>添加元素到列表的最后，这里的ensureCapacityInternal方法会处理数组长度不够长的问题，它的参数是当前数组的长度+1。</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{
  <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
  }

  ensureExplicitCapacity(minCapacity);
}
</code></pre><p>如果当前对象是使用无參的构造函数实现的，那么取10(DEFAULT_CAPACITY)和参数的较大值，然后用这个值调用ensureExplicitCapacity方法。否则，直接调用ensureExplicitCapacity方法。</p>
<pre><code><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{
  modCount++;

  <span class="comment">// overflow-conscious code</span>
  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)
    grow(minCapacity);
}
</code></pre><p>如果要加的元素的下标值比当前数组长度要大的话(minCapacity参数代表当前数组的最后一个元素的下标值， 只有一个情况特殊，那就是使用无參的构造函数构造之后第一次调用，这个时候minCapacity为10)</p>
<pre><code><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{
  <span class="comment">// overflow-conscious code</span>
  <span class="keyword">int</span> oldCapacity = elementData.length;
  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);
  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)
  newCapacity = minCapacity;
  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)
  newCapacity = hugeCapacity(minCapacity);
  <span class="comment">// minCapacity is usually close to size, so this is a win:</span>
  elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre><p>这个就是数组长度动态计算的算法。</p>
<p>下面是我写的一些测试代码和注释，有兴趣的可以验证一下：</p>
<pre><code>@<span class="function">Test
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNoParamConstructor</span><span class="params">()</span> </span>{
  <span class="comment">// 不带参数的构造函数第一次add之后，会分配10个长度给内部elementData数组属性</span>
  <span class="comment">// 接下来每次add，会都判断数组长度是否不够，不够的话 新的长度 = max(当前数组长度 + 当前数组长度 / 2, 当前数组长度 + 1)</span>
  <span class="comment">// 比如，实例化之后。第一次add，数组长度分配了10个空间，当添加第11个的时候，数组长度不够，这也时候会分配15个(11 + 11 / 2)和11个的较大值，然后分配了11个。</span>
  <span class="comment">// 然后elementData有15个空间，当添加第16个的时候，分配22(15 + 15 / 2)个。 以此类推， 22个不够的时候分配33个，33个不够的时候分配49个。</span>
  ArrayList <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList();

  <span class="keyword">int</span> count = <span class="number">164</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) {
    <span class="built_in">list</span>.add(i);
  }
  System.out.println(<span class="string">"done"</span>);
}

@<span class="function">Test
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testKnowSize</span><span class="params">()</span> </span>{
  <span class="comment">// 带长度的原理。 只不过一开始不会分配10个空间，而是参数穿进来的空间大小。</span>
  <span class="comment">// 比如传入0, 0个空间，第一次add, 选择0(0 + 0 / 2)和1(0+1)的较大值，取1,分配1个空间</span>
  <span class="comment">// 再次添加的时候，选择1(1+1/2)和2(1+1)的较大值，取2,分配2个空间</span>
  <span class="comment">// 再次添加的时候，选择3(2+2/2)和3(2+1)的较大值，取3,分配3个空间</span>
  <span class="comment">// 再次添加的时候，选择4(3+3/2)和4(3+1)的较大值，取4,分配4个空间</span>
  <span class="comment">// 再次添加的时候，选择6(4+4/2)和5(4+1)的较大值，取6,分配6个空间  以此类推...</span>
  ArrayList <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList(<span class="number">0</span>);
  <span class="built_in">list</span>.add(<span class="number">1</span>);
  <span class="built_in">list</span>.add(<span class="number">2</span>);
  <span class="built_in">list</span>.add(<span class="number">3</span>);
  <span class="built_in">list</span>.add(<span class="number">4</span>);
  <span class="built_in">list</span>.add(<span class="number">5</span>);
  System.out.println(<span class="string">"done"</span>);
}

@<span class="function">Test
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testValidAdd</span><span class="params">()</span> </span>{
  <span class="comment">// 虽然list内部的elementData长度为5,但是有效长度为0。 所以add的时候不会增加长度。</span>
  ArrayList <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList(<span class="number">5</span>);
  <span class="built_in">list</span>.add(<span class="string">"1"</span>);
}
</code></pre><h3 id="add(int_index,_E_element)_方法">add(int index, E element) 方法</h3><p>这个方法的作用是 <strong>在指定位置插入数据</strong></p>
<pre><code><span class="keyword">public</span> void add(<span class="built_in">int</span> <span class="built_in">index</span>, E element) {
  rangeCheckForAdd(<span class="built_in">index</span>);

  ensureCapacityInternal(<span class="built_in">size</span> + <span class="number">1</span>);  // Increments modCount<span class="comment">!!</span>
  System.arraycopy(elementData, <span class="built_in">index</span>, elementData, <span class="built_in">index</span> + <span class="number">1</span>,
                   <span class="built_in">size</span> - <span class="built_in">index</span>);
    elementData[<span class="built_in">index</span>] = element;
    <span class="built_in">size</span>++;
}
</code></pre><p>rangeCheckForAdd方法是验证参数index是否ok，index &lt; 0 或 index &gt; 数组最后一个下标值的话，直接抛出IndexOutOfBoundsException异常。ensureCapacityInternal方法之前分析add(E e)的时候已经分析过了。接下来的一句代码就是将index下标值的数据全部往后移一位，然后index下标值的数据使用新的素质，元素长度+1(size++)。</p>
<h3 id="remove(int_index)">remove(int index)</h3><p>remove方法就是 <strong>移除对应坐标值上的数据</strong></p>
<pre><code><span class="keyword">public</span> E remove(<span class="built_in">int</span> <span class="built_in">index</span>) {
  rangeCheck(<span class="built_in">index</span>);

  modCount++;
  E oldValue = elementData(<span class="built_in">index</span>);

  <span class="built_in">int</span> numMoved = <span class="built_in">size</span> - <span class="built_in">index</span> - <span class="number">1</span>;
  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)
      System.arraycopy(elementData, <span class="built_in">index</span>+<span class="number">1</span>, elementData, <span class="built_in">index</span>,
                       numMoved);
  elementData[--<span class="built_in">size</span>] = null; // clear to let GC <span class="keyword">do</span> its work

  <span class="keyword">return</span> oldValue;
}
</code></pre><p>首先先检查坐标值是否合法，然后得到对应坐标上的元素，之后index下标值之后的数据全部往前移。</p>
<p>测试代码：</p>
<pre><code>@<span class="function">Test
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRemove</span><span class="params">()</span> </span>{
  ArrayList <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList();
  <span class="built_in">list</span>.add(<span class="string">"1"</span>);
  <span class="built_in">list</span>.add(<span class="string">"2"</span>);
  <span class="built_in">list</span>.add(<span class="string">"1"</span>);
  <span class="built_in">list</span>.add(<span class="string">"3"</span>);
  <span class="built_in">list</span>.remove(<span class="number">0</span>);
  <span class="comment">// remove方法只会删除第一个匹配的元素，之后的元素下标都向前移。 所以"1"的下标值从2变成了1，且只有1个"1"元素</span>
  System.out.println(<span class="built_in">list</span>.indexOf(<span class="string">"1"</span>)); <span class="comment">// 输出 1</span>
}
</code></pre><h3 id="remove(Object_o)">remove(Object o)</h3><p> <strong>找出数组中的元素，然后移除</strong></p>
<pre><code><span class="keyword">public</span> <span class="keyword">boolean</span> remove(Object o) {
    <span class="keyword">if</span> (o == <span class="keyword">null</span>) {
        <span class="keyword">for</span> (<span class="keyword">int</span> <span class="keyword">index</span> = <span class="number">0</span>; <span class="keyword">index</span> &lt; size; <span class="keyword">index</span>++)
            <span class="keyword">if</span> (elementData[<span class="keyword">index</span>] == <span class="keyword">null</span>) {
                fastRemove(<span class="keyword">index</span>) {
    modCount++;
    <span class="keyword">int</span> numMoved = size - <span class="keyword">index</span> - <span class="number">1</span>;
    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)
        System.arraycopy(elementData, <span class="keyword">index</span>+<span class="number">1</span>, elementData, <span class="keyword">index</span>,
                         numMoved);
    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span>
}
</code></pre><h3 id="clear">clear</h3><p><strong>清除list中的所有数据</strong>。 没啥好说的，遍历数组，每一项设置为null，然后让GC去回收。 之后将size设置为0。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">clear</span>() {
  modCount++;

  <span class="comment">// clear to let GC do its work</span>
  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)
      elementData[i] = <span class="keyword">null</span>;

  <span class="built_in">size</span> = <span class="number">0</span>;
}
</code></pre><h3 id="set(int_index,_E_element)">set(int index, E element)</h3><p><strong>用element值替换下标值为index的值</strong></p>
<pre><code><span class="keyword">public</span> E set(<span class="keyword">int</span> <span class="keyword">index</span>, E element) {
  rangeCheck(<span class="keyword">index</span>);

  E oldValue = elementData(<span class="keyword">index</span>);
  elementData[<span class="keyword">index</span>] = element;
  <span class="keyword">return</span> oldValue;
}
</code></pre><h3 id="get(int_index)">get(int index)</h3><p><strong>得到下标值为index的元素</strong></p>
<pre><code><span class="keyword">public</span> E get(<span class="keyword">int</span> <span class="keyword">index</span>) {
    rangeCheck(<span class="keyword">index</span>);

    <span class="keyword">return</span> elementData(<span class="keyword">index</span>);
}
</code></pre><h3 id="indexOf(Object)">indexOf(Object)</h3><p><strong>根据参数对象，如果是null对象，找出数组上第一个为null对着的元素，然后返回下标值。如果不是null对象，参数对象equals数组元素为true的话，返回对应的下标</strong></p>
<pre><code>public <span class="built_in">int</span> indexOf(Object o) {
    <span class="keyword">if</span> (o == <span class="literal">null</span>) {
        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span><span class="comment">; i &lt; size; i++)</span>
            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)
              <span class="keyword">return</span> i<span class="comment">;</span>
    } <span class="keyword">else</span> {
        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span><span class="comment">; i &lt; size; i++)</span>
            <span class="keyword">if</span> (o.equals(elementData[i]))
                <span class="keyword">return</span> i<span class="comment">;</span>
    }
    <span class="keyword">return</span> -<span class="number">1</span><span class="comment">;</span>
}
</code></pre><h3 id="contains(Object_o)">contains(Object o)</h3><p><strong>查看数组中是否存在对象</strong> 内部使用indexOf方法</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>{
    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;
}
</code></pre><h3 id="addAll">addAll</h3><p><strong>在列表的结尾添加一个Collection集合</strong></p>
<pre><code><span class="keyword">public</span> <span class="keyword">boolean</span> addAll(Collection&lt;? <span class="keyword">extends</span> E&gt; c) {
    Object[] a = c.toArray();
    <span class="keyword">int</span> numNew = a.length;
    ensureCapacityInternal(<span class="keyword">size</span> + numNew);  <span class="comment">// Increments modCount</span>
    System.arraycopy(a, <span class="number">0</span>, elementData, <span class="keyword">size</span>, numNew);
    <span class="keyword">size</span> += numNew;
    <span class="keyword">return</span> numNew != <span class="number">0</span>;
}
</code></pre><p>首先先得到Collection参数内部数组的长度，然后调用ensureCapacityInternal方法确保内部数据的长度，然后在内部数组的最后添加新的数组。</p>
<p>在列表的指定位置添加一个Collection集合。</p>
<pre><code><span class="keyword">public</span> boolean addAll(<span class="built_in">int</span> <span class="built_in">index</span>, Collection&lt;? <span class="keyword">extends</span> E&gt; c) {
  rangeCheckForAdd(<span class="built_in">index</span>);

  Object[] a = c.toArray();
  <span class="built_in">int</span> numNew = a.length;
  ensureCapacityInternal(<span class="built_in">size</span> + numNew);  // Increments modCount

  <span class="built_in">int</span> numMoved = <span class="built_in">size</span> - <span class="built_in">index</span>;
  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)
  System.arraycopy(elementData, <span class="built_in">index</span>, elementData, <span class="built_in">index</span> + numNew,
    numMoved);

    System.arraycopy(a, <span class="number">0</span>, elementData, <span class="built_in">index</span>, numNew);
    <span class="built_in">size</span> += numNew;
    <span class="keyword">return</span> numNew <span class="comment">!= 0;</span>
}
</code></pre><p>首先先判断下标值是否合法。然后调用ensureCapacityInternal方法确保内部数据的长度，然后在index坐标位置的元素都往后移参数Collection集合内部数组的长度，然后空闲的位置加入新集合的数据。</p>
<h3 id="toArray">toArray</h3><p><strong>根据elementData数组拷贝一份新的数组</strong></p>
<pre><code><span class="keyword">public</span> <span class="keyword">Object</span>[] toArray() {
    <span class="keyword">return</span> Arrays.copyOf(elementData, <span class="built_in">size</span>);
}
</code></pre><p>以前分析的一些方法都会处理一个叫做modCount的int类型的属性，这个属性的ArrayList的父类AbstractList中定义的。</p>
<p>据说这个modCount跟ArrayList的迭代器有关，现在还不清楚。。 以后看迭代器相关的源码的时候我再继续这个话题。</p>
<h2 id="ArrayList的注意点">ArrayList的注意点</h2><ol>
<li>当数据量很大的时候，ArrayList内部操作元素的时候会移动位置，很耗性能</li>
<li>ArrayList虽然可以自动扩展长度，但是数据量一大，扩展的也多，会造成很多空间的浪费</li>
<li>ArrayList有一个内部私有类，SubList。ArrayList提供一个subList方法用于构造这个SubList。这里需要注意的是SubList和ArrayList使用的数据引用是同一个对象，在SubList中操作数据和在ArrayList中操作数据都会影响对方。</li>
<li>ArrayList允许加入null元素</li>
</ol>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/01/11/bootstrap-grid/" itemprop="url">
                  bootstrap学习系列之表格布局
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-01-11T00:07:24+08:00" content="2015-01-11">
              2015-01-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/bootstrap/" itemprop="url" rel="index">
                    <span itemprop="name">bootstrap</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/01/11/bootstrap-grid/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/01/11/bootstrap-grid/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>bootstrap框架不用多说了，本文来讲讲bootstrap中的grid相关的知识。</p>
<p>grid，也就是表格，可以用来展示一些表单的数据。</p>
<p>废话不多说，直接进入主题。 </p>
<h2 id="grid样式基本知识">grid样式基本知识</h2><p>bootstrap中grid样式有几个基本的知识，我们先来看一下这几个基本的知识。</p>
<ol>
<li>grid样式有12种比例设置，分别为1-12.  1代表宽度为1/12，2代表宽度为2/12，以此类推。</li>
<li>grid样式可以在多种设备中生效，且针对各个设备会有不同的样式。<br> 小于768像素的， 比如手机。 样式以.col-xs-为前缀<br> 大于等于768像素的，比如平板。 样式以.col-sm为前缀<br> 大于等于992像素的，比如笔记本。 样式以.col-md-为前缀<br> 大于等于1200像素的，比如大屏显示器。 样式以.col-lg-为前缀</li>
<li>grid样式的position都是relative，即相对布局。</li>
</ol>
<p>具体的一些细节方便的知识请参考<a href="http://getbootstrap.com/css/#grid-options" target="_blank" rel="external">bootstrap官网</a>介绍。</p>
<h2 id="例子">例子</h2><p>由于使用markdown编写，无法进行展示，具体的效果读者可以自行尝试，当然也可以查看<a href="https://github.com/fangjian0423/ReadingNotes/blob/master/bootstrap/grid/grid.html" target="_blank" rel="external">我的学习笔记</a>。下面的说明一般都使用col-md-这种设备，这都是在我的PC上测试过的。</p>
<p>例子1：<br>这行占3列，每列占宽度的1/3。由于使用的是 md样式 这个样式只针对笔记本这个设备，该例子在笔记本上显示3列正常，但是在手机上看的话这里会有3行，因为手机端无法识别md这个样式。因此如果不区分设备，所有的设备都显示同样的效果，那应该使用col-xs-为前缀的样式。</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"row"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"col-md-4"</span>&gt;.col-md-<span class="number">4</span>&lt;/<span class="keyword">div</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"col-md-4"</span>&gt;.col-md-<span class="number">4</span>&lt;/<span class="keyword">div</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"col-md-4"</span>&gt;.col-md-<span class="number">4</span>&lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>
</code></pre><p>例子2：<br>这行有2列，笔记本上这2列各占一半，但是在手机上这2列各占1/3。 之前已经分析过，col-md-为前缀的代表笔记本设备，col-xs-为前缀的代表手机设备。</p>
<pre><code>&lt;<span class="tag">div</span> class=<span class="string">"row"</span>&gt;
    &lt;<span class="tag">div</span> class=<span class="string">"col-md-6 col-xs-4"</span>&gt;<span class="class">.col-md-6</span> .col-xs-<span class="number">4</span>&lt;/div&gt;
    &lt;<span class="tag">div</span> class=<span class="string">"col-md-6 col-xs-4"</span>&gt;<span class="class">.col-md-6</span> .col-xs-<span class="number">4</span>&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>例子3：<br>布局的嵌套, 嵌套内部也是以12为总和进行计算的。</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"row"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"col-md-6"</span>&gt;
        .col-md-<span class="number">6</span>
        &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"row"</span>&gt;
            &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"col-md-6"</span>&gt;.col-md-<span class="number">6</span>&lt;/<span class="keyword">div</span>&gt;
            &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"col-md-6"</span>&gt;.col-md-<span class="number">6</span>&lt;/<span class="keyword">div</span>&gt;
        &lt;/<span class="keyword">div</span>&gt;
    &lt;/<span class="keyword">div</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"col-md-6"</span>&gt;.col-md-<span class="number">6</span>&lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>例子4：<br>位置的偏移。 如果想在列与列之间有间隔，可以使用col-md-offset这个样式，这个样式也是分1-12种，分别代为1/12, 2/12…的margin-left样式。 有了这个样式，间隔的代码就不需要使用一个空的div隔开了。</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"row"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"col-md-5"</span>&gt;.col-md-<span class="number">5</span>&lt;/<span class="keyword">div</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"col-md-5 col-md-offset-2"</span>&gt;.col-md-<span class="number">5</span> .col-md-<span class="command">offset</span>-<span class="number">2</span>&lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>col-md-offset-2的样式的margin-left， 还有另外两个类似的样式，分别是 col-md-push-2和col-md-pull-2。 分别代表left和right百分比。 由于col-md-5等样式使用的是相对布局，因此这些right，left样式会生效。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://7x2wh6.com1.z0.glb.clouddn.com/avatar.jpg" alt="Format" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Format</p>
        </div>
        <p class="site-description motion-element" itemprop="description">吃饭睡觉撸代码</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">56</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            
              <span class="site-state-item-count">52</span>
              <span class="site-state-item-name">标签</span>
              
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fangjian0423" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/fangjian0423" target="_blank">
                  
                    <i class="fa fa-twitter"></i> Twitter
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/2952387973" target="_blank">
                  
                    <i class="fa fa-weibo"></i> Weibo
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">友情链接</p>
            
              <span class="links-of-author-item">
              <a href="http://xtutu.me/" target="_blank">永哥</a>
              </span>
            
              <span class="links-of-author-item">
              <a href="http://blog.zlf.me" target="_blank">Felix</a>
              </span>
            
              <span class="links-of-author-item">
              <a href="http://stockgraph.net/" target="_blank">WhiteAmber</a>
              </span>
            
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Format</span>
</div>




      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'fangjian0423';
      var disqus_identifier = 'page/8/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
