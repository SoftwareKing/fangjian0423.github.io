<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Format&#39;s Notes</title>
  <subtitle>吃饭睡觉撸代码</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fangjian0423.github.io/"/>
  <updated>2016-11-09T04:22:25.000Z</updated>
  <id>http://fangjian0423.github.io/</id>
  
  <author>
    <name>Format</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBatch中的retry和skip机制实现分析</title>
    <link href="http://fangjian0423.github.io/2016/11/09/springbatch-retry-skip/"/>
    <id>http://fangjian0423.github.io/2016/11/09/springbatch-retry-skip/</id>
    <published>2016-11-09T00:15:22.000Z</published>
    <updated>2016-11-09T04:22:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://projects.spring.io/spring-batch/" target="_blank" rel="external">SpringBatch</a>是spring框架下的一个子模块，用于处理批处理的批次框架。</p>
<p>本文主要分析SpringBatch中的retry和skip机制的实现。</p>
<p>先简单说明下SpringBatch在SpringBoot中的使用。</p>
<p>如果要在springboot中使用batch的话，直接加入以下依赖即可：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-batch&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>然后使用注解开启Batch模块：</p>
<pre><code>...
@EnableBatchProcessing
public class Application { ... }
</code></pre><p>之后就可以注入JobBuilderFactory和StepBuilderFactory：</p>
<pre><code>@Autowired
private JobBuilderFactory jobs;

@Autowired
private StepBuilderFactory steps;
</code></pre><p>有了这2个factory之后，就可以build job。</p>
<a id="more"></a>
<p>SpringBatch中的相关基础概念比如ItemReader、ItemWriter、Chunk等本文就不介绍了。</p>
<p>我们以FlatFileItemReader作为reader，一个自定义Writer用于打印reader中读取出来的数据。</p>
<p>这个定义的writer遇到good job这条数据的时候会报错，具体逻辑如下：</p>
<pre><code>@Override
public void write(List&lt;? extends String&gt; items) throws Exception {
    System.out.println(&quot;handle start =====&quot; + items);
    for(String a : items) {
        if(a.equals(&quot;good job&quot;)) {
            throw new Exception(&quot;custom exception&quot;);
        }
    }
    System.out.println(&quot;handle end.. -----&quot; + items);
}
</code></pre><p>其中reader中读取的文件中的数据如下：</p>
<pre><code>hello world
hello coder
good job
cool
66666
</code></pre><p>我们使用StepBuilderFactory构造Step，chunkSize设置为2。然后在job1中使用并执行：</p>
<pre><code>stepBuilderFactory.get(&quot;test-step&quot;).chunk(2).reader(reader).writer(writer).build();
</code></pre><p>执行job1后console打印如下：</p>
<pre><code>handle start =====[hello world, hello coder]
handle end.. -----[hello world, hello coder]
handle start =====[good job, cool]
</code></pre><p>job1遇到了good job这条数据，writer抛出了异常，由于没有使用skip或者retry机制，导致整个流程停止。job1的处理流程底层在<strong>SimpleChunkProcessor</strong>这个类中完成，包括processor、writer的使用。</p>
<p>接下里我们构造一个job2，job2使用skip机制(其中skipLimit必须要和skip(Class&lt;? extends Throwable&gt; type)一起使用)，skip机制可以防止writer发生异常后不停止整个job，但是需要同时满足skip的限制次数和skip对应的Exception是发生异常的父类或自身关系条件才不会停止整个job，这里我们使用Exception作为异常和Integer.MAX_VALUE作为skip的限制次数为例：</p>
<pre><code>stepBuilderFactory.get.get(&quot;test-step&quot;).chunk(2).reader(reader).writer(writer).faultTolerant().skipLimit(Integer.MAX_VALUE).skip(Exception.class).build();
</code></pre><p>执行job2    后console打印如下：</p>
<pre><code>handle start =====[hello world, hello coder]
handle end.. -----[hello world, hello coder]
handle start =====[good job, cool]
handle start =====[good job]
handle start =====[cool]
handle end.. -----[cool]
handle start =====[66666]
handle end.. -----[66666]
</code></pre><p>我们看到good job这条数据发生的异常被skip掉了，job完整的执行。</p>
<p>但是发现了另外一个问题，那就是处理 [good job, cool] 这批数据的时候，发生了异常，但是接下来执行了 [good job] 和 [cool] 这两批chunk为1的批次。这是在ItemWriter中执行的，它也会在ItemWriteListener中执行多次。</p>
<p><strong>换句话说，如果使用了skip功能，那么对于需要被skip的批次数据中会进行scan操作找出具体是哪1条数据的原因，这里的scan操作指的是一条一条数据的遍历。</strong></p>
<p>这个过程为什么叫scan呢?  在源码中，FaultTolerantChunkProcessor类(处理带有skip或者retry机制的处理器，跟SimpleChunkProcessor类似，只不过SimpleChunkProcessor处理简单的Job)里有个私有方法scan：</p>
<pre><code>private void scan(final StepContribution contribution, final Chunk&lt;I&gt; inputs, final Chunk&lt;O&gt; outputs,
        ChunkMonitor chunkMonitor, boolean recovery) throws Exception {

    ...

    Chunk&lt;I&gt;.ChunkIterator inputIterator = inputs.iterator();
    Chunk&lt;O&gt;.ChunkIterator outputIterator = outputs.iterator();

    List&lt;O&gt; items = Collections.singletonList(outputIterator.next()); // 拿出需要写的数据中的每一条数据
    inputIterator.next();
    try {
        writeItems(items); // 写每条数据
        doAfterWrite(items);
        contribution.incrementWriteCount(1);
        inputIterator.remove();
        outputIterator.remove();
    }
    catch (Exception e) { // 写的时候如果发生了异常
        doOnWriteError(e, items);
        if (!shouldSkip(itemWriteSkipPolicy, e, -1) &amp;&amp; !rollbackClassifier.classify(e)) {
            inputIterator.remove();
            outputIterator.remove();
        }
        else {
            // 具体的skip策略
            checkSkipPolicy(inputIterator, outputIterator, e, contribution, recovery);
        }
        if (rollbackClassifier.classify(e)) {
            throw e;
        }
    }
    chunkMonitor.incrementOffset();
    if (outputs.isEmpty()) { // 批次里的所有数据处理完毕之后 scanning 设置为false
        data.scanning(false);
        inputs.setBusy(false);
        chunkMonitor.resetOffset();
    }
}
</code></pre><p>这个scan方法触发的条件是UserData这个内部类里的scanning被设置为true，这里被设置为true是在处理批次数据出现异常后并且不能retry的情况下才会被设置的。</p>
<pre><code>try {
    batchRetryTemplate.execute(retryCallback, recoveryCallback, new DefaultRetryState(inputs,
            rollbackClassifier));
}
catch (Exception e) {
    RetryContext context = contextHolder.get();
     if (!batchRetryTemplate.canRetry(context)) {
         // 设置scanning为true
        data.scanning(true);
    }
    throw e;
}
</code></pre><p>这就是为什么skip机制在skip数据的时候会去scan批次中的每条数据，然后并找出需要被skip的数据的原理。</p>
<p>job3带有retry功能，retry的功能在于出现某个异常并且这个异常可以被retry所接受的话会进行retry，retry的次数可以进行配置，我们配置了3次retry：</p>
<pre><code>stepBuilderFactory.get.get(&quot;test-step&quot;).chunk(2).reader(reader).writer(writer).faultTolerant().skipLimit(Integer.MAX_VALUE).skip(Exception.class).retryLimit(3).retry(Exception.class).build();
</code></pre><p>执行 job3后console打印如下：</p>
<pre><code>handle start =====[hello world, hello coder]
handle end.. -----[hello world, hello coder]
handle start =====[good job, cool]
handle start =====[good job, cool]
handle start =====[good job, cool]
handle start =====[good job]
handle start =====[cool]
handle end.. -----[cool]
handle start =====[66666]
handle end.. -----[66666]
</code></pre><p>[good job, cool] 这批数据retry了3次，而且都失败了。失败之后进行了skip操作。</p>
<p>SpringBatch中的retry和skip都有对应的policy实现，默认的retry policy是SimpleRetryPolicy，可以设置retry次数和接收的exception。比如可以使用NeverRetryPolicy：</p>
<pre><code>.retryPolicy(new NeverRetryPolicy())
</code></pre><p>使用NeverRetryPolicy之后，便不再retry了，只会skip。SpringBatch内部的retry是使用Spring的<a href="https://github.com/spring-projects/spring-retry" target="_blank" rel="external">retry模块</a>完成的。执行的时候可以设置RetryCallback和RecoveryCallback。</p>
<p>SpringBatch中默认的skip policy是LimitCheckingItemSkipPolicy。</p>
<p>参考资料: </p>
<p><a href="http://stackoverflow.com/questions/16567432/how-is-the-skipping-implemented-in-spring-batch" target="_blank" rel="external">http://stackoverflow.com/questions/16567432/how-is-the-skipping-implemented-in-spring-batch</a></p>
<p><a href="http://docs.spring.io/spring-batch/reference/html/retry.html" target="_blank" rel="external">http://docs.spring.io/spring-batch/reference/html/retry.html</a></p>
<p><a href="https://github.com/spring-projects/spring-retry" target="_blank" rel="external">https://github.com/spring-projects/spring-retry</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://projects.spring.io/spring-batch/&quot;&gt;SpringBatch&lt;/a&gt;是spring框架下的一个子模块，用于处理批处理的批次框架。&lt;/p&gt;
&lt;p&gt;本文主要分析SpringBatch中的retry和skip机制的实现。&lt;/p&gt;
&lt;p&gt;先简单说明下SpringBatch在SpringBoot中的使用。&lt;/p&gt;
&lt;p&gt;如果要在springboot中使用batch的话，直接加入以下依赖即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-batch&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后使用注解开启Batch模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
@EnableBatchProcessing
public class Application { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后就可以注入JobBuilderFactory和StepBuilderFactory：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Autowired
private JobBuilderFactory jobs;

@Autowired
private StepBuilderFactory steps;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有了这2个factory之后，就可以build job。&lt;/p&gt;
    
    </summary>
    
      <category term="spring" scheme="http://fangjian0423.github.io/categories/spring/"/>
    
    
      <category term="spring" scheme="http://fangjian0423.github.io/tags/spring/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springbatch" scheme="http://fangjian0423.github.io/tags/springbatch/"/>
    
  </entry>
  
  <entry>
    <title>java Annotation的RetentionPolicy介绍</title>
    <link href="http://fangjian0423.github.io/2016/11/04/java-annotation-retentionpolicy/"/>
    <id>http://fangjian0423.github.io/2016/11/04/java-annotation-retentionpolicy/</id>
    <published>2016-11-03T16:01:06.000Z</published>
    <updated>2016-11-03T16:03:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java Annotation对应的Retention有3种，在RetentionPolicy中定义，有3种：</p>
<ol>
<li>SOURCE. 注解保留在源代码中，但是编译的时候会被编译器所丢弃。比如@Override, @SuppressWarnings</li>
<li>CLASS. 这是默认的policy。注解会被保留在class文件中，但是在运行时期间就不会识别这个注解。</li>
<li>RUNTIME. 注解会被保留在class文件中，同时运行时期间也会被识别。所以可以使用反射机制获取注解信息。比如@Deprecated</li>
</ol>
<a id="more"></a>
<h2 id="RUNTIME"><a href="#RUNTIME" class="headerlink" title="RUNTIME"></a>RUNTIME</h2><p>大部分情况下，我们都是使用RUNTIME这个Policy。</p>
<p>下面就是一个RUNTIME Annotation的例子。</p>
<p>先定义Annotation：</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface MyClassRuntimeAnno {
    String name();
    int level() default 1;
}
</code></pre><p>然后在CLASS前面使用这个Annotation。</p>
<pre><code>@MyClassRuntimeAnno(name = &quot;simple&quot;, level = 10)
public class SimpleObj {
}
</code></pre><p>最后写一个testcase通过反射可以获取这个类的Annotation进行后续操作。</p>
<pre><code>@Test
public void testGetAnnotation() {
    Annotation[] annotations = SimpleObj.class.getAnnotations();
    System.out.println(Arrays.toString(annotations));
    MyClassRuntimeAnno myClassAnno = SimpleObj.class.getAnnotation(MyClassRuntimeAnno.class);
    System.out.println(myClassAnno.name() + &quot;, &quot; + myClassAnno.level());
    System.out.println(myClassAnno == annotations[0]);
}
</code></pre><h2 id="SOURCE"><a href="#SOURCE" class="headerlink" title="SOURCE"></a>SOURCE</h2><p>SOURCE这个policy表示注解保留在源代码中，但是编译的时候会被编译器所丢弃。 由于在编译的过程中这个注解还被保留着，所以在编译过程中可以针对这个policy进行一些操作。比如在自动生成java代码的场景下使用。最常见的就是<a href="https://projectlombok.org/" target="_blank" rel="external">lombok</a>的使用了，可以自动生成field的get和set方法以及toString方法，构造器等；消除了冗长的java代码。</p>
<p>SOURCE这个policy可以使用jdk中的javax.annotation.processing.*包中的processor处理器进行注解的处理过程。</p>
<p>以1个编译过程中会打印类中的方法的例子来说明SOUCRE这个policy的作用：</p>
<p>首先定义一个Printer注解：</p>
<pre><code>@Retention(RetentionPolicy.SOURCE)
@Target(ElementType.METHOD)
public @interface Printer {
}
</code></pre><p>然后一个类的方法使用这个注解：</p>
<pre><code>public class SimpleObject {

    @Printer
    public void methodA() {

    }

    public void methodB() {

    }

}
</code></pre><p>创建对应的Processor：</p>
<pre><code>@SupportedAnnotationTypes({&quot;me.format.annotaion.Printer&quot;})
public class PrintProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
        Messager messager = processingEnv.getMessager();
        messager.printMessage(Diagnostic.Kind.NOTE, &quot;start to use PrintProcessor ..&quot;);


        Set&lt;? extends Element&gt; rootElements = roundEnv.getRootElements();
        messager.printMessage(Diagnostic.Kind.NOTE, &quot;root classes: &quot;);
        for(Element root : rootElements) {
            messager.printMessage(Diagnostic.Kind.NOTE, &quot;&gt;&gt; &quot; + root.toString());
        }
        messager.printMessage(Diagnostic.Kind.NOTE, &quot;annotation: &quot;);
        for(TypeElement te : annotations) {
            messager.printMessage(Diagnostic.Kind.NOTE, &quot;&gt;&gt;&gt; &quot; + te.toString());
            Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(te);
            for(Element ele : elements) {
                messager.printMessage(Diagnostic.Kind.NOTE, &quot;&gt;&gt;&gt;&gt; &quot; + ele.toString());
            }
        }

        return true;
    }
    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }
}
</code></pre><p>然后先使用javac编译Printer和PrintProcessor：</p>
<pre><code>javac -d classes src/main/java/me/format/annotation/Printer.java src/main/java/me/format/annotation/PrintProcessor.java
</code></pre><p>最后再使用javac中的processor参数处理：</p>
<pre><code>javac -cp classes -processor me.format.annotation.PrintProcessor -d classes src/main/java/me/format/annotation/SimpleObject.java
</code></pre><p>控制台打印出：</p>
<pre><code>注: start to use PrintProcessor ..
注: root classes: 
注: &gt;&gt; hello.annotation.SimpleObject
注: annotation: 
注: &gt;&gt;&gt; hello.annotation.Printer
注: &gt;&gt;&gt;&gt; methodA()
</code></pre><h2 id="CLASS"><a href="#CLASS" class="headerlink" title="CLASS"></a>CLASS</h2><p>CLASS和RUNTIME的唯一区别是RUNTIME在运行时期间注解是存在的，而CLASS则不存在。</p>
<p>我们通过<a href="http://asm.ow2.org/" target="_blank" rel="external">asm</a>来获取class文件里的annotation。</p>
<p>首先定义注解：</p>
<p>policy为CLASS的注解。</p>
<pre><code>@Retention(RetentionPolicy.CLASS)
@Target(ElementType.TYPE)
public @interface Meta {

    String name();

}
</code></pre><p>policy为RUNTIME的注解。</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Header {

    int code();

}
</code></pre><p>使用注解：</p>
<pre><code>@Meta(name = &quot;obj&quot;)
@Header(code = 200)
public class AnnotationObject {

    private String val;

    public String getVal() {
        return val;
    }

    public void setVal(String val) {
        this.val = val;
    }
}
</code></pre><p>编译这3个java文件得到字节码文件AnnotationObject.class：</p>
<pre><code>javac -d classes src/main/java/me/format/annotaion/AnnotationObject.java src/main/java/me/format/annotation/Meta.java src/main/java/me/format/annotation/Header.java
</code></pre><p>使用asm获取字节码文件中的注解：</p>
<pre><code>ClassNode classNode = new ClassNode();

ClassReader cr = new ClassReader(new FileInputStream(&quot;classes/me/format/annotation/AnnotationObject.class&quot;));

cr.accept(classNode, 0);

System.out.println(&quot;Class Name: &quot; + classNode.name);
System.out.println(&quot;Source File: &quot; + classNode.sourceFile);

System.out.println(&quot;invisible: &quot;);
AnnotationNode anNode = null;
for (Object annotation : classNode.invisibleAnnotations) {
    anNode = (AnnotationNode) annotation;
    System.out.println(&quot;Annotation Descriptor : &quot; + anNode.desc);
    System.out.println(&quot;Annotation attribute pairs : &quot; + anNode.values);
}

System.out.println(&quot;visible: &quot;);
for (Object annotation : classNode.visibleAnnotations) {
    anNode = (AnnotationNode) annotation;
    System.out.println(&quot;Annotation Descriptor : &quot; + anNode.desc);
    System.out.println(&quot;Annotation attribute pairs : &quot; + anNode.values);
}
</code></pre><p>打印出：</p>
<pre><code>Class Name: me/format/annotation/AnnotationObject
Source File: AnnotationObject.java
invisible: 
Annotation Descriptor : Lme/format/annotation/Meta;
Annotation attribute pairs : [name, obj]
visible: 
Annotation Descriptor : Lme/format/annotation/Header;
Annotation attribute pairs : [code, 200]
</code></pre><p>其中policy为CLASS的注解编译完后不可见，而policy为RUNTIME的注解编译后可见。</p>
<p>同样，我们可以使用javap查看编译后的信息：</p>
<pre><code>javap -v me.format.annotation.AnnotationObject
</code></pre><p>会打印出注解的visible信息：</p>
<pre><code>#16 = Utf8               AnnotationObject.java
#17 = Utf8               RuntimeVisibleAnnotations
#18 = Utf8               Lhello/annotation/Header;
#19 = Utf8               code
#20 = Integer            200
#21 = Utf8               RuntimeInvisibleAnnotations
#22 = Utf8               Lhello/annotation/Meta;
#23 = Utf8               name
#24 = Utf8               obj
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java Annotation对应的Retention有3种，在RetentionPolicy中定义，有3种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SOURCE. 注解保留在源代码中，但是编译的时候会被编译器所丢弃。比如@Override, @SuppressWarnings&lt;/li&gt;
&lt;li&gt;CLASS. 这是默认的policy。注解会被保留在class文件中，但是在运行时期间就不会识别这个注解。&lt;/li&gt;
&lt;li&gt;RUNTIME. 注解会被保留在class文件中，同时运行时期间也会被识别。所以可以使用反射机制获取注解信息。比如@Deprecated&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Swagger在SpringBoot中的使用</title>
    <link href="http://fangjian0423.github.io/2016/10/09/springboot-swagger/"/>
    <id>http://fangjian0423.github.io/2016/10/09/springboot-swagger/</id>
    <published>2016-10-09T14:11:23.000Z</published>
    <updated>2016-10-09T13:50:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://swagger.io/" target="_blank" rel="external">Swagger</a>是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p>
<p>在SpringBoot中要使用Swagger的话，可以使用<a href="https://github.com/springfox/springfox" target="_blank" rel="external">springfox</a>。</p>
<p>在sbt中添加依赖即可：</p>
<pre><code>libraryDependencies += &quot;io.springfox&quot; % &quot;springfox-swagger2&quot; % &quot;2.6.0&quot;
libraryDependencies += &quot;io.springfox&quot; % &quot;springfox-swagger-ui&quot; % &quot;2.6.0&quot;
</code></pre><p>查看springfox-swagger2中的源码，发现springfox并不是通过autoconfigure实现和swagger的整合的，而是基于Spring的方式Import各种bean构造Swagger。</p>
<p>所以本文指的Swagger在SpringBoot中的使用同样也可以在Spring中使用。</p>
<a id="more"></a>
<p>要整合Spring和Swagger的话需要这么做。</p>
<ol>
<li>加上@EnableSwagger2注解</li>
<li>构造一个Docket</li>
</ol>
<p>以下代码就是例子：</p>
<pre><code>@EnableSwagger2
@Configuration
public class SwaggerConfiguration {

    @Bean
    public Docket userDocket() {
        ApiInfo apiInfo = new ApiInfo(&quot;A Simple of SpringBoot-Swagger&quot;,// 大标题
                &quot;two controllers: UserController and DeptController&quot;,// 小标题
                &quot;1.0&quot;,// 版本
                &quot;NO terms of service&quot;,
                new Contact(&quot;format&quot;, &quot;fangjian0423.github.io&quot;, &quot;fangjian0423@gmail.com&quot;), // 作者信息
                &quot;The Apache License, Version 2.0&quot;,// 开源许可证
                &quot;http://www.apache.org/licenses/LICENSE-2.0.html&quot;// 许可证详情
        );
        return new Docket(DocumentationType.SWAGGER_2)
                .select()
                .paths(Predicates.or(PathSelectors.regex(&quot;/user/.*&quot;), PathSelectors.regex(&quot;/dept/.*&quot;)))
                .build()
                .apiInfo(apiInfo);
    }

}
</code></pre><p>需要注意的是path方法表示要构造的url，这里使用了or连接了 /user/.*<em> 和 /dept/.*</em> 这2个地址，这里用的是正则的匹配方式。</p>
<p>UserController：</p>
<pre><code>@RestController
@RequestMapping(Array(&quot;/user&quot;))
class UserController {

  @ApiOperation(nickname = &quot;test method&quot;, value = &quot;just a test method&quot;)
  @RequestMapping(value = Array(&quot;/demo&quot;), method = Array(RequestMethod.POST, RequestMethod.GET))
  def demo(): String = {
    &quot;Hello Swagger&quot;
  }

  @RequestMapping(value = Array(&quot;/get/{id}&quot;), method = Array(RequestMethod.GET))
  def get(@PathVariable id: String): String = {
    s&quot;get ${id}&quot;
  }

  @RequestMapping(value = Array(&quot;/delete/{id}&quot;), method = Array(RequestMethod.POST))
  def delete(
              @ApiParam(name = &quot;id&quot;, value = &quot;the identity of user&quot;, required = true)
              @PathVariable id: String
              ): String = {
    s&quot;delete ${id}&quot;
  }

  @ApiImplicitParams(
    Array(
      new ApiImplicitParam(name = &quot;name&quot;, value = &quot;the name of user&quot;, required = true, paramType = &quot;form&quot;, dataType = &quot;string&quot;),
      new ApiImplicitParam(name = &quot;age&quot;, value = &quot;the age of user&quot;, required = true, paramType = &quot;form&quot;, dataType = &quot;int&quot;)
    )
  )

  @RequestMapping(value = Array(&quot;/add&quot;), method = Array(RequestMethod.POST))
  def add(req: HttpServletRequest): String = {
    s&quot;${req.getParameter(&quot;name&quot;)}-${req.getParameter(&quot;age&quot;)}&quot;
  }

}
</code></pre><p>Swagger默认会去找被@RequestMapping注解的方法。</p>
<p>@ApiOperation注解用于说明接口的作用，作用在方法上，如果没有使用这个注解，会去@RequestMapping中的value和method等属性。</p>
<p>@ApiParam注解用来额外说明参数的meta data。</p>
<p>@ApiImplicitParams注解也用来额外说明参数，当参数不在方法里声明的时候，可以使用这个注解。需要注意的是这个注解只能作用在方法上。</p>
<p>Swagger还提供了@ApiModel、@ApiResponse、@Example等诸多注解用于说明接口的作用。</p>
<p>另外一个Controller: </p>
<pre><code>@RestController
@RequestMapping(Array(&quot;/dept&quot;))
class DeptController {

  @ApiOperation(nickname = &quot;dept test method&quot;, value = &quot;dept just a test method&quot;)
  @RequestMapping(value = Array(&quot;/demo&quot;), method = Array(RequestMethod.POST, RequestMethod.GET))
  def demo(): String = {
    &quot;Hello Swagger&quot;
  }

}
</code></pre><p>Swagger展示如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/swagger01.png" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://swagger.io/&quot;&gt;Swagger&lt;/a&gt;是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。&lt;/p&gt;
&lt;p&gt;在SpringBoot中要使用Swagger的话，可以使用&lt;a href=&quot;https://github.com/springfox/springfox&quot;&gt;springfox&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在sbt中添加依赖即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;libraryDependencies += &amp;quot;io.springfox&amp;quot; % &amp;quot;springfox-swagger2&amp;quot; % &amp;quot;2.6.0&amp;quot;
libraryDependencies += &amp;quot;io.springfox&amp;quot; % &amp;quot;springfox-swagger-ui&amp;quot; % &amp;quot;2.6.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看springfox-swagger2中的源码，发现springfox并不是通过autoconfigure实现和swagger的整合的，而是基于Spring的方式Import各种bean构造Swagger。&lt;/p&gt;
&lt;p&gt;所以本文指的Swagger在SpringBoot中的使用同样也可以在Spring中使用。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="swagger" scheme="http://fangjian0423.github.io/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot的事务管理</title>
    <link href="http://fangjian0423.github.io/2016/10/07/springboot-transaction/"/>
    <id>http://fangjian0423.github.io/2016/10/07/springboot-transaction/</id>
    <published>2016-10-06T17:28:36.000Z</published>
    <updated>2016-10-06T17:33:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Springboot内部提供的事务管理器是根据autoconfigure来进行决定的。</p>
<p>比如当使用jpa的时候，也就是pom中加入了spring-boot-starter-data-jpa这个starter之后(之前我们分析过<a href="http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/">springboot的自动化配置原理</a>)。</p>
<p>Springboot会构造一个JpaTransactionManager这个事务管理器。</p>
<p>而当我们使用spring-boot-starter-jdbc的时候，构造的事务管理器则是DataSourceTransactionManager。</p>
<p>这2个事务管理器都实现了spring中提供的PlatformTransactionManager接口，这个接口是spring的事务核心接口。</p>
<p>这个核心接口有以下这几个常用的实现策略：</p>
<ol>
<li>HibernateTransactionManager</li>
<li>DataSourceTransactionManager</li>
<li>JtaTransactionManager</li>
<li>JpaTransactionManager</li>
</ol>
<p>具体的PlatformTransactionManager继承关系如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/transactionmanager.png" alt=""></p>
<a id="more"></a>
<p>spring-boot-starter-data-jpa这个starter会触发HibernateJpaAutoConfiguration这个自动化配置类，HibernateJpaAutoConfiguration继承了JpaBaseConfiguration基础类。</p>
<p>在JpaBaseConfiguration中构造了事务管理器：</p>
<pre><code>@Bean
@ConditionalOnMissingBean(PlatformTransactionManager.class)
public PlatformTransactionManager transactionManager() {
    return new JpaTransactionManager();
}
</code></pre><p>spring-boot-starter-jdbc会触发DataSourceTransactionManagerAutoConfiguration这个自动化配置类，也会构造事务管理器：</p>
<pre><code>@Bean
@ConditionalOnMissingBean(PlatformTransactionManager.class)
@ConditionalOnBean(DataSource.class)
public DataSourceTransactionManager transactionManager() {
    return new DataSourceTransactionManager(this.dataSource);
}
</code></pre><p>Spring的事务管理器PlatformTransactionManager接口中定义了3个方法：</p>
<pre><code>// 基于事务的传播特性，返回一个已经存在的事务或者创建一个新的事务
TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;

// 提交事务
void commit(TransactionStatus status) throws TransactionException;

// 回滚事务
void rollback(TransactionStatus status) throws TransactionException;
</code></pre><p>其中TransactionDefinition接口表示跟spring兼容的事务属性，比如传播行为、隔离级别、超时时间、是否只读等属性。</p>
<p>DefaultTransactionDefinition类是一个默认的TransactionDefinition实现，它的传播行为是PROPAGATION_REQUIRED(如果当前没事务，则创建一个，否则加入到当前事务中)，隔离级别是数据库默认级别。</p>
<p>TransactionStatus接口表示事务的状态，比如事务是否是一个刚构造的事务、事务是否已经完成等状态。</p>
<p>下面这段代码就是传统事务的常见写法：</p>
<pre><code>transaction.begin();
try {
    ...
    transaction.commit();
} catch(Exception e) {
    ...
    transaction.rollback();
} finally {

}
</code></pre><p>由于spring的事务操作被封装到了PlatformTransactionManager接口中，commit和rollback方法对应接口中的方法，begin方法在getTransaction方法中会被调用。</p>
<p>细心的读者发现文章前面构造事务管理器的时候都会加上这段注解：</p>
<pre><code>@ConditionalOnMissingBean(PlatformTransactionManager.class)
</code></pre><p>也就是说如果我们手动配置了事务管理器，Springboot就不会再为我们自动配置事务管理器。</p>
<p>如果要使用多个事务管理器的话，那么需要手动配置多个：</p>
<pre><code>@Configuration
public class DatabaseConfiguration {

    @Bean
    public PlatformTransactionManager transactionManager1(EntityManagerFactory entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory);
    }

    @Bean
    public PlatformTransactionManager transactionManager2(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }

}
</code></pre><p>然后使用Transactional注解的时候需要声明是哪个事务管理器：</p>
<pre><code>@Transactional(value=&quot;transactionManager1&quot;)
public void save() {
    doSave();
}
</code></pre><p>Spring给我们提供了一个TransactionManagementConfigurer接口，该接口只有一个方法返回PlatformTransactionManager。其中返回的PlatformTransactionManager就表示这是默认的事务处理器，这样在Transactional注解上就不需要声明是使用哪个事务管理器了。</p>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/davidwang456/p/4309038.html" target="_blank" rel="external">http://www.cnblogs.com/davidwang456/p/4309038.html</a></p>
<p><a href="http://blog.csdn.net/chjttony/article/details/6528344" target="_blank" rel="external">http://blog.csdn.net/chjttony/article/details/6528344</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Springboot内部提供的事务管理器是根据autoconfigure来进行决定的。&lt;/p&gt;
&lt;p&gt;比如当使用jpa的时候，也就是pom中加入了spring-boot-starter-data-jpa这个starter之后(之前我们分析过&lt;a href=&quot;http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/&quot;&gt;springboot的自动化配置原理&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;Springboot会构造一个JpaTransactionManager这个事务管理器。&lt;/p&gt;
&lt;p&gt;而当我们使用spring-boot-starter-jdbc的时候，构造的事务管理器则是DataSourceTransactionManager。&lt;/p&gt;
&lt;p&gt;这2个事务管理器都实现了spring中提供的PlatformTransactionManager接口，这个接口是spring的事务核心接口。&lt;/p&gt;
&lt;p&gt;这个核心接口有以下这几个常用的实现策略：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HibernateTransactionManager&lt;/li&gt;
&lt;li&gt;DataSourceTransactionManager&lt;/li&gt;
&lt;li&gt;JtaTransactionManager&lt;/li&gt;
&lt;li&gt;JpaTransactionManager&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体的PlatformTransactionManager继承关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wh6.com1.z0.glb.clouddn.com/transactionmanager.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Netty的单元测试</title>
    <link href="http://fangjian0423.github.io/2016/09/03/netty-unittest/"/>
    <id>http://fangjian0423.github.io/2016/09/03/netty-unittest/</id>
    <published>2016-09-03T13:04:52.000Z</published>
    <updated>2016-09-03T12:47:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在编写完Netty程序之后，会需要进行ChannelHandler的一些测试。</p>
<p>在初学Netty的时候，我们都是直接起一个Server，然后再写一个Client去连接Server，看传输的数据和接收到的数据是否正确。</p>
<p>在<a href="https://book.douban.com/subject/24700704/" target="_blank" rel="external">Netty in Action</a>书中的Transport和Unit-test your code这两章就提出了可以使用EmbeddedChannel进行ChanndlHandler的单元测试。</p>
<a id="more"></a>
<h2 id="EmbeddedChannel介绍"><a href="#EmbeddedChannel介绍" class="headerlink" title="EmbeddedChannel介绍"></a>EmbeddedChannel介绍</h2><p>EmbeddedChannel中提供了一些方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>writeInbound</td>
<td>写数据到Channel中，但是这些数据只会被ChannelPipeline中的inbound handler处理。如果可以从EmbeddedChannel的readInbound方法中读取出数据的话，就返回true</td>
</tr>
<tr>
<td>readInbound</td>
<td>读取在EmbeddedChannel上被所有inbound handler处理过的数据，如果已经没有数据可以读取就返回null</td>
</tr>
<tr>
<td>writeInbound</td>
<td>写数据到Channel中，但是这些数据只会被ChannelPipeline中的outbound handler处理。如果可以从EmbeddedChannel的readOutbound方法中读取出数据的话，就返回true</td>
</tr>
<tr>
<td>readOutbound</td>
<td>读取在EmbeddedChannel上被所有outbound handler处理过的数据，如果已经没有数据可以读取就返回null</td>
</tr>
<tr>
<td>finish</td>
<td>标记EmbeddedChannel已经完成。如果可以从inbound或者outbound中返回数据，该方法就返回true。这个方法还会关闭Channel</td>
</tr>
</tbody>
</table>
<p>下图就是EmbeddedChannel的处理流程图：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty10.png" alt=""></p>
<p>使用writeInbound方法写入的数据，并经过Pipeline中所有的inbound handler，之后可以使用readInbound方法读取经过inbound handler之后的数据。</p>
<p>使用writeOutbound方法写入的数据，并经过Pipeline中所有的outbound handler，之后可以使用readOutbound方法读取经过outbound handler之后的数据。</p>
<p>调用finish方法可以标记EmbeddedChannel已经完成。</p>
<h2 id="Inbound-Handler的测试"><a href="#Inbound-Handler的测试" class="headerlink" title="Inbound Handler的测试"></a>Inbound Handler的测试</h2><p>Netty内部提供了一个FixedLengthFrameDecoder解码器用于把长度不固定的字节转换成固定长度的字节，处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty11.png" alt=""></p>
<p>针对这个Decoder编写单元测试。</p>
<p>由于是个Decoder，针对的是inbound中的数据，所以需要使用的方法是writeInbound和readInbound：</p>
<pre><code>ByteBuf buf = Unpooled.buffer(); // 构造heap buffer
for(int i = 0; i &lt; 9; i ++) { // 写入9个字节
    buf.writeByte(i);
}

ByteBuf input = buf.copy();

// 构造EmbeddedChannel，并在Pipeline中加入FixedLengthFrameDecoder
EmbeddedChannel channel = new EmbeddedChannel(new FixedLengthFrameDecoder(3));

// 使用writeInbound方法写入数据
Assert.assertTrue(channel.writeInbound(input));
// 标记EmbeddedChannel状态已经complete
Assert.assertTrue(channel.finish());

// 读取经过FixedLengthFrameDecoder处理过后的字节
Assert.assertEquals(buf.readBytes(3), channel.readInbound());
Assert.assertEquals(buf.readBytes(3), channel.readInbound());
Assert.assertEquals(buf.readBytes(3), channel.readInbound());
Assert.assertNull(channel.readInbound());
</code></pre><p>我们在<a href="http://fangjian0423.github.io/2016/08/30/netty-custom-protocol/">使用Netty编写自定义的协议</a>文章中编写的自定义协议CustomProtocol的解码器，并最后通过一个server和client的编写完成了测试。</p>
<p>现在我们可以使用EmbeddedChannel进行Decoder的unit test：</p>
<pre><code>EmbeddedChannel channel = new EmbeddedChannel(new CustomProtocolDecoder());
String uuid = UUID.randomUUID().toString();
channel.writeInbound(new CustomProtocol(1024l, uuid, &quot;content content&quot;));
Assert.assertTrue(channel.finish());

CustomProtocol customProtocol = (CustomProtocol) channel.readInbound();
// 判断是否正确
Assert.assertEquals(1024l, customProtocol.getVersion());
Assert.assertEquals(uuid, customProtocol.getHeader());
Assert.assertEquals(&quot;content content&quot;, customProtocol.getContent());
Assert.assertNull(channel.readInbound());
</code></pre><h2 id="Outbound-Handler的测试"><a href="#Outbound-Handler的测试" class="headerlink" title="Outbound Handler的测试"></a>Outbound Handler的测试</h2><p>AbsIntegerEncoder对所有的int数据取绝对值。处理流过图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty12.png" alt=""></p>
<pre><code>public class AbsIntegerEncoder extends MessageToMessageEncoder&lt;ByteBuf&gt; {
    @Override
    protected void encode(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out) throws Exception {
        while(msg.readableBytes() &gt;= 4) {
            int value = Math.abs(msg.readInt());
            out.add(value);
        }
    }
}
</code></pre><p>针对这个Encoder编写单元测试。</p>
<p>由于是个Encoder，针对的是outbound中的数据，所以需要使用的方法是writeOutbound和readOutbound：</p>
<pre><code>ByteBuf buf = Unpooled.buffer(); // 构造heap buffer
for(int i = 1; i &lt; 10; i ++) { // 写入10个负数
    buf.writeInt(i * -1);
}
// 构造EmbeddedChannel，并在Pipeline中加入AbsIntegerEncoder
EmbeddedChannel channel = new EmbeddedChannel(new AbsIntegerEncoder());
// 使用writeOutbound方法写入数据
Assert.assertTrue(channel.writeOutbound(buf));
// 标记EmbeddedChannel状态已经complete
Assert.assertTrue(channel.finish());

// 测试是否所有的int数据都取了绝对值
for(int i = 1; i &lt; 10; i ++) {
    Assert.assertEquals(i, (int)channel.readOutbound());
}
Assert.assertNull(channel.readOutbound());
</code></pre><p>同理我们可以使用EmbeddedChannel进行CustomProtocol的Encoder的unit test：</p>
<pre><code>EmbeddedChannel channel = new EmbeddedChannel(new CustomProtocolEncoder());
String uuid = UUID.randomUUID().toString();

channel.writeOutbound(new CustomProtocol(1024l, uuid, &quot;content content&quot;));
Assert.assertTrue(channel.finish());

ByteBuf buf = (ByteBuf) channel.readOutbound();
Assert.assertEquals(1024l, buf.readLong());
byte[] headerBytes = new byte[36];
buf.readBytes(headerBytes);
Assert.assertEquals(uuid, new String(headerBytes));
byte[] contentBytes = new byte[buf.readableBytes()];
buf.readBytes(contentBytes);
Assert.assertEquals(&quot;content content&quot;, new String(contentBytes));
Assert.assertNull(channel.readOutbound());
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在编写完Netty程序之后，会需要进行ChannelHandler的一些测试。&lt;/p&gt;
&lt;p&gt;在初学Netty的时候，我们都是直接起一个Server，然后再写一个Client去连接Server，看传输的数据和接收到的数据是否正确。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://book.douban.com/subject/24700704/&quot;&gt;Netty in Action&lt;/a&gt;书中的Transport和Unit-test your code这两章就提出了可以使用EmbeddedChannel进行ChanndlHandler的单元测试。&lt;/p&gt;
    
    </summary>
    
      <category term="netty" scheme="http://fangjian0423.github.io/categories/netty/"/>
    
    
      <category term="nio" scheme="http://fangjian0423.github.io/tags/nio/"/>
    
      <category term="netty" scheme="http://fangjian0423.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>使用Netty编写自定义的协议</title>
    <link href="http://fangjian0423.github.io/2016/08/30/netty-custom-protocol/"/>
    <id>http://fangjian0423.github.io/2016/08/30/netty-custom-protocol/</id>
    <published>2016-08-30T14:04:52.000Z</published>
    <updated>2016-08-30T13:28:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Netty内部提供的Codec用于处理消息的编解码问题，比如Http，Ftp，SMTP这些协议，都需要进行编解码。</p>
<p>Netty内部直接提供了Http协议的Codec组件用于编解码Http协议。</p>
<p>在开发过程中，有时候我们需要构建一些适应自己业务的应用层协议，Netty可以很方便地实现自定义协议。</p>
<p>比如我们的自定义协议CucstomProtocol结构如下：</p>
<pre><code>| version | header | content |
</code></pre><p>其中version表示版本号，long类型；header是一个uuid，string类型，content则是具体的内容，string类型。</p>
<a id="more"></a>
<p>对应的POJO如下：</p>
<pre><code>public class CustomProtocol {
    private long version; // 版本
    private String header; // 头信息(UUID)
    private String content; // 具体内容
    // GET SET ...
    @Override
    public String toString() {
        return &quot;CustomProtocol{&quot; +
                &quot;version=&quot; + version +
                &quot;, header=&apos;&quot; + header + &apos;\&apos;&apos; +
                &quot;, content=&apos;&quot; + content + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}
</code></pre><p>解码器把byte转换成CustomProtocol，在server中使用：</p>
<pre><code>public class CustomProtocolDecoder extends ByteToMessageDecoder {
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {
        long version = in.readLong(); // 读取version

        byte[] headerBytes = new byte[36];
        in.readBytes(headerBytes); // 读取header

        String header = new String(headerBytes);

        byte[] contentBytes = new byte[in.readableBytes()]; // 读取content
        in.readBytes(contentBytes);

        out.add(new CustomProtocol(version, header, new String(contentBytes)));
    }
}
</code></pre><p>编码器把CustomProtocol转换成byte，在client中使用：</p>
<pre><code>public class CustomProtocolEncoder extends MessageToByteEncoder&lt;CustomProtocol&gt; {
    @Override
    protected void encode(ChannelHandlerContext ctx, CustomProtocol msg, ByteBuf out) throws Exception {
        out.writeLong(msg.getVersion());
        out.writeBytes(msg.getHeader().getBytes());
        out.writeBytes(msg.getContent().getBytes());
    }
}
</code></pre><p>server代码：</p>
<pre><code>ServerBootstrap serverBootstrap = new ServerBootstrap();
EventLoopGroup eventLoopGroup = new NioEventLoopGroup();
EventLoopGroup childEventLoopGroup = new NioEventLoopGroup();

try {
    serverBootstrap
            .group(eventLoopGroup, childEventLoopGroup)
            .channel(NioServerSocketChannel.class)
            .childHandler(new ChannelInitializer&lt;Channel&gt;() {
                @Override
                protected void initChannel(Channel ch) throws Exception {
                    ch.pipeline().addLast(new CustomProtocolDecoder()); // 解码器
                    ch.pipeline().addLast(new ServerHandler()); // 打印数据
                }
            });

    ChannelFuture future = serverBootstrap.bind(&quot;localhost&quot;, 9999).sync();

    future.channel().closeFuture().sync();
} catch (Exception e) {
    e.printStackTrace();
} finally {
    try {
        eventLoopGroup.shutdownGracefully().sync();
        childEventLoopGroup.shutdownGracefully().sync();
    } catch (Exception e1) {
        e1.printStackTrace();
    }
}
</code></pre><p>ServerHandler用于打印接收到的数据，并写数据回去给客户端表示接收到了数据：</p>
<pre><code>public class ServerHandler extends SimpleChannelInboundHandler&lt;CustomProtocol&gt; {
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, CustomProtocol msg) throws Exception {
        System.out.println(&quot;server receive: &quot; + msg);
        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;server get&quot;, CharsetUtil.UTF_8)).addListener(ChannelFutureListener.CLOSE);
    }
}
</code></pre><p>client代码：</p>
<pre><code>Bootstrap bootstrap = new Bootstrap();

EventLoopGroup eventLoopGroup = new NioEventLoopGroup();

try {
    bootstrap
            .group(eventLoopGroup)
            .channel(NioSocketChannel.class)
            .handler(new ChannelInitializer&lt;Channel&gt;() {
                @Override
                protected void initChannel(Channel ch) throws Exception {
                    ch.pipeline().addLast(new CustomProtocolEncoder()); // 编码器
                    ch.pipeline().addLast(new ClientHandler()); // 接收服务端数据
                }
            });
    ChannelFuture channelFuture = bootstrap.connect(&quot;localhost&quot;, 9999).sync();

    channelFuture.channel().writeAndFlush(new CustomProtocol(1024l, UUID.randomUUID().toString(), &quot;content detail&quot;));

    channelFuture.channel().closeFuture().sync();
} catch (Exception e) {
    e.printStackTrace();
} finally {
    try {
        eventLoopGroup.shutdownGracefully().sync();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre><p>ClientHandler用于接收服务端返回回来的数据：</p>
<pre><code>public class ClientHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; {
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
        System.out.println(&quot;send success, response is: &quot; + msg.toString(CharsetUtil.UTF_8));
    }
}
</code></pre><p>启动服务端和客户端之后，服务端收到客户端发来的CustomProtocol：</p>
<pre><code>server receive: CustomProtocol{version=1024, header=&apos;6ed7fa3d-7d54-4add-9081-d659d4b37d3f&apos;, content=&apos;content detail&apos;}
</code></pre><p>之后客户端也收到服务端成功接收数据的反馈：</p>
<pre><code>send success, response is: server get
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Netty内部提供的Codec用于处理消息的编解码问题，比如Http，Ftp，SMTP这些协议，都需要进行编解码。&lt;/p&gt;
&lt;p&gt;Netty内部直接提供了Http协议的Codec组件用于编解码Http协议。&lt;/p&gt;
&lt;p&gt;在开发过程中，有时候我们需要构建一些适应自己业务的应用层协议，Netty可以很方便地实现自定义协议。&lt;/p&gt;
&lt;p&gt;比如我们的自定义协议CucstomProtocol结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;| version | header | content |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中version表示版本号，long类型；header是一个uuid，string类型，content则是具体的内容，string类型。&lt;/p&gt;
    
    </summary>
    
      <category term="netty" scheme="http://fangjian0423.github.io/categories/netty/"/>
    
    
      <category term="nio" scheme="http://fangjian0423.github.io/tags/nio/"/>
    
      <category term="netty" scheme="http://fangjian0423.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty in Action笔记(二)</title>
    <link href="http://fangjian0423.github.io/2016/08/29/netty-in-action-note2/"/>
    <id>http://fangjian0423.github.io/2016/08/29/netty-in-action-note2/</id>
    <published>2016-08-29T12:36:52.000Z</published>
    <updated>2016-08-29T12:07:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录ChannelHandler、Codec以及Bootstrap的作用，还有Netty内置的一些ChannelHandler、Codec，以及Bootstrap的分类。</p>
<a id="more"></a>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>介绍Netty中的Channel、ChannelHandler、ChannelHandlerContext以及ChannelPipeline。</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>定义：一个Channel表示一个通道，跟io中的stream的角色一样，但是有几点不同。 1. stream是单向的，只支持读或者写，channel是双向的，既支持读也支持写。2. stream是阻塞的，channel是并行的。</p>
<p>其中Channel的生命周期状态如下：</p>
<table>
<thead>
<tr>
<th>状态说明</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>channelUnregistered</td>
<td>channel创建之后，还未注册到EventLoop</td>
</tr>
<tr>
<td>channelRegistered</td>
<td>channel注册到了对应的EventLoop</td>
</tr>
<tr>
<td>channelActive</td>
<td>channel处于活跃状态，活跃状态表示已经连接到了远程服务器，现在可以接收和发送数据</td>
</tr>
<tr>
<td>channelInactive</td>
<td>channel未连接到远程服务器</td>
</tr>
</tbody>
</table>
<p>一个Channel正常的生命周期如下：</p>
<p>channelRegistered -&gt; channelActice -&gt; channelInactive -&gt; channelUnregistered</p>
<p>在另外一种特殊情况下，会发生多次channelRegistered和channelUnregistered，这是因为用户可以从EventLoop上取消注册Channel来阻止事件的执行并在之后重新注册。状态变化如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty03.png" alt=""></p>
<h3 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h3><p>ChannelHandler有2种类型：</p>
<ol>
<li>Inbound Handler: 处理inbound数据(接收到的数据)以及所有类型的channel状态修改事件</li>
<li>Outbound Handler: 处理outbound数据(发送出去的数据)并且可以拦截各种操作，比如bind、connect、disconnect、close、write等操作</li>
</ol>
<p>Inbound和Outbound Handler都属于ChannelHandler，它们都可以被添加到ChannelPipeline中，它们内部也提供了handlerAdded、handlerRemoved这两种方法分别在ChannelHandler添加到ChannelPipeline和ChannelHandler从ChannelPipeline中被删除的时候触发。</p>
<h4 id="ChannelInboundHandler"><a href="#ChannelInboundHandler" class="headerlink" title="ChannelInboundHandler"></a>ChannelInboundHandler</h4><p>ChannelInboundHandler方法在两种情况下触发：channel状态的改变和channel接收到数据。</p>
<p>一些方法说明：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>channelRegistered(..)</td>
<td>Channel注册到EventLoop，并且可以处理IO请求</td>
</tr>
<tr>
<td>channelUnregistered(…)</td>
<td>Channel从EventLoop中被取消注册，并且不能处理任何IO请求</td>
</tr>
<tr>
<td>channelActive(…)</td>
<td>Channel已经连接到远程服务器，并准备好了接收数据</td>
</tr>
<tr>
<td>channelInactive(…)</td>
<td>Channel还没有连接到远程服务器</td>
</tr>
<tr>
<td>channelReadComplete(…)</td>
<td>Channel的读取操作已经完成</td>
</tr>
<tr>
<td>channelRead(…)</td>
<td>有数据可以读取的时候触发</td>
</tr>
<tr>
<td>userEventTriggered(…)</td>
<td>当用户调用Channel.fireUserEventTriggered方法的时候触发，用户可以传递一个自定义的对象当这个方法里</td>
</tr>
</tbody>
</table>
<p>ChannelInboundHandler有一个实现ChannelInboundHandlerAdapter，它实现了所有的方法，我们只需要继承这个类然后复写需要的方法即可。</p>
<p>ChannelInboundHandler中的channelRead方法中有读取的ByteBuf。由于Netty在ByteBuf的使用上使用了池的概念，当不需要这个ByteBuf的时候需要进行资源的释放以减少内存的消耗。</p>
<pre><code>@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
      // do something
      ReferenceCountUtil.release(msg);
}
</code></pre><p>Netty内部提供了一个SimpleChannelInboundHandler类，这个类读取数据会自动释放资源。它继承ChannelInboundHandlerAdapter并复写了channelRead方法，在channelRead方法里面finally代码里会自动release资源，并提供了channelRead0方法：</p>
<pre><code>@Override
public void channelRead0(ChannelHandlerContext ctx, Object msg) {
      // do something, do not need release
}
</code></pre><p>所以一般使用ChannelInboundHandler的话，有3种方法。 </p>
<ol>
<li>直接实现ChannelInBoundHandler接口 </li>
<li>继承ChannelInboundHandlerAdapter</li>
<li>继承SimpleChannelInboundHandler</li>
</ol>
<p>第1种基本不用，第3种用来处理接收消息，第2种用来处理事件状态的改变</p>
<h4 id="ChannelOutboundHandler"><a href="#ChannelOutboundHandler" class="headerlink" title="ChannelOutboundHandler"></a>ChannelOutboundHandler</h4><p>ChannelOutboundHandler方法在两种情况下触发：发送数据和拦截操作。</p>
<p>ChannelOutboundHandler有一个强大的功能，可以按需推迟一个操作，这使得处理请求可以用到更为复杂的策略。比如，如果写数据到远端被暂停，你可以推迟flush操作，稍后再试。</p>
<p>一些方法说明：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>bind(..)</td>
<td>请求绑定channel到本地地址</td>
</tr>
<tr>
<td>connect(…)</td>
<td>channel连接到远程地址</td>
</tr>
<tr>
<td>disconnect(…)</td>
<td>channel从远程服务器上断开</td>
</tr>
<tr>
<td>close(…)</td>
<td>关闭channel</td>
</tr>
<tr>
<td>deregister(…)</td>
<td>取消channel在eventloop上的注册</td>
</tr>
<tr>
<td>read(…)</td>
<td>在channel中读数据</td>
</tr>
<tr>
<td>flush(…)</td>
<td>flush数据到远程服务器</td>
</tr>
<tr>
<td>write(…)</td>
<td>写数据到远程服务器</td>
</tr>
</tbody>
</table>
<p>ChannelOutboundHandler有一个实现ChannelOutboundHandlerAdapter，它实现了所有的方法，我们只需要继承这个类然后复写需要的方法即可。</p>
<p>在outboundhandler中有时候也需要释放资源，当消息被消费并且不再需要传递给下一个outbound handler的时候，调用ReferenceCountUtil.release(message)释放消息。</p>
<p>当消息被写回去或者channel关闭的时候，这个消息的资源会被自动释放，所以没有一个类似SimpleChannelInboundHandler的概念。</p>
<h3 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h3><p>当ChannelHandler被添加到ChannelPipeline中的时候，ChannelHandlerContext会被创建。<br>所以说ChannelHandlerContext属于ChannelHandler。</p>
<p>可以通过ChannelHandlerContext的channel方法得到Channel和pipeline方法得到ChannelPipeline。</p>
<p>ChannelHandlerContext可以被保留下来并且在其他地方进行调用，比如在其他线程，或者在handler外部进行调用。</p>
<p>可以使用以下方法保留ChannelHandlerContext：</p>
<pre><code>class WriterHandler extends ChannelHandlerAdapter {
  private ChannelHandlerContext ctx;

  @Override
  public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
      this.ctx = ctx;
  }

  public void send(String msg) {
      ctx.write(msg);
  }
}
</code></pre><p>Netty中提供了一个@Sharable注解用来将一个实例的ChannelHandler添加到多个ChannelPipeline中，如果不加上这个注解，被多个ChannelPipeline使用的话会抛出异常。</p>
<h3 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h3><p>多个ChannelHandler可以组成一个ChannelPipeline，里面的每个ChannelHandler可以转发给下一个ChannelHandler。</p>
<p>ChannelPipeline内部的所有ChannelHandler的处理流程图：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty01.png" alt=""></p>
<p>ChannelPipeline提供了多种方法用于添加或删除或代替ChannelHandler，比如addLast, addFirst, remove, replace等方法。</p>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><p>介绍Netty中的编码器、解码器。我们知道网络中传输的是字节-ByteBuf。我们需要对ByteBuf进行一些解码用于解码成熟悉的POJO，对ByteBuf进行编码用于网络传输。</p>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>解码器，针对的是inbound的数据，也就是读取数据的解码。</p>
<p>2种类型：</p>
<ol>
<li>bytes到message的解码(ByteToMessageDecoder和ReplayingDecoder)</li>
<li>message到message的解码(MessageToMessageDecoder)</li>
</ol>
<p>decoders的作用是把inbound中读取的数据从一种格式转换成另一种格式，由于decoders处理的是inbound中的数据，所以它也是ChannelInboundHandler的一种实现类。</p>
<p>ByteToMessageDecoder和ReplayingDecoder属于bytes到message的解码。</p>
<p>一个ByteToMessageDecoder例子，将byte转换成integer：</p>
<pre><code>public class ToIntegerDecoder extends ByteToMessageDecoder {
    @Override  protected void decode(ChannelHandlerContext ctx, ByteBuf in,     List&lt;Object&gt; out) throws Exception {
        if(in.readableBytes() &gt;= 4) {
            out.add(in.readInt());
        }
    }    
}
</code></pre><p>处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty04.png" alt=""></p>
<p>如果使用ReplayingDecoder，不需要进行可读字节的判断，直接添加到List里即可。跟ToIntegerDecoder实现一样的功能，ReplayingDecoder只需要这样即可。(但是有一定的局限性：1.不是所有的操作都被ByteBuf支持 2.ByteBuf.readableBytes方法大部分时间不会返回期望的值)</p>
<pre><code>public class ToIntegerDecoder2 extends ReplayingDecoder&lt;Void&gt; {
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt;     out) throws Exception {
        out.add(in.readInt());
    }
}
</code></pre><p>一个MessageToMessageDecoder例子，将integer转换成string：</p>
<pre><code>public class IntegerToStringDecoder extends MessageToMessageDecoder&lt;Integer&gt; {
    @Override
    protected void decode(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out) throws Exception {
        out.add(String.valueOf(msg));
    }
}
</code></pre><p>处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty05.png" alt=""></p>
<h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><p>编码器，针对的是outbound的数据，也就是发送出去的数据的编码。</p>
<p>2种类型：</p>
<ol>
<li>message到message的编码(MessageToMessageEncoder)</li>
<li>message到byte的编码(MessageToByteEncoder)</li>
</ol>
<p>decoders的作用是把outbound中发送出去的数据从一种格式转换成另一种格式，由于eecoders处理的是outbound中的数据，所以它也是ChannelOutboundHandler的一种实现类。</p>
<p>一个MessageToByteEncoder例子，将integer转换成byte：</p>
<pre><code>public class IntegerToByteEncoder extends MessageToByteEncoder&lt;Integer&gt; {
    @Override
    protected void encode(ChannelHandlerContext ctx, Integer msg, ByteBuf out) throws Exception {
        out.writeInt(msg);
    }
}
</code></pre><p>处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty06.png" alt=""></p>
<p>一个MessageToMessageEncoder例子，将integer转换成string：</p>
<pre><code>public class IntegerToStringEncoder extends MessageToMessageEncoder&lt;Integer&gt; {
    @Override
    protected void encode(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out) throws Exception {
        out.add(String.valueOf(msg));
    }
}
</code></pre><p>处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty07.png" alt=""></p>
<h3 id="Codec"><a href="#Codec" class="headerlink" title="Codec"></a>Codec</h3><p>编解码器，既支持编码器的功能，也支持解码器的功能。</p>
<p>2种类型：</p>
<ol>
<li>ByteToMessageCodec：message到byte的编解码</li>
<li>MessageToMessageCodec：message到message的编解码</li>
</ol>
<h3 id="CombinedChannelDuplexHandler"><a href="#CombinedChannelDuplexHandler" class="headerlink" title="CombinedChannelDuplexHandler"></a>CombinedChannelDuplexHandler</h3><p>结合解码器和编码器在一起可能会牺牲可重用性。为了避免这种方式，可以使用CombinedChannelDuplexHandler。</p>
<p>CombinedChannelDuplexHandler也就是codec的另外一种方式，如果已经有个encoder和decoder，不需要重新写了codec，直接使用CombinedChannelDuplexHandler整合这个encoder和decoder即可。</p>
<p>上面的ToIntegerDecoder和IntegerToByteEncoder就可以构成一个编解码器，直接使用CombinedChannelDuplexHandler即可。</p>
<pre><code>public class CombinedByteIntegerCodec extends CombinedChannelDuplexHandler&lt;ToIntegerDecoder, IntegerToByteEncoder&gt; {
    public CombinedByteIntegerCodec() {
        super(new ToIntegerDecoder(), new IntegerToByteEncoder());
    }
}
</code></pre><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><p>主要说明jetty内置的一些ChannelHandler和Codec。</p>
<p>使用SSL/TLS加密Netty程序的话，可以使用内置的SslHandler。</p>
<p>要构建Http应用的话，可以使用HttpClientCodec/HttpServerCodec(http客户端和服务端的编解码)以及HttpObjectAggregator(Http的消息聚合)。</p>
<p>可以使用HttpContentDecompressor和HttpContentCompressor对http的内容进行解压和压缩。</p>
<p>还有一些WebSocket、SPDY，一些空置链接、超时链接等处理的内置解决方案。</p>
<h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><p>主要讲解Bootstrap中Netty中的作用。</p>
<p>之前分析过各种ChannelHandler，各种Codec，以及把这两个东西添加到Channel 的ChannelPipeline中。有了这些东西之后，该用什么把他们整合起来呢，那就是Bootstrap。</p>
<p>Bootstrap分别ServerBootstrap(服务端)和Bootstrap(客户端)，它们都继承AbstractBootstrap。</p>
<h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><p>客户端服务启动类，内部提供的一些方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>group(..)</td>
<td>设置Bootstrap使用的EventLoopGroup，用来处理Channel的IO操作</td>
</tr>
<tr>
<td>channel(..)</td>
<td>Channel的类型，比如有NioSocketChannel, OioSocketChannel等</td>
</tr>
<tr>
<td>channelFactory(..)</td>
<td>如果Channel没有没有参数的构造函数，需要使用ChannelFactory构造Channel</td>
</tr>
<tr>
<td>localAddress(..)</td>
<td>Channel需要绑定的地址和端口，可以不调用，使用connect或者bind再进行设置</td>
</tr>
<tr>
<td>option(..)</td>
<td>一些可选的设置，使用ChannelOptions完成。比如keep-alive时间，超时时间</td>
</tr>
<tr>
<td>handler(..)</td>
<td>设置ChannelHandler处理事件</td>
</tr>
<tr>
<td>clone(..)</td>
<td>复制一个新的Bootstrap，AbstractBootstrap实现了Cloneable接口</td>
</tr>
<tr>
<td>remoteAddress()..)</td>
<td>设置远程地址，也可以在调用connect方法的时候设置</td>
</tr>
<tr>
<td>connect()..)</td>
<td>链接到远程地址</td>
</tr>
<tr>
<td>bind()..)</td>
<td>绑定本地端口</td>
</tr>
</tbody>
</table>
<p>需要注意的是如果EventLoopGroup选择的是NioEventLoopGroup，那么对应的channel需要选择NioSocketChannel，否则会抛出兼容性的错误异常。</p>
<h3 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h3><p>服务端服务启动类，内部提供的一些方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>group(..)</td>
<td>设置ServerBootstrap使用的EventLoopGroup，用来处理ServerChannel的IO操作并接收Channel</td>
</tr>
<tr>
<td>channel(..)</td>
<td>ServerChannel的类型，比如有NioServerSocketChannel, OioServerSocketChannel等</td>
</tr>
<tr>
<td>channelFactory(..)</td>
<td>如果ServerChannel没有没有参数的构造函数，需要使用ChannelFactory构造ServerChannel</td>
</tr>
<tr>
<td>localAddress(..)</td>
<td>ServerChannel需要绑定的地址和端口，可以不调用，使用connect或者bind再进行设置</td>
</tr>
<tr>
<td>option(..)</td>
<td>一些ServerChannel可选的设置，使用ChannelOptions完成。比如keep-alive时间，超时时间</td>
</tr>
<tr>
<td>childOption(..)</td>
<td>被ServerChannel接收的Channel的可选的设置，使用ChannelOptions完成</td>
</tr>
<tr>
<td>handler(..)</td>
<td>设置ServerChannel的ChannelHandler处理事件</td>
</tr>
<tr>
<td>childHandler(..)</td>
<td>设置被ServerChannel接收的Channel的ChannelHandler处理事件</td>
</tr>
<tr>
<td>clone(..)</td>
<td>复制一个新的ServerBootstrap，AbstractBootstrap实现了Cloneable接口</td>
</tr>
<tr>
<td>bind()..)</td>
<td>绑定本地端口</td>
</tr>
</tbody>
</table>
<p>ServerBootstrap的处理过程：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty08.png" alt=""></p>
<p>ServerBootstrap调用bind绑定地址和端口的时候，会创建ServerChannel。这个ServerChannel会接收客户的各个链接，针对各个链接创建Channel。</p>
<p>handler方法就是为ServerChannel服务的，而childHandler是给被ServerChannel接收的Channel服务器的。所以说只要服务器已起来，handler中的ChannelHandler就会触发，而有链接被ServerChannel接收之后childHandler中的ChannelHandler才会触发。</p>
<h3 id="从一个已经存在的Channel中使用Bootstrap启动客户端"><a href="#从一个已经存在的Channel中使用Bootstrap启动客户端" class="headerlink" title="从一个已经存在的Channel中使用Bootstrap启动客户端"></a>从一个已经存在的Channel中使用Bootstrap启动客户端</h3><p>在ServerBootstrap接收到新的Channel的时候准备启动Bootstrap客户端的时候，可以使用一个全新的EventLoop用于处理Channel的IO模型。</p>
<p>但是没有必要，可以跟ServerBootstrap共享同一个EventLoop，因为一个EventLoop是跟一个线程绑定的，如果使用了多个EventLoop的话，那就相当于需要进行线程的上下文切换，需要消耗一定的资源。</p>
<p>1个在ServerBootstrap接收到链接之后，使用Bootstrap链接另外一个地址的处理过程：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty09.png" alt=""></p>
<p>其中第3点就是ServerChannel接收到的新的Channel，第5点是Bootstrap创建的连接到远程服务器的Channel，它们使用同一个EventLoop。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要记录ChannelHandler、Codec以及Bootstrap的作用，还有Netty内置的一些ChannelHandler、Codec，以及Bootstrap的分类。&lt;/p&gt;
    
    </summary>
    
      <category term="netty" scheme="http://fangjian0423.github.io/categories/netty/"/>
    
    
      <category term="nio" scheme="http://fangjian0423.github.io/tags/nio/"/>
    
      <category term="netty" scheme="http://fangjian0423.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty in Action笔记(一)</title>
    <link href="http://fangjian0423.github.io/2016/08/19/netty-in-action-note1/"/>
    <id>http://fangjian0423.github.io/2016/08/19/netty-in-action-note1/</id>
    <published>2016-08-18T17:36:52.000Z</published>
    <updated>2016-08-18T17:41:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>一篇读书笔记，根据章节进行下总结。已经看了5章，先对这5个章节做个小总结。</p>
<a id="more"></a>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>然后介绍了一下Netty出来的背景以及Netty所拥有的一些强大的特性，比如Netty的设计高可用，可扩展，性能高，使用NIO这种非阻塞式的IO模型等特点。</p>
<p>然后介绍了一下异步编程的设计，有两种方式：</p>
<ol>
<li>基于Callback</li>
<li>基于Future</li>
</ol>
<p>基于Callback的跟javascript相似，这种方式比较大的问题就是当callback多的时候，代码就变得难以阅读。</p>
<p>基于Future的方式就是jdk里的concurrent包里的Future接口一样，代表着未来的一个值。</p>
<p>Netty内部这2种异步编程方式都有使用。</p>
<p>之后对IO阻塞模型和NIO非阻塞模型进行了一番比较。</p>
<p>其中IO阻塞模型对于每一个Socket都会创建一个线程进行处理，虽然可以使用线程池解决线程过多的问题，但是底层还是使用线程处理每一个请求，系统的瓶颈在于线程的个数，并且线程多了会导致频繁的线程切换，导致CPU利用效率不高。</p>
<p>NIO非阻塞模型采用Reactor模式，一个Reactor线程内部使用一个多路复用器selector，这个selector可以同时注册、监听和轮询成百上千个Channel，一个IO线程可以同时并发处理多个客户端连接，就不会存在频繁的IO线程之间的切换，CPU利用率高。</p>
<p>之后使用JDK的NIO Api编写了一个demo，发现JDK的NIO Api比较难用，比如在ByteBuffer中进行读操作后又要进行写操作，需要调用flip进行切换，api很难用，而netty很好地解决了这个问题，这也是netty的一个优点。</p>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>第二章主要就是使用netty的api编写了一个server端和client端，让读者先简单熟悉一下netty中的一些api的使用。</p>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p>第三章主要对netty中的一些主要的组件做一个简单的介绍。</p>
<p>Channel: 一个Channel表示一个通道，跟io中的stream的角色一样，但是有几点不同。 1. stream是单向的，只支持读或者写，channel是双向的，既支持读也支持写。2. stream是阻塞的，channel是并行的。</p>
<p>EventLoop: 当一个channel注册之后，会将这个channel绑定到EventLoop里来处理channel的IO操作，一个EventLoop对应一个线程。</p>
<p>EventLoopGroup: 多个EventLoop的集合</p>
<p>Bootstrap: 用于配置客户端netty程序，比如连接的host和port，EventLoop等</p>
<p>ServerBootstrap: 用于配置服务端netty程序，比如绑定的port，EventLoop等</p>
<p>ChannelHandler: 主要用于处理关于Channel的业务逻辑。比如转换数据格式、当channel状态改变的时候被通知到，当channel注册到EventLoop的时候被通知到以及通知一些用户执行的特殊事件等。ChannelHandler有很多很多的实现类</p>
<p>ChannelPipeline: 把很多ChannelHandler整合在一起并进行处理</p>
<p>Future or ChannelFuture: 由于所有的netty都是异步操作。异步操作的结果就是ChannelFuture</p>
<p>ChannelInBoundHandler和ChannelOutBoundHandler是ChannelHandler的两种很常见的实现类，他们分别用于读取socket中的数据和写数据到socket中，他们存储在ChannelPipeline中用于处理socket，有一张很经典关于ChannelInboundHandler和ChannelOutboundHandler的图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty01.png" alt="image"></p>
<p>最后讲解了关于java对象的编码和解码，因为使用netty开发的时候需要传输字节数据，而这些字节数据可以跟java对象之间进行互相转换使编程更加方便。</p>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>第四章主要讲解了netty中的4种transport，分别是OIO、NIO、Local和Embedded。</p>
<p>其中OIO这种transport在netty中的io.netty.channel.socket.oio包里，底层使用jdk的java.net包里的类，io模型为阻塞io模型</p>
<p>NIO在netty中的io.netty.channel.socket.nio包里，底层使用jdk的java.nio.channels包里的类，netty提供了2种nio的实现，分别是基于selector和基于epoll的实现。</p>
<p>Local在io.netty.channel.local包里，这是一种在同一个JVM中客户端与服务器进行通信的一种transport。</p>
<p>Embedded在io.netty.channel.embedded包里，主要用于测试，可以在不需要网络的情况下进行ChannelHandler的单元测试。</p>
<p>这4种transport的使用场景如下：</p>
<p>OIO: 低连接数，低延迟，需要阻塞时使用<br>NIO: 搞链接数<br>Local: 同一个JVM中进行通信时使用<br>Embedded: ChannelHandler单元测试时使用</p>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p>第五章主要讲解netty中的ByteBuf的使用。</p>
<p>Jdk的NIO中的ByteBuffer使用成本过多，netty发现了这一缺点并进行了改造，设计出了ByteBuf这个类来代替ByteBuffer，相比ByteBuffer，ByteBuf有如下几个特点：</p>
<ol>
<li>可以定义自己的buffer类型，比如heap buffer, direct buffer等</li>
<li>可以使用内置的composite buffer类型完成零拷贝</li>
<li>buffer容量可以扩展</li>
<li>不需要调用flip来切换读写模式</li>
<li>区分readerIndex和writerIndex</li>
<li>方法链式调用</li>
<li>使用引用计数</li>
<li>可以使用pool来创建buffer</li>
</ol>
<p>ByteBuf工作原理：内部有2个索引，分别是readerIndex和writerIndex，初始化时，这2个值都是0，当写入数据到buffer中，writerIndex会增加；当读取数据时，readerIndex会增加。当readerIndex = writerIndex的时候，再进行读取将会抛出IndexOutOfBoundsException异常。</p>
<p>ByteBuf是有容量概念的，默认情况下的最大的容量是Integer.MAX_VALUE。当writerIndex超过这个容量大小时，将会抛出异常。</p>
<p>下图就是一个ByteBuf的结构：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty02.png" alt="image"></p>
<p>ByteBuf共有3种类型：</p>
<ol>
<li>heap buffer: 存储在JVM的堆中，内部使用一个字节数组存储字节。可以使用ByteBuf的hasArray方法判断是否是heap buffer</li>
<li>direct buffer：在堆外直接内存中分配，效率高，相比于堆内分配的buffer，在堆外直接内存中分配的buffer少了一次缓冲区的内存拷贝(实际上，当使用一个非直接内存buffer的时候，在发送buffer数据出去之前jvm内部会拷贝这个buffer到堆外直接内存中)</li>
<li>composite buffer：组合型的buffer，比如一个ByteBuf由2个ByteBuf构成，可以使用Composite Buffer完成，可以避免创建一个新的ByteBuf来整合这2个ByteBuf导致的内存拷贝</li>
</ol>
<p>以上2、3点再加上netty文件传输采用的transferTo方法(可以直接将文件缓存区的数据发送到目标Channel，不需要通过循环write方式导致的内存拷贝问题)构成了Netty的零拷贝。</p>
<p>接下来就是ByteBuf的一些常用方法介绍，比如copy, slice, duplicate, readInt, writeInt, indexOf, clear, discardReadBytes方法等等。</p>
<p>一些参考资料：</p>
<p><a href="http://www.open-open.com/news/view/1d31d83" target="_blank" rel="external">http://www.open-open.com/news/view/1d31d83</a></p>
<p><a href="http://www.infoq.com/cn/articles/netty-high-performance" target="_blank" rel="external">http://www.infoq.com/cn/articles/netty-high-performance</a></p>
<p><a href="http://www.infoq.com/cn/author/%E6%9D%8E%E6%9E%97%E9%94%8B#%E6%96%87%E7%AB%A0" target="_blank" rel="external">http://www.infoq.com/cn/author/%E6%9D%8E%E6%9E%97%E9%94%8B#%E6%96%87%E7%AB%A0</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇读书笔记，根据章节进行下总结。已经看了5章，先对这5个章节做个小总结。&lt;/p&gt;
    
    </summary>
    
      <category term="netty" scheme="http://fangjian0423.github.io/categories/netty/"/>
    
    
      <category term="nio" scheme="http://fangjian0423.github.io/tags/nio/"/>
    
      <category term="netty" scheme="http://fangjian0423.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot的actuator模块</title>
    <link href="http://fangjian0423.github.io/2016/06/25/springboot-actuator/"/>
    <id>http://fangjian0423.github.io/2016/06/25/springboot-actuator/</id>
    <published>2016-06-25T06:52:52.000Z</published>
    <updated>2016-06-25T07:38:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>springboot内部提供了一个模块spring-boot-actuator用于监控和管理springboot应用。</p>
<p>这个模块内部提供了很多功能，endpoint就是其中一块功能。</p>
<p>我们在sbt中加入这个模块的依赖：</p>
<pre><code>libraryDependencies += &quot;org.springframework.boot&quot; % &quot;spring-boot-starter-actuator&quot; % &quot;1.3.5.RELEASE&quot;
</code></pre><p>然后启动项目，访问地址 <a href="http://localhost:8080/health，看到以下页面：" target="_blank" rel="external">http://localhost:8080/health，看到以下页面：</a></p>
<pre><code>{
    status: &quot;UP&quot;,
    diskSpace: {
        status: &quot;UP&quot;,
        total: 249779191808,
        free: 22231089152,
        threshold: 10485760
    },
    db: {
        status: &quot;UP&quot;,
        database: &quot;H2&quot;,
        hello: 1
    }
}
</code></pre><a id="more"></a>
<p>这个/health endpoint显示了目前应用的一些健康情况。</p>
<h2 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h2><p>spring-boot-autoconfigure模块中还提供了其他很多endpoint，比如 /beans(查看spring工厂信息，里面存在哪些bean)、/dump(应用中的所有线程状态)、/env(应用环境信息，比如jvm环境信息、配置文件内容、应用端口等信息)、/mappings(SpringMVC的RequestMapping映射信息)、/configprops(框架配置信息，比如数据源、freemarker、spring的配置信息)、/metrics(度量信息)等等。</p>
<p>具体其他的endpoint可以查看springboot官方文档上的信息： <a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready-endpoints" target="_blank" rel="external">http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready-endpoints</a></p>
<p>这些endpoint是如何暴露出来的呢，是通过SpringBoot内部的一个Endpoint接口完成的。</p>
<pre><code>public interface Endpoint&lt;T&gt; {
    String getId(); // endpoint的唯一标识
    boolean isEnabled(); // 是否可用
    boolean isSensitive(); // 是否对一般用户可见
    T invoke(); // 具体的执行过程，返回值会被解析成json暴露出口
}
</code></pre><p>这个接口的实现类有DumpEndpoint、BeansEndpoint、InfoEndpoint、HealthEndpoint、RequestMappingEndpoint等等。这些EndPoint实现类就是对应对外暴露的endpoint。BeansEndpoint的代码如下：</p>
<pre><code>@ConfigurationProperties(prefix = &quot;endpoints.beans&quot;) // 配置以endpoints.beans开头，可以覆盖
public class BeansEndpoint extends AbstractEndpoint&lt;List&lt;Object&gt;&gt;
        implements ApplicationContextAware {

    private final LiveBeansView liveBeansView = new LiveBeansView();

    private final JsonParser parser = JsonParserFactory.getJsonParser();

    public BeansEndpoint() {
        super(&quot;beans&quot;); // id为beans
    }

    @Override
    public void setApplicationContext(ApplicationContext context) throws BeansException {
        if (context.getEnvironment()
                .getProperty(LiveBeansView.MBEAN_DOMAIN_PROPERTY_NAME) == null) {
            this.liveBeansView.setApplicationContext(context);
        }
    }

    @Override
    public List&lt;Object&gt; invoke() {
        return this.parser.parseList(this.liveBeansView.getSnapshotAsJson()); // 返回值就是最后展示的json数组
    }
}
</code></pre><p>可以使用配置覆盖默认的beans endpoint中的信息：</p>
<pre><code>endpoints.beans.enabled= # Enable the endpoint.
endpoints.beans.id= # Endpoint identifier.
endpoints.beans.path= # Endpoint path.
endpoints.beans.sensitive= # Mark if the endpoint exposes sensitive information.
</code></pre><h2 id="Health-Indicator"><a href="#Health-Indicator" class="headerlink" title="Health Indicator"></a>Health Indicator</h2><p>HealthEndpoint这个endpoint是暴露通过扫描出的HealthIndicator接口的实现类完成的。</p>
<p>用于查看应用的健康状况。</p>
<p>在我们的应用中只使用了h2数据库，最终/health显示出来的内容如下(只有硬盘容量和数据库健康状况)：</p>
<pre><code>{
    status: &quot;UP&quot;,
    diskSpace: {
        status: &quot;UP&quot;,
        total: 249779191808,
        free: 20595720192,
        threshold: 10485760
    },
    db: {
        status: &quot;UP&quot;,
        database: &quot;H2&quot;,
        hello: 1
    }
}
</code></pre><p>springboot内置的HealthIndicator有这些：SolrHealthIndicator、RedisHealthIndicator、RabbitHealthIndicator、MongoHealthIndicator、ElasticsearchHealthIndicator、CassandraHealthIndicator、DiskSpaceHealthIndicator、DataSourceHealthIndicator等。</p>
<p>这些都是springboot内置的，我们也可以编写自定义的health indicator。</p>
<p>以服务器中某个目录中的文件个数不能超过某个值为健康指标作为需求进行编写health indicator。</p>
<p>编写HealthIndicator：</p>
<pre><code>@Component
public class TempDirHealthIndicator implements HealthIndicator {

    @Override
    public Health health() {
        Health.Builder builder = new Health.Builder();
        File file = new File(&quot;youdirpath&quot;);
        File[] fileList = file.listFiles();
        if(fileList.length &gt; 10) {
            builder.down().withDetail(&quot;file num&quot;,fileList.length);
        } else {
            builder.up();
        }
        return builder.build();
    }

}
</code></pre><p>访问 <a href="http://localhost:8080/health" target="_blank" rel="external">http://localhost:8080/health</a></p>
<pre><code>{
    status: &quot;DOWN&quot;,
    tempDir: {
        status: &quot;DOWN&quot;,
        file num: 34
    },
    diskSpace: {
        status: &quot;UP&quot;,
        total: 249779191808,
        free: 20690649088,
        threshold: 10485760
    },
    db: {
        status: &quot;UP&quot;,
        database: &quot;H2&quot;,
        hello: 1
    }
}
</code></pre><h2 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h2><p>Metrics服务用来做一些度量支持，springboot提供了两种Metrics，分别是gauge(单一的值)和counter(计数器，自增或自减)。springboot提供了PublicMetrics接口用来支持Metrics服务。</p>
<p>metrics这个endpoint中使用的metrics都是由SystemPublicMetrics完成的：</p>
<pre><code>{
    mem: 388503,
    mem.free: 199992,
    processors: 4,
    instance.uptime: 58260089,
    uptime: 21843805,
    systemload.average: 3.28369140625,
    heap.committed: 320000,
    heap.init: 131072,
    heap.used: 120007,
    heap: 1864192,
    nonheap.committed: 69528,
    nonheap.init: 2496,
    nonheap.used: 68501,
    nonheap: 0,
    threads.peak: 15,
    threads.daemon: 13,
    threads.totalStarted: 20,
    threads: 15,
    classes: 9483,
    classes.loaded: 9484,
    classes.unloaded: 1,
    gc.ps_scavenge.count: 9,
    gc.ps_scavenge.time: 152,
    gc.ps_marksweep.count: 2,
    gc.ps_marksweep.time: 167,
    httpsessions.max: -1,
    httpsessions.active: 0,
    datasource.primary.active: 0,
    datasource.primary.usage: 0,
    gauge.response.health: 218,
    gauge.response.star-star.favicon.ico: 29,
    counter.status.200.star-star.favicon.ico: 1,
    counter.status.503.health: 1
}
</code></pre><p>gauge和counter度量通过GaugeService和CounterService完成。</p>
<p>比如我们要查看各个Controller中的接口被调用的次数话，可以使用CounterService和aop完成：</p>
<pre><code>@Aspect
@Component
class ControllerAspect @Autowired() (
  counterService: CounterService
) {

  @Before(&quot;execution(* me.format.controller.*.*(..))&quot;)
  def controllerCounter(joinPoint: JoinPoint): Unit = {
    counterService.increment(joinPoint.getSignature.toString + &quot;-invokeNum&quot;)
  }

}
</code></pre><p>启动应用，调用getPersons接口4次，调用get/{long} 2次，查看metrics endpoint，得到以下信息：</p>
<pre><code>counter.List me.format.controller.PersonController.get(HttpServletRequest)-invokeNum: 4,
counter.Person me.format.controller.PersonController.get(long)-invokeNum: 2,
</code></pre><p>比如我们要查看各个Controller中的接口的延迟情况，可以使用GaugeService和aop完成：</p>
<pre><code>@Aspect
@Component
class ControllerAspect @Autowired() (
  counterService: CounterService,
  gaugeService: GaugeService
) {

  @Before(&quot;execution(* me.format.controller.*.*(..))&quot;)
  def controllerCounter(joinPoint: JoinPoint): Unit = {
    counterService.increment(joinPoint.getSignature.toString + &quot;-invokeNum&quot;)
  }

  @Around(&quot;execution(* me.format.controller.*.*(..))&quot;)
  def controllerGauge(proceedingJoinPoint: ProceedingJoinPoint): AnyRef = {
    val st = System.currentTimeMillis()
    val result = proceedingJoinPoint.proceed()
    val et = System.currentTimeMillis()
    gaugeService.submit(proceedingJoinPoint.getSignature.toString + &quot;-invokeTime&quot;, (et - st))
    result
  }

}
</code></pre><p>启动应用，调用getPersons接口4次，调用get/{long} 2次，查看metrics endpoint，得到以下信息：</p>
<pre><code>gauge.List me.format.controller.PersonController.get(HttpServletRequest)-invokeTime: 4,
gauge.Person me.format.controller.PersonController.get(long)-invokeTime: 11,
counter.List me.format.controller.PersonController.get(HttpServletRequest)-invokeNum: 4,
counter.Person me.format.controller.PersonController.get(long)-invokeNum: 2,
</code></pre><p>当然，actuator模块提供的功能远不止这些，更多的信息可以查看官方文档。</p>
<p><a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready" target="_blank" rel="external">http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;springboot内部提供了一个模块spring-boot-actuator用于监控和管理springboot应用。&lt;/p&gt;
&lt;p&gt;这个模块内部提供了很多功能，endpoint就是其中一块功能。&lt;/p&gt;
&lt;p&gt;我们在sbt中加入这个模块的依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;libraryDependencies += &amp;quot;org.springframework.boot&amp;quot; % &amp;quot;spring-boot-starter-actuator&amp;quot; % &amp;quot;1.3.5.RELEASE&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后启动项目，访问地址 &lt;a href=&quot;http://localhost:8080/health，看到以下页面：&quot;&gt;http://localhost:8080/health，看到以下页面：&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    status: &amp;quot;UP&amp;quot;,
    diskSpace: {
        status: &amp;quot;UP&amp;quot;,
        total: 249779191808,
        free: 22231089152,
        threshold: 10485760
    },
    db: {
        status: &amp;quot;UP&amp;quot;,
        database: &amp;quot;H2&amp;quot;,
        hello: 1
    }
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="scala" scheme="http://fangjian0423.github.io/tags/scala/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot with Scala</title>
    <link href="http://fangjian0423.github.io/2016/06/22/springboot-with-scala/"/>
    <id>http://fangjian0423.github.io/2016/06/22/springboot-with-scala/</id>
    <published>2016-06-22T15:22:39.000Z</published>
    <updated>2016-06-23T06:06:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下，我们使用java开发springboot应用，可以使用scala开发springboot应用吗？</p>
<p>答案当然是可以的。</p>
<p>今天参考了阿福老师的这篇<a href="http://afoo.me/posts/2015-07-21-scala-developers-springboot-guide.html" target="_blank" rel="external">Scala开发者的SpringBoot快速入门指南</a>以及一位国际友人的一个<a href="https://github.com/bijukunjummen/spring-boot-scala-web" target="_blank" rel="external">spring-boot-scala-web</a> demo。</p>
<p>自己尝试地搭建了一下环境，发现用scala编写springboot应用这种体验也是非常赞的。</p>
<p>下面是具体的环境搭建流程：</p>
<a id="more"></a>
<p>1.使用sbt作为构建工具，由于springboot官方只有基于maven或者gradle的构建方法，所以我们只能自己写了。</p>
<p>参考了springboot的maven配置，比如要开发web应用，需要1个spring-boot-starter-web模块，这个spring-boot-starter-web模块内地又引用了spring-boot-starter模块，spring-boot-starter模块是一个基础的starter模块，内部的依赖如下：</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;commons-logging&lt;/groupId&gt;
                &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.yaml&lt;/groupId&gt;
        &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>其中springb-boot模块内部使用了spring的依赖，spring-boot-autoconfigure模块内部有很多自动化配置的类，spring-boot-starter-web模块内部使用了spring的web模块，一些tomcat模块等。</p>
<p>我们将这3个模块加入到sbt中：</p>
<pre><code>libraryDependencies += &quot;org.springframework.boot&quot; % &quot;spring-boot&quot; % &quot;1.3.5.RELEASE&quot;
libraryDependencies += &quot;org.springframework.boot&quot; % &quot;spring-boot-autoconfigure&quot; % &quot;1.3.5.RELEASE&quot;
libraryDependencies += &quot;org.springframework.boot&quot; % &quot;spring-boot-starter-web&quot; % &quot;1.3.5.RELEASE&quot;
</code></pre><p>再加入jpa的依赖：</p>
<pre><code>libraryDependencies += &quot;org.springframework.boot&quot; % &quot;spring-boot-starter-data-jpa&quot; % &quot;1.3.5.RELEASE&quot;
libraryDependencies += &quot;com.h2database&quot; % &quot;h2&quot; % &quot;1.4.192&quot;
</code></pre><p>2.编写domain，使用BeanProperty可以自动给field加入get，set方法。</p>
<pre><code>@Entity
class Person(pName: String, pAge: Int) {

  @Id
  @GeneratedValue
  @BeanProperty
  var id: Long = _

  @BeanProperty
  var name: String = pName

  @BeanProperty
  var age: Int = pAge

  def this() = this(&quot;unknown&quot;, -1)

}

object Person {
  def apply(name: String, age: Int) = new Person(name, age)
}
</code></pre><p>3.编写Repository，由于scala中没有接口这个概念，我们使用trait代替。</p>
<pre><code>@Repository
trait PersonRepository extends CrudRepository[Person, Long]
</code></pre><p>4.编写Controller。利用构造器依赖注入将PersonRepository注入到属性里。</p>
<pre><code>@RestController
class PersonController @Autowired() (
  private val personRepository: PersonRepository
) {

  @RequestMapping(value = Array(&quot;/index&quot;))
  def index(): String = {
    &quot;hello springboot&quot;
  }

  @RequestMapping(value = Array(&quot;/add&quot;))
  def add(req: HttpServletRequest): String = {
    val p = Person(req.getParameter(&quot;name&quot;), Some(req.getParameter(&quot;age&quot;).toInt).getOrElse(-1))
    personRepository.save(p)
    &quot;ok&quot;
  }

  @RequestMapping(value = Array(&quot;/getAll&quot;))
  def get(req: HttpServletRequest): java.util.List[Person] = {
    personRepository.findAll().toList
  }

  @RequestMapping(value = Array(&quot;/get/{id}&quot;))
  def get(@PathVariable() id: Long): Person = {
    personRepository.findOne(id)
  }

}
</code></pre><p>5.使用CommandLineRunner做一些初始化工作。</p>
<pre><code>@SpringBootApplication
class MainClass {

  @Bean
  def init(personRepository: PersonRepository): CommandLineRunner = {
    return new CommandLineRunner {
      override def run(strings: String*): Unit = {
        personRepository.save(Person(&quot;jim&quot;, 1))
        personRepository.save(Person(&quot;tom&quot;, 2))
        personRepository.save(Person(&quot;jerry&quot;, 3))
      }
    }
  }

}
</code></pre><p>6.配置文件application.properties中加入以下配置。</p>
<pre><code>spring.datasource.url=jdbc:h2:mem:AZ;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
</code></pre><p>7.写一个入口对象启动应用。</p>
<pre><code>object Application extends App {
  SpringApplication.run(classOf[MainClass]);
}
</code></pre><p>测试：</p>
<pre><code>curl http://localhost:8080/index

hello springboot

curl http://localhost:8080/getPersons

[{&quot;id&quot;:1,&quot;name&quot;:&quot;jim&quot;,&quot;age&quot;:1},{&quot;id&quot;:2,&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:2},{&quot;id&quot;:3,&quot;name&quot;:&quot;jerry&quot;,&quot;age&quot;:3}]

curl http://localhost:8080/get/1

{&quot;id&quot;:1,&quot;name&quot;:&quot;jim&quot;,&quot;age&quot;:1}

curl http://localhost:8080/add\?name\=format\&amp;age\=4

ok

curl http://localhost:8080/getPersons

[{&quot;id&quot;:1,&quot;name&quot;:&quot;jim&quot;,&quot;age&quot;:1},{&quot;id&quot;:2,&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:2},{&quot;id&quot;:3,&quot;name&quot;:&quot;jerry&quot;,&quot;age&quot;:3},{&quot;id&quot;:4,&quot;name&quot;:&quot;format&quot;,&quot;age&quot;:4}]
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般情况下，我们使用java开发springboot应用，可以使用scala开发springboot应用吗？&lt;/p&gt;
&lt;p&gt;答案当然是可以的。&lt;/p&gt;
&lt;p&gt;今天参考了阿福老师的这篇&lt;a href=&quot;http://afoo.me/posts/2015-07-21-scala-developers-springboot-guide.html&quot;&gt;Scala开发者的SpringBoot快速入门指南&lt;/a&gt;以及一位国际友人的一个&lt;a href=&quot;https://github.com/bijukunjummen/spring-boot-scala-web&quot;&gt;spring-boot-scala-web&lt;/a&gt; demo。&lt;/p&gt;
&lt;p&gt;自己尝试地搭建了一下环境，发现用scala编写springboot应用这种体验也是非常赞的。&lt;/p&gt;
&lt;p&gt;下面是具体的环境搭建流程：&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="scala" scheme="http://fangjian0423.github.io/tags/scala/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot内部的一些自动化配置原理</title>
    <link href="http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/"/>
    <id>http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/</id>
    <published>2016-06-12T11:30:57.000Z</published>
    <updated>2016-09-23T17:07:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>springboot用来简化Spring框架带来的大量XML配置以及复杂的依赖管理，让开发人员可以更加关注业务逻辑的开发。</p>
<p>比如不使用springboot而使用SpringMVC作为web框架进行开发的时候，需要配置相关的SpringMVC配置以及对应的依赖，比较繁琐；而使用springboot的话只需要以下短短的几行代码就可以使用SpringMVC，可谓相当地方便：</p>
<pre><code>@RestController
class App {
  @RequestMapping(&quot;/&quot;)
  String home() {
    &quot;hello&quot;
  }
}
</code></pre><p>其中maven配置如下：</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
&lt;/parent&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><a id="more"></a>
<p>我们以使用SpringMVC并且视图使用freemarker为例，分析springboot内部是如何解析freemarker视图的。</p>
<p>如果要在springboot中使用freemarker视图框架，并且使用maven构建项目的时候，还需要加入以下依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;
    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>这个spring-boot-starter-freemarker依赖对应的jar包里的文件如下：</p>
<pre><code>META-INF
├── MANIFEST.MF
├── maven
│   └── org.springframework.boot
│       └── spring-boot-starter-freemarker
│           ├── pom.properties
│           └── pom.xml
└── spring.provides
</code></pre><p>内部的pom.xml里需要的依赖如下：</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
  &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>我们可以看到这个spring-boot-starter-freemarker依赖内部并没有freemarker的ViewResolver，而是仅仅加入了freemarker的依赖，还有3个依赖，分别是spring-boot-starter、spring-boot-starter-web和spring-context-support。</p>
<p>接下来我们来分析一下为什么在springboot中加入了freemarker的依赖spring-boot-starter-freemarker后，SpringMVC自动地构造了一个freemarker的ViewResolver？</p>
<p>在分析之前，首先我们先看下maven配置，看到了一个parent配置：</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
&lt;/parent&gt;
</code></pre><p>这个spring-boot-starter-parent的pom文件在 <a href="http://central.maven.org/maven2/org/springframework/boot/spring-boot-starter-parent/1.3.5.RELEASE/spring-boot-starter-parent-1.3.5.RELEASE.pom" target="_blank" rel="external">http://central.maven.org/maven2/org/springframework/boot/spring-boot-starter-parent/1.3.5.RELEASE/spring-boot-starter-parent-1.3.5.RELEASE.pom</a> 里。</p>
<p>它内部也有一个parent：</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
    &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;
&lt;/parent&gt;
</code></pre><p>这个spring-boot-dependencies的pom文件在<a href="http://central.maven.org/maven2/org/springframework/boot/spring-boot-dependencies/1.3.5.RELEASE/spring-boot-dependencies-1.3.5.RELEASE.pom，内部有很多依赖。" target="_blank" rel="external">http://central.maven.org/maven2/org/springframework/boot/spring-boot-dependencies/1.3.5.RELEASE/spring-boot-dependencies-1.3.5.RELEASE.pom，内部有很多依赖。</a></p>
<p>比如spring-boot-starter-web、spring-boot-starter-websocket、spring-boot-starter-data-solrspring-boot-starter-freemarker等等，基本上所有的依赖都在这个parent里。</p>
<p>我们的例子中使用了parent依赖里的两个依赖，分别是spring-boot-starter-web和spring-boot-starter-freemarker。</p>
<p>其中spring-boot-starter-web内部依赖了spring的两个spring web依赖：spring-web和spring-webmvc。</p>
<p>spring-boot-starter-web内部还依赖spring-boot-starter，这个spring-boot-starter依赖了spring核心依赖spring-core；还依赖了<strong>spring-boot</strong>和<strong>spring-boot-autoconfigure</strong>这两个。</p>
<p><strong>spring-boot</strong>定义了很多基础功能类，像运行程序的SpringApplication，Logging系统，一些tomcat或者jetty这些EmbeddedServlet容器，配置属性loader等等。</p>
<p>包括了这些包：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/springboot01.png" alt="image"></p>
<p><strong>spring-boot-autoconfigure</strong>定义了很多自动配置的类，比如jpa，solr，redis，elasticsearch、mongo、freemarker、velocity，thymeleaf等等自动配置的类。</p>
<p>以freemarker为例，看一下它的自动化配置类：</p>
<pre><code>@Configuration // 使用Configuration注解，自动构造一些内部定义的bean
@ConditionalOnClass({ freemarker.template.Configuration.class,
        FreeMarkerConfigurationFactory.class }) // 需要freemarker.template.Configuration和FreeMarkerConfigurationFactory这两个类存在在classpath中才会进行自动配置
@AutoConfigureAfter(WebMvcAutoConfiguration.class) // 本次自动配置需要依赖WebMvcAutoConfiguration这个配置类配置之后触发。这个WebMvcAutoConfiguration内部会配置很多Wen基础性的东西，比如RequestMappingHandlerMapping、RequestMappingHandlerAdapter等
@EnableConfigurationProperties(FreeMarkerProperties.class) // 使用FreeMarkerProperties类中的配置
public class FreeMarkerAutoConfiguration {

    private static final Log logger = LogFactory
            .getLog(FreeMarkerAutoConfiguration.class);

    @Autowired
    private ApplicationContext applicationContext;

    @Autowired
    private FreeMarkerProperties properties;

    @PostConstruct // 构造之后调用的方法，组要检查模板位置是否存在
    public void checkTemplateLocationExists() {
        if (this.properties.isCheckTemplateLocation()) {
            TemplateLocation templatePathLocation = null;
            List&lt;TemplateLocation&gt; locations = new ArrayList&lt;TemplateLocation&gt;();
            for (String templateLoaderPath : this.properties.getTemplateLoaderPath()) {
                TemplateLocation location = new TemplateLocation(templateLoaderPath);
                locations.add(location);
                if (location.exists(this.applicationContext)) {
                    templatePathLocation = location;
                    break;
                }
            }
            if (templatePathLocation == null) {
                logger.warn(&quot;Cannot find template location(s): &quot; + locations
                        + &quot; (please add some templates, &quot;
                        + &quot;check your FreeMarker configuration, or set &quot;
                        + &quot;spring.freemarker.checkTemplateLocation=false)&quot;);
            }
        }
    }

    protected static class FreeMarkerConfiguration {

        @Autowired
        protected FreeMarkerProperties properties;

        protected void applyProperties(FreeMarkerConfigurationFactory factory) {
            factory.setTemplateLoaderPaths(this.properties.getTemplateLoaderPath());
            factory.setPreferFileSystemAccess(this.properties.isPreferFileSystemAccess());
            factory.setDefaultEncoding(this.properties.getCharsetName());
            Properties settings = new Properties();
            settings.putAll(this.properties.getSettings());
            factory.setFreemarkerSettings(settings);
        }

    }

    @Configuration
    @ConditionalOnNotWebApplication // 非Web项目的自动配置
    public static class FreeMarkerNonWebConfiguration extends FreeMarkerConfiguration {

        @Bean
        @ConditionalOnMissingBean
        public FreeMarkerConfigurationFactoryBean freeMarkerConfiguration() {
            FreeMarkerConfigurationFactoryBean freeMarkerFactoryBean = new FreeMarkerConfigurationFactoryBean();
            applyProperties(freeMarkerFactoryBean);
            return freeMarkerFactoryBean;
        }

    }

    @Configuration // 自动配置的类
    @ConditionalOnClass(Servlet.class) // 需要运行在Servlet容器下
    @ConditionalOnWebApplication // 需要在Web项目下
    public static class FreeMarkerWebConfiguration extends FreeMarkerConfiguration {

        @Bean
        @ConditionalOnMissingBean(FreeMarkerConfig.class)
        public FreeMarkerConfigurer freeMarkerConfigurer() {
            FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
            applyProperties(configurer);
            return configurer;
        }

        @Bean
        public freemarker.template.Configuration freeMarkerConfiguration(
                FreeMarkerConfig configurer) {
            return configurer.getConfiguration();
        }

        @Bean
        @ConditionalOnMissingBean(name = &quot;freeMarkerViewResolver&quot;) // 没有配置freeMarkerViewResolver这个bean的话，会自动构造一个freeMarkerViewResolver
        @ConditionalOnProperty(name = &quot;spring.freemarker.enabled&quot;, matchIfMissing = true) // 配置文件中开关开启的话，才会构造
        public FreeMarkerViewResolver freeMarkerViewResolver() {
            // 构造了freemarker的ViewSolver，这就是一开始我们分析的为什么没有设置ViewResolver，但是最后却还是存在的原因
            FreeMarkerViewResolver resolver = new FreeMarkerViewResolver();
            this.properties.applyToViewResolver(resolver);
            return resolver;
        }

    }
}
</code></pre><p>freemarker对应的配置类：</p>
<pre><code>@ConfigurationProperties(prefix = &quot;spring.freemarker&quot;) // 使用配置文件中以spring.freemarker开头的配置
public class FreeMarkerProperties extends AbstractTemplateViewResolverProperties {
    public static final String DEFAULT_TEMPLATE_LOADER_PATH = &quot;classpath:/templates/&quot;; // 默认路径

    public static final String DEFAULT_PREFIX = &quot;&quot;; // 默认前缀

    public static final String DEFAULT_SUFFIX = &quot;.ftl&quot;; // 默认后缀

    ...

}
</code></pre><p>下面是官网上的freemarker配置：</p>
<pre><code># FREEMARKER (FreeMarkerAutoConfiguration)
spring.freemarker.allow-request-override=false # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.
spring.freemarker.allow-session-override=false # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.
spring.freemarker.cache=false # Enable template caching.
spring.freemarker.charset=UTF-8 # Template encoding.
spring.freemarker.check-template-location=true # Check that the templates location exists.
spring.freemarker.content-type=text/html # Content-Type value.
spring.freemarker.enabled=true # Enable MVC view resolution for this technology.
spring.freemarker.expose-request-attributes=false # Set whether all request attributes should be added to the model prior to merging with the template.
spring.freemarker.expose-session-attributes=false # Set whether all HttpSession attributes should be added to the model prior to merging with the template.
spring.freemarker.expose-spring-macro-helpers=true # Set whether to expose a RequestContext for use by Spring&apos;s macro library, under the name &quot;springMacroRequestContext&quot;.
spring.freemarker.prefer-file-system-access=true # Prefer file system access for template loading. File system access enables hot detection of template changes.
spring.freemarker.prefix= # Prefix that gets prepended to view names when building a URL.
spring.freemarker.request-context-attribute= # Name of the RequestContext attribute for all views.
spring.freemarker.settings.*= # Well-known FreeMarker keys which will be passed to FreeMarker&apos;s Configuration.
spring.freemarker.suffix= # Suffix that gets appended to view names when building a URL.
spring.freemarker.template-loader-path=classpath:/templates/ # Comma-separated list of template paths.
spring.freemarker.view-names= # White list of view names that can be resolved.
</code></pre><p>所以说一开始我们加入了一个spring-boot-starter-freemarker依赖，这个依赖中存在freemarker的lib，满足了FreeMarkerAutoConfiguration中的ConditionalOnClass里写的freemarker.template.Configuration.class这个类存在于classpath中。</p>
<p>所以就构造了FreeMarkerAutoConfiguration里的ViewResolver，这个ViewResolver被自动加入到SpringMVC中。</p>
<p>同样地，如果我们要使用velocity模板，springboot内部也有velocity的自动配置类VelocityAutoConfiguration，原理是跟freemarker一样的。</p>
<p>其他：</p>
<p><a href="https://github.com/mybatis/spring-boot-starter" target="_blank" rel="external">Mybatis的autoconfigure</a>是Mybatis提供的springboot的自动配置模块，由于springboot官方没有提供mybatis的自动化配置模块，所以mybatis自己写了这么一个模块，观察它的源码，发现基本上跟freemarker的autoconfigure模块一样，只需要构造对应的实例即可。</p>
<p>总结：</p>
<p>springboot内部提供了很多自动化配置的类，这些类会判断classpath中是否存在自己需要的那个类，如果存在则会自动配置相关的配置，否则就不会自动配置。</p>
<p>如果我们需要使用一些框架，只需要加入依赖即可，这些依赖内部是没有代码的，只是一些对应框架需要的lib，有了这些lib就会触发自动化配置，于是就能使用框架了。</p>
<p>这一点跟当时看springmvc的时候对response进行json或xml渲染的原理相同。springmvc中的requestmapping注解加上responsebody注解后会返回xml或者json，如果依赖中加入jackson依赖就会转换成json，如果依赖中加入xstream依赖就会转换成xml。当然，前提是springmvc中有了这两种依赖的HttpMessageConverter代码，这个HttpMessageConverter代码就相当于springboot中的各种AutoConfiguration。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;springboot用来简化Spring框架带来的大量XML配置以及复杂的依赖管理，让开发人员可以更加关注业务逻辑的开发。&lt;/p&gt;
&lt;p&gt;比如不使用springboot而使用SpringMVC作为web框架进行开发的时候，需要配置相关的SpringMVC配置以及对应的依赖，比较繁琐；而使用springboot的话只需要以下短短的几行代码就可以使用SpringMVC，可谓相当地方便：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RestController
class App {
  @RequestMapping(&amp;quot;/&amp;quot;)
  String home() {
    &amp;quot;hello&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中maven配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3.5.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/parent&amp;gt;
&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Java线程状态分析</title>
    <link href="http://fangjian0423.github.io/2016/06/04/java-thread-state/"/>
    <id>http://fangjian0423.github.io/2016/06/04/java-thread-state/</id>
    <published>2016-06-04T15:53:35.000Z</published>
    <updated>2016-06-04T15:53:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java线程的生命周期中，存在几种状态。在Thread类里有一个枚举类型State，定义了线程的几种状态，分别有：</p>
<ol>
<li>NEW: 线程创建之后，但是还没有启动(not yet started)。这时候它的状态就是NEW</li>
<li>RUNNABLE: 正在Java虚拟机下跑任务的线程的状态。在RUNNABLE状态下的线程可能会处于等待状态， 因为它正在等待一些系统资源的释放，比如IO</li>
<li>BLOCKED: 阻塞状态，等待锁的释放，比如线程A进入了一个synchronized方法，线程B也想进入这个方法，但是这个方法的锁已经被线程A获取了，这个时候线程B就处于BLOCKED状态</li>
<li>WAITING: 等待状态，处于等待状态的线程是由于执行了3个方法中的任意方法。 1. Object的wait方法，并且没有使用timeout参数; 2. Thread的join方法，没有使用timeout参数 3. LockSupport的park方法。  处于waiting状态的线程会等待另外一个线程处理特殊的行为。 再举个例子，如果一个线程调用了一个对象的wait方法，那么这个线程就会处于waiting状态直到另外一个线程调用这个对象的notify或者notifyAll方法后才会解除这个状态</li>
<li>TIMED_WAITING: 有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。 1. Thread.sleep方法 2. Object的wait方法，带有时间 3. Thread.join方法，带有时间 4. LockSupport的parkNanos方法，带有时间 5. LockSupport的parkUntil方法，带有时间</li>
<li>TERMINATED: 线程中止的状态，这个线程已经完整地执行了它的任务</li>
</ol>
<a id="more"></a>
<p>下面通过几个例子再次说明一下在什么情况下，线程会处于这几种状态：</p>
<h2 id="NEW状态"><a href="#NEW状态" class="headerlink" title="NEW状态"></a>NEW状态</h2><p>NEW状态比较简单，实例化一个线程之后，并且这个线程没有开始执行，这个时候的状态就是NEW：</p>
<pre><code>Thread thread = new Thread();
System.out.println(thread.getState()); // NEW
</code></pre><h2 id="RUNNABLE状态"><a href="#RUNNABLE状态" class="headerlink" title="RUNNABLE状态"></a>RUNNABLE状态</h2><p>正在运行的状态。</p>
<pre><code>Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
        for(int i = 0; i &lt; Integer.MAX_VALUE; i ++) {
            System.out.println(i);
        }
    }
}, &quot;RUNNABLE-Thread&quot;);
thread.start();
</code></pre><p>使用jstack查看线程状态：</p>
<pre><code>&quot;RUNNABLE-Thread&quot; #10 prio=5 os_prio=31 tid=0x00007f8e04981000 nid=0x4f03 runnable [0x000070000124c000]
   java.lang.Thread.State: RUNNABLE
  at java.io.FileOutputStream.writeBytes(Native Method)
  at java.io.FileOutputStream.write(FileOutputStream.java:315)
  at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82)
  at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140)
  - locked &lt;0x000000079764cc50&gt; (a java.io.BufferedOutputStream)
  at java.io.PrintStream.write(PrintStream.java:482)
  - locked &lt;0x0000000797604dc0&gt; (a java.io.PrintStream)
  at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)
  at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291)
  at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104)
  - locked &lt;0x0000000797604d78&gt; (a java.io.OutputStreamWriter)
  at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185)
  at java.io.PrintStream.write(PrintStream.java:527)
  - eliminated &lt;0x0000000797604dc0&gt; (a java.io.PrintStream)
  at java.io.PrintStream.print(PrintStream.java:597)
  at java.io.PrintStream.println(PrintStream.java:736)
  - locked &lt;0x0000000797604dc0&gt; (a java.io.PrintStream)
  at study.thread.ThreadStateTest$1.run(ThreadStateTest.java:23)
  at java.lang.Thread.run(Thread.java:745)
</code></pre><h2 id="BLOCKED状态"><a href="#BLOCKED状态" class="headerlink" title="BLOCKED状态"></a>BLOCKED状态</h2><p>线程A和线程B都需要持有lock对象的锁才能调用方法。如果线程A持有锁，那么线程B处于BLOCKED状态；如果线程B持有锁，那么线程A处于BLOCKED状态。例子中使用Thread.sleep方法主要是用于调试方便：</p>
<pre><code>final Object lock = new Object();
Thread threadA = new Thread(new Runnable() {
    @Override
    public void run() {
        synchronized (lock) {
            System.out.println(Thread.currentThread().getName() + &quot; invoke&quot;);
            try {
                Thread.sleep(20000l);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}, &quot;BLOCKED-Thread-A&quot;);
Thread threadB = new Thread(new Runnable() {
    @Override
    public void run() {
        synchronized (lock) {
            System.out.println(Thread.currentThread().getName() + &quot; invoke&quot;);
            try {
                Thread.sleep(20000l);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}, &quot;BLOCKED-Thread-B&quot;);
threadA.start();
threadB.start();
</code></pre><p>使用jstack查看线程状态。由于线程A先执行，线程B后执行，而且线程A执行后调用了Thread.sleep方法，所以线程A会处于TIMED_WAITING状态，线程B处于BLOCKED状态：</p>
<pre><code>&quot;BLOCKED-Thread-B&quot; #11 prio=5 os_prio=31 tid=0x00007fa7db8ff000 nid=0x5103 waiting for monitor entry [0x000070000134f000]
   java.lang.Thread.State: BLOCKED (on object monitor)
  at study.thread.ThreadStateTest$3.run(ThreadStateTest.java:50)
  - waiting to lock &lt;0x0000000795a03bf8&gt; (a java.lang.Object)
  at java.lang.Thread.run(Thread.java:745)

&quot;BLOCKED-Thread-A&quot; #10 prio=5 os_prio=31 tid=0x00007fa7db15a000 nid=0x4f03 waiting on condition [0x000070000124c000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
  at java.lang.Thread.sleep(Native Method)
  at study.thread.ThreadStateTest$2.run(ThreadStateTest.java:39)
  - locked &lt;0x0000000795a03bf8&gt; (a java.lang.Object)
  at java.lang.Thread.run(Thread.java:745)
</code></pre><h2 id="WAITING状态"><a href="#WAITING状态" class="headerlink" title="WAITING状态"></a>WAITING状态</h2><p>Object的wait方法、Thread的join方法以及Conditon的await方法都会产生WAITING状态。</p>
<p>1.没有时间参数的Object的wait方法</p>
<pre><code>final Object lock = new Object();
Thread threadA = new Thread(new Runnable() {
    @Override
    public void run() {
        synchronized (lock) {
            try {
                lock.wait();
                System.out.println(&quot;wait over&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}, &quot;WAITING-Thread-A&quot;);
Thread threadB = new Thread(new Runnable() {
    @Override
    public void run() {
        synchronized (lock) {
            try {
                Thread.sleep(20000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            lock.notifyAll();
        }
    }
}, &quot;WAITING-Thread-B&quot;);
threadA.start();
threadB.start();
</code></pre><p>WAITING-Thread-A调用了lock的wait，处于WAITING状态：</p>
<pre><code>&quot;WAITING-Thread-B&quot; #11 prio=5 os_prio=31 tid=0x00007f8de992d800 nid=0x5103 waiting on condition [0x000070000134f000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
  at java.lang.Thread.sleep(Native Method)
  at study.thread.ThreadStateTest$5.run(ThreadStateTest.java:84)
  - locked &lt;0x0000000795a03e40&gt; (a java.lang.Object)
  at java.lang.Thread.run(Thread.java:745)

&quot;WAITING-Thread-A&quot; #10 prio=5 os_prio=31 tid=0x00007f8dea193000 nid=0x4f03 in Object.wait() [0x000070000124c000]
   java.lang.Thread.State: WAITING (on object monitor)
  at java.lang.Object.wait(Native Method)
  - waiting on &lt;0x0000000795a03e40&gt; (a java.lang.Object)
  at java.lang.Object.wait(Object.java:502)
  at study.thread.ThreadStateTest$4.run(ThreadStateTest.java:71)
  - locked &lt;0x0000000795a03e40&gt; (a java.lang.Object)
  at java.lang.Thread.run(Thread.java:745)
</code></pre><p>2.Thread的join方法</p>
<pre><code>Thread threadA = new Thread(new Runnable() {
    @Override
    public void run() {
        try {
            Thread.sleep(20000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;Thread-A over&quot;);
    }
}, &quot;WAITING-Thread-A&quot;);
threadA.start();
try {
    threadA.join();
} catch (InterruptedException e) {
    e.printStackTrace();
}
</code></pre><p>主线程main处于WAITING状态：</p>
<pre><code>&quot;WAITING-Thread-A&quot; #10 prio=5 os_prio=31 tid=0x00007fd2d5100000 nid=0x4e03 waiting on condition [0x000070000124c000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
  at java.lang.Thread.sleep(Native Method)
  at study.thread.ThreadStateTest$6.run(ThreadStateTest.java:103)
  at java.lang.Thread.run(Thread.java:745)
&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007fd2d3815000 nid=0x1003 in Object.wait() [0x0000700000182000]
   java.lang.Thread.State: WAITING (on object monitor)
  at java.lang.Object.wait(Native Method)
  - waiting on &lt;0x0000000795a03ec0&gt; (a java.lang.Thread)
  at java.lang.Thread.join(Thread.java:1245)
  - locked &lt;0x0000000795a03ec0&gt; (a java.lang.Thread)
  at java.lang.Thread.join(Thread.java:1319)
  at study.thread.ThreadStateTest.WAITING_join(ThreadStateTest.java:118)
  at study.thread.ThreadStateTest.main(ThreadStateTest.java:13)
  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
  at java.lang.reflect.Method.invoke(Method.java:483)
  at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)
</code></pre><p>3.没有时间参数的Condition的await方法</p>
<p>Condition的await方法跟Obejct的wait方法原理是一样的，故也是WAITING状态</p>
<h2 id="TIMED-WAITING状态"><a href="#TIMED-WAITING状态" class="headerlink" title="TIMED_WAITING状态"></a>TIMED_WAITING状态</h2><p>TIMED_WAITING状态跟TIMEING状态类似，是一个有等待时间的等待状态，不会一直等待下去。</p>
<p>最简单的TIMED_WAITING状态例子就是Thread的sleep方法：</p>
<pre><code>Thread threadA = new Thread(new Runnable() {
    @Override
    public void run() {
        try {
            Thread.sleep(20000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;Thread-A over&quot;);
    }
}, &quot;WAITING-Thread-A&quot;);
threadA.start();
try {
    Thread.sleep(5000);
} catch (InterruptedException e) {
    e.printStackTrace();
}
System.out.println(threadA.getState()); // TIMED_WAITING
</code></pre><p>或者是Object的wait方法带有时间参数、Thread的join方法带有时间参数也会让线程的状态处于TIMED_WAITING状态。</p>
<h2 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h2><p>线程终止的状态，线程执行完成，结束生命周期。</p>
<pre><code>Thread threadA = new Thread();
threadA.start();
try {
    Thread.sleep(5000l);
} catch (InterruptedException e) {
    e.printStackTrace();
}
System.out.println(threadA.getState()); // TERMINATED
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>了解线程的状态可以分析一些问题。</p>
<p>比如线程处于BLOCKED状态，这个时候可以分析一下是不是lock加锁的时候忘记释放了，或者释放的时机不对。导致另外的线程一直处于BLOCKED状态。</p>
<p>比如线程处于WAITING状态，这个时候可以分析一下notifyAll或者signalAll方法的调用时机是否不对。</p>
<p>java自带的jstack工具可以分析查看线程的状态、优先级、描述等具体信息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java线程的生命周期中，存在几种状态。在Thread类里有一个枚举类型State，定义了线程的几种状态，分别有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NEW: 线程创建之后，但是还没有启动(not yet started)。这时候它的状态就是NEW&lt;/li&gt;
&lt;li&gt;RUNNABLE: 正在Java虚拟机下跑任务的线程的状态。在RUNNABLE状态下的线程可能会处于等待状态， 因为它正在等待一些系统资源的释放，比如IO&lt;/li&gt;
&lt;li&gt;BLOCKED: 阻塞状态，等待锁的释放，比如线程A进入了一个synchronized方法，线程B也想进入这个方法，但是这个方法的锁已经被线程A获取了，这个时候线程B就处于BLOCKED状态&lt;/li&gt;
&lt;li&gt;WAITING: 等待状态，处于等待状态的线程是由于执行了3个方法中的任意方法。 1. Object的wait方法，并且没有使用timeout参数; 2. Thread的join方法，没有使用timeout参数 3. LockSupport的park方法。  处于waiting状态的线程会等待另外一个线程处理特殊的行为。 再举个例子，如果一个线程调用了一个对象的wait方法，那么这个线程就会处于waiting状态直到另外一个线程调用这个对象的notify或者notifyAll方法后才会解除这个状态&lt;/li&gt;
&lt;li&gt;TIMED_WAITING: 有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。 1. Thread.sleep方法 2. Object的wait方法，带有时间 3. Thread.join方法，带有时间 4. LockSupport的parkNanos方法，带有时间 5. LockSupport的parkUntil方法，带有时间&lt;/li&gt;
&lt;li&gt;TERMINATED: 线程中止的状态，这个线程已经完整地执行了它的任务&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java阻塞队列ArrayBlockingQueue和LinkedBlockingQueue实现原理分析</title>
    <link href="http://fangjian0423.github.io/2016/05/10/java-arrayblockingqueue-linkedblockingqueue-analysis/"/>
    <id>http://fangjian0423.github.io/2016/05/10/java-arrayblockingqueue-linkedblockingqueue-analysis/</id>
    <published>2016-05-10T12:30:57.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的阻塞队列接口BlockingQueue继承自Queue接口。</p>
<p>BlockingQueue接口提供了3个添加元素方法。</p>
<ol>
<li>add：添加元素到队列里，添加成功返回true，由于容量满了添加失败会抛出IllegalStateException异常</li>
<li>offer：添加元素到队列里，添加成功返回true，添加失败返回false</li>
<li>put：添加元素到队列里，如果容量满了会阻塞直到容量不满</li>
</ol>
<p>3个删除方法。</p>
<ol>
<li>poll：删除队列头部元素，如果队列为空，返回null。否则返回元素。</li>
<li>remove：基于对象找到对应的元素，并删除。删除成功返回true，否则返回false</li>
<li>take：删除队列头部元素，如果队列为空，一直阻塞到队列有元素并删除</li>
</ol>
<p>常用的阻塞队列具体类有ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、LinkedBlockingDeque等。</p>
<p>本文以ArrayBlockingQueue和LinkedBlockingQueue为例，分析它们的实现原理。</p>
<a id="more"></a>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue的原理就是使用一个可重入锁和这个锁生成的两个条件对象进行并发控制(classic two-condition algorithm)。</p>
<p>ArrayBlockingQueue是一个带有长度的阻塞队列，初始化的时候必须要指定队列长度，且指定长度之后不允许进行修改。</p>
<p>它带有的属性如下：</p>
<pre><code>// 存储队列元素的数组，是个循环数组
final Object[] items;

// 拿数据的索引，用于take，poll，peek，remove方法
int takeIndex;

// 放数据的索引，用于put，offer，add方法
int putIndex;

// 元素个数
int count;

// 可重入锁
final ReentrantLock lock;
// notEmpty条件对象，由lock创建
private final Condition notEmpty;
// notFull条件对象，由lock创建
private final Condition notFull;
</code></pre><h3 id="数据的添加"><a href="#数据的添加" class="headerlink" title="数据的添加"></a>数据的添加</h3><p>ArrayBlockingQueue有不同的几个数据添加方法，add、offer、put方法。</p>
<p>add方法：</p>
<pre><code>public boolean add(E e) {
    if (offer(e))
        return true;
    else
        throw new IllegalStateException(&quot;Queue full&quot;);
}
</code></pre><p>add方法内部调用offer方法如下：</p>
<pre><code>public boolean offer(E e) {
    checkNotNull(e); // 不允许元素为空
    final ReentrantLock lock = this.lock;
    lock.lock(); // 加锁，保证调用offer方法的时候只有1个线程
    try {
        if (count == items.length) // 如果队列已满
            return false; // 直接返回false，添加失败
        else {
            insert(e); // 数组没满的话调用insert方法
            return true; // 返回true，添加成功
        }
    } finally {
        lock.unlock(); // 释放锁，让其他线程可以调用offer方法
    }
}
</code></pre><p>insert方法如下：</p>
<pre><code>private void insert(E x) {
    items[putIndex] = x; // 元素添加到数组里
    putIndex = inc(putIndex); // 放数据索引+1，当索引满了变成0
    ++count; // 元素个数+1
    notEmpty.signal(); // 使用条件对象notEmpty通知，比如使用take方法的时候队列里没有数据，被阻塞。这个时候队列insert了一条数据，需要调用signal进行通知
}
</code></pre><p>put方法：</p>
<pre><code>public void put(E e) throws InterruptedException {
    checkNotNull(e); // 不允许元素为空
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly(); // 加锁，保证调用put方法的时候只有1个线程
    try {
        while (count == items.length) // 如果队列满了，阻塞当前线程，并加入到条件对象notFull的等待队列里
            notFull.await(); // 线程阻塞并被挂起，同时释放锁
        insert(e); // 调用insert方法
    } finally {
        lock.unlock(); // 释放锁，让其他线程可以调用put方法
    }
}
</code></pre><p>ArrayBlockingQueue的添加数据方法有add，put，offer这3个方法，总结如下：</p>
<p>add方法内部调用offer方法，如果队列满了，抛出IllegalStateException异常，否则返回true</p>
<p>offer方法如果队列满了，返回false，否则返回true</p>
<p>add方法和offer方法不会阻塞线程，put方法如果队列满了会阻塞线程，直到有线程消费了队列里的数据才有可能被唤醒。</p>
<p>这3个方法内部都会使用可重入锁保证原子性。</p>
<h3 id="数据的删除"><a href="#数据的删除" class="headerlink" title="数据的删除"></a>数据的删除</h3><p>ArrayBlockingQueue有不同的几个数据删除方法，poll、take、remove方法。</p>
<p>poll方法：</p>
<pre><code>public E poll() {
    final ReentrantLock lock = this.lock;
    lock.lock(); // 加锁，保证调用poll方法的时候只有1个线程
    try {
        return (count == 0) ? null : extract(); // 如果队列里没元素了，返回null，否则调用extract方法
    } finally {
        lock.unlock(); // 释放锁，让其他线程可以调用poll方法
    }
}
</code></pre><p>poll方法内部调用extract方法：</p>
<pre><code>private E extract() {
    final Object[] items = this.items;
    E x = this.&lt;E&gt;cast(items[takeIndex]); // 得到取索引位置上的元素
    items[takeIndex] = null; // 对应取索引上的数据清空
    takeIndex = inc(takeIndex); // 取数据索引+1，当索引满了变成0
    --count; // 元素个数-1
    notFull.signal(); // 使用条件对象notFull通知，比如使用put方法放数据的时候队列已满，被阻塞。这个时候消费了一条数据，队列没满了，就需要调用signal进行通知
    return x; // 返回元素
}
</code></pre><p>take方法：</p>
<pre><code>public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly(); // 加锁，保证调用take方法的时候只有1个线程
    try {
        while (count == 0) // 如果队列空，阻塞当前线程，并加入到条件对象notEmpty的等待队列里
            notEmpty.await(); // 线程阻塞并被挂起，同时释放锁
        return extract(); // 调用extract方法
    } finally {
        lock.unlock(); // 释放锁，让其他线程可以调用take方法
    }
}
</code></pre><p>remove方法：</p>
<pre><code>public boolean remove(Object o) {
    if (o == null) return false;
    final Object[] items = this.items;
    final ReentrantLock lock = this.lock;
    lock.lock(); // 加锁，保证调用remove方法的时候只有1个线程
    try {
        for (int i = takeIndex, k = count; k &gt; 0; i = inc(i), k--) { // 遍历元素
            if (o.equals(items[i])) { // 两个对象相等的话
                removeAt(i); // 调用removeAt方法
                return true; // 删除成功，返回true
            }
        }
        return false; // 删除成功，返回false
    } finally {
        lock.unlock(); // 释放锁，让其他线程可以调用remove方法
    }
}
</code></pre><p>removeAt方法：</p>
<pre><code>void removeAt(int i) {
    final Object[] items = this.items;
    if (i == takeIndex) { // 如果要删除数据的索引是取索引位置，直接删除取索引位置上的数据，然后取索引+1即可
        items[takeIndex] = null;
        takeIndex = inc(takeIndex);
    } else { // 如果要删除数据的索引不是取索引位置，移动元素元素，更新取索引和放索引的值
        for (;;) {
            int nexti = inc(i);
            if (nexti != putIndex) {
                items[i] = items[nexti];
                i = nexti;
            } else {
                items[i] = null;
                putIndex = i;
                break;
            }
        }
    }
    --count; // 元素个数-1
    notFull.signal(); // 使用条件对象notFull通知，比如使用put方法放数据的时候队列已满，被阻塞。这个时候消费了一条数据，队列没满了，就需要调用signal进行通知 
}
</code></pre><p>ArrayBlockingQueue的删除数据方法有poll，take，remove这3个方法，总结如下：</p>
<p>poll方法对于队列为空的情况，返回null，否则返回队列头部元素。</p>
<p>remove方法取的元素是基于对象的下标值，删除成功返回true，否则返回false。</p>
<p>poll方法和remove方法不会阻塞线程。</p>
<p>take方法对于队列为空的情况，会阻塞并挂起当前线程，直到有数据加入到队列中。</p>
<p>这3个方法内部都会调用notFull.signal方法通知正在等待队列满情况下的阻塞线程。</p>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue是一个使用链表完成队列操作的阻塞队列。链表是单向链表，而不是双向链表。</p>
<p>内部使用放锁和拿锁，这两个锁实现阻塞(“two lock queue” algorithm)。</p>
<p>它带有的属性如下：</p>
<pre><code>// 容量大小
private final int capacity;

// 元素个数，因为有2个锁，存在竞态条件，使用AtomicInteger
private final AtomicInteger count = new AtomicInteger(0);

// 头结点
private transient Node&lt;E&gt; head;

// 尾节点
private transient Node&lt;E&gt; last;

// 拿锁
private final ReentrantLock takeLock = new ReentrantLock();

// 拿锁的条件对象
private final Condition notEmpty = takeLock.newCondition();

// 放锁
private final ReentrantLock putLock = new ReentrantLock();

// 放锁的条件对象
private final Condition notFull = putLock.newCondition();
</code></pre><p>ArrayBlockingQueue只有1个锁，添加数据和删除数据的时候只能有1个被执行，不允许并行执行。</p>
<p>而LinkedBlockingQueue有2个锁，放锁和拿锁，添加数据和删除数据是可以并行进行的，当然添加数据和删除数据的时候只能有1个线程各自执行。</p>
<h3 id="数据的添加-1"><a href="#数据的添加-1" class="headerlink" title="数据的添加"></a>数据的添加</h3><p>LinkedBlockingQueue有不同的几个数据添加方法，add、offer、put方法。</p>
<p>add方法内部调用offer方法：</p>
<pre><code>public boolean offer(E e) {
    if (e == null) throw new NullPointerException(); // 不允许空元素
    final AtomicInteger count = this.count;
    if (count.get() == capacity) // 如果容量满了，返回false
        return false;
    int c = -1;
    Node&lt;E&gt; node = new Node(e); // 容量没满，以新元素构造节点
    final ReentrantLock putLock = this.putLock;
    putLock.lock(); // 放锁加锁，保证调用offer方法的时候只有1个线程
    try {
        if (count.get() &lt; capacity) { // 再次判断容量是否已满，因为可能拿锁在进行消费数据，没满的话继续执行
            enqueue(node); // 节点添加到链表尾部
            c = count.getAndIncrement(); // 元素个数+1
            if (c + 1 &lt; capacity) // 如果容量还没满
                notFull.signal(); // 在放锁的条件对象notFull上唤醒正在等待的线程，表示可以再次往队列里面加数据了，队列还没满
        }
    } finally {
        putLock.unlock(); // 释放放锁，让其他线程可以调用offer方法
    }
    if (c == 0) // 由于存在放锁和拿锁，这里可能拿锁一直在消费数据，count会变化。这里的if条件表示如果队列中还有1条数据
        signalNotEmpty(); // 在拿锁的条件对象notEmpty上唤醒正在等待的1个线程，表示队列里还有1条数据，可以进行消费
    return c &gt;= 0; // 添加成功返回true，否则返回false
}
</code></pre><p>put方法：</p>
<pre><code>public void put(E e) throws InterruptedException {
    if (e == null) throw new NullPointerException(); // 不允许空元素
    int c = -1;
    Node&lt;E&gt; node = new Node(e); // 以新元素构造节点
    final ReentrantLock putLock = this.putLock;
    final AtomicInteger count = this.count;
    putLock.lockInterruptibly(); // 放锁加锁，保证调用put方法的时候只有1个线程
    try {
        while (count.get() == capacity) { // 如果容量满了
            notFull.await(); // 阻塞并挂起当前线程
        }
        enqueue(node); // 节点添加到链表尾部
        c = count.getAndIncrement(); // 元素个数+1
        if (c + 1 &lt; capacity) // 如果容量还没满
            notFull.signal(); // 在放锁的条件对象notFull上唤醒正在等待的线程，表示可以再次往队列里面加数据了，队列还没满
    } finally {
        putLock.unlock(); // 释放放锁，让其他线程可以调用put方法
    }
    if (c == 0) // 由于存在放锁和拿锁，这里可能拿锁一直在消费数据，count会变化。这里的if条件表示如果队列中还有1条数据
        signalNotEmpty(); // 在拿锁的条件对象notEmpty上唤醒正在等待的1个线程，表示队列里还有1条数据，可以进行消费
}
</code></pre><p>LinkedBlockingQueue的添加数据方法add，put，offer跟ArrayBlockingQueue一样，不同的是它们的底层实现不一样。</p>
<p>ArrayBlockingQueue中放入数据阻塞的时候，需要消费数据才能唤醒。</p>
<p>而LinkedBlockingQueue中放入数据阻塞的时候，因为它内部有2个锁，可以并行执行放入数据和消费数据，不仅在消费数据的时候进行唤醒插入阻塞的线程，同时在插入的时候如果容量还没满，也会唤醒插入阻塞的线程。</p>
<h3 id="数据的删除-1"><a href="#数据的删除-1" class="headerlink" title="数据的删除"></a>数据的删除</h3><p>LinkedBlockingQueue有不同的几个数据删除方法，poll、take、remove方法。</p>
<p>poll方法：</p>
<pre><code>public E poll() {
    final AtomicInteger count = this.count;
    if (count.get() == 0) // 如果元素个数为0
        return null; // 返回null
    E x = null;
    int c = -1;
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lock(); // 拿锁加锁，保证调用poll方法的时候只有1个线程
    try {
        if (count.get() &gt; 0) { // 判断队列里是否还有数据
            x = dequeue(); // 删除头结点
            c = count.getAndDecrement(); // 元素个数-1
            if (c &gt; 1) // 如果队列里还有元素
                notEmpty.signal(); // 在拿锁的条件对象notEmpty上唤醒正在等待的线程，表示队列里还有数据，可以再次消费
        }
    } finally {
        takeLock.unlock(); // 释放拿锁，让其他线程可以调用poll方法
    }
    if (c == capacity) // 由于存在放锁和拿锁，这里可能放锁一直在添加数据，count会变化。这里的if条件表示如果队列中还可以再插入数据
        signalNotFull(); // 在放锁的条件对象notFull上唤醒正在等待的1个线程，表示队列里还能再次添加数据
                return x;
}
</code></pre><p>take方法：</p>
<pre><code>public E take() throws InterruptedException {
    E x;
    int c = -1;
    final AtomicInteger count = this.count;
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lockInterruptibly(); // 拿锁加锁，保证调用take方法的时候只有1个线程
    try {
        while (count.get() == 0) { // 如果队列里已经没有元素了
            notEmpty.await(); // 阻塞并挂起当前线程
        }
        x = dequeue(); // 删除头结点
        c = count.getAndDecrement(); // 元素个数-1
        if (c &gt; 1) // 如果队列里还有元素
            notEmpty.signal(); // 在拿锁的条件对象notEmpty上唤醒正在等待的线程，表示队列里还有数据，可以再次消费
    } finally {
        takeLock.unlock(); // 释放拿锁，让其他线程可以调用take方法
    }
    if (c == capacity) // 由于存在放锁和拿锁，这里可能放锁一直在添加数据，count会变化。这里的if条件表示如果队列中还可以再插入数据
        signalNotFull(); // 在放锁的条件对象notFull上唤醒正在等待的1个线程，表示队列里还能再次添加数据
    return x;
}
</code></pre><p>remove方法：</p>
<pre><code>public boolean remove(Object o) {
    if (o == null) return false;
    fullyLock(); // remove操作要移动的位置不固定，2个锁都需要加锁
    try {
        for (Node&lt;E&gt; trail = head, p = trail.next; // 从链表头结点开始遍历
             p != null;
             trail = p, p = p.next) {
            if (o.equals(p.item)) { // 判断是否找到对象
                unlink(p, trail); // 修改节点的链接信息，同时调用notFull的signal方法
                return true;
            }
        }
        return false;
    } finally {
        fullyUnlock(); // 2个锁解锁
    }
}
</code></pre><p>LinkedBlockingQueue的take方法对于没数据的情况下会阻塞，poll方法删除链表头结点，remove方法删除指定的对象。</p>
<p>需要注意的是remove方法由于要删除的数据的位置不确定，需要2个锁同时加锁。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中的阻塞队列接口BlockingQueue继承自Queue接口。&lt;/p&gt;
&lt;p&gt;BlockingQueue接口提供了3个添加元素方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;add：添加元素到队列里，添加成功返回true，由于容量满了添加失败会抛出IllegalStateException异常&lt;/li&gt;
&lt;li&gt;offer：添加元素到队列里，添加成功返回true，添加失败返回false&lt;/li&gt;
&lt;li&gt;put：添加元素到队列里，如果容量满了会阻塞直到容量不满&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3个删除方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;poll：删除队列头部元素，如果队列为空，返回null。否则返回元素。&lt;/li&gt;
&lt;li&gt;remove：基于对象找到对应的元素，并删除。删除成功返回true，否则返回false&lt;/li&gt;
&lt;li&gt;take：删除队列头部元素，如果队列为空，一直阻塞到队列有元素并删除&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;常用的阻塞队列具体类有ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、LinkedBlockingDeque等。&lt;/p&gt;
&lt;p&gt;本文以ArrayBlockingQueue和LinkedBlockingQueue为例，分析它们的实现原理。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch和CyclicBarrier的区别</title>
    <link href="http://fangjian0423.github.io/2016/05/01/countdownlatch-cyclicbarrier-difference/"/>
    <id>http://fangjian0423.github.io/2016/05/01/countdownlatch-cyclicbarrier-difference/</id>
    <published>2016-04-30T17:59:39.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>CountDownLatch和CyclicBarrier都是java并发包下的工具类。</p>
<p>CountDownLatch用于处理一个或多个线程等待其他所有线程完毕之后再继续进行操作。</p>
<p>比如要处理一个非常耗时的任务，处理完之后需要更新这个任务的状态，需要开多线程去分批次处理任务中的各个子任务，当所有的子任务全部执行完毕之后，就可以更新任务状态了。这个时候就需要使用CountDownLatch。</p>
<p>CyclicBarrier用于N个线程相互等待，当到达条件之后所有线程继续执行。</p>
<p>比如一个抽奖活动，每个线程进行抽奖，当奖品全部抽完之后对各个线程中的用户进行后续操作。</p>
<p>个人理解的两者之间的区别有3点：</p>
<ol>
<li>CountDownLatch可以阻塞1个或N个线程，CyclicBarrier必须要阻塞N个线程</li>
<li>CountDownLatch用完之后就不能再次使用了，CyclicBarrier用完之后可以再次使用，CyclicBarrier还可以做reset操作</li>
<li>CountDownLatch底层使用的是共享锁，CyclicBarrier底层使用的是ReentrantLock和这个lock的条件对象Condition</li>
</ol>
<a id="more"></a>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>1个CountDownLatch例子，这个例子阻塞3个线程，分别是主线程，Thread1和Thread2。这3个线程会在调用await方法之后阻塞，直到计数器变成0：</p>
<pre><code>public class CountDownLatchTest {

    public static void main(String[] args) {
        System.out.println(&quot;主任务开始，一共需要进行7个子任务。第1和第2个子任务需要进行后续操作 &quot; + DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;));
        CountDownLatch countDownLatch = new CountDownLatch(5);
        for(int i = 0; i &lt; 7; i ++) {
            final int index = i;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    System.out.println(&quot;子任务在线程 &quot; + Thread.currentThread().getName() + &quot; 中运行 &quot; + DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;));
                    if(index == 1 || index == 2) {
                        try {
                            countDownLatch.await();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(&quot;子任务在线程 &quot; + Thread.currentThread().getName() + &quot; 中进行后续操作 &quot; + DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;));
                    }
                    if(index != 1 &amp;&amp; index != 2) {
                        try {
                            Thread.sleep(5000l);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        countDownLatch.countDown();
                    }
                }
            }, &quot;Thread-&quot; + i).start();
        }
        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;主任务结束 &quot; + DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;));
    }

}
</code></pre><p>输出：</p>
<pre><code>主任务开始，一共需要进行7个子任务。第1和第2个子任务需要进行后续操作 2016-05-01 00:41:57
子任务在线程 Thread-1 中运行 2016-05-01 00:41:57
子任务在线程 Thread-2 中运行 2016-05-01 00:41:57
子任务在线程 Thread-0 中运行 2016-05-01 00:41:57
子任务在线程 Thread-3 中运行 2016-05-01 00:41:57
子任务在线程 Thread-4 中运行 2016-05-01 00:41:57
子任务在线程 Thread-5 中运行 2016-05-01 00:41:57
子任务在线程 Thread-6 中运行 2016-05-01 00:41:57
子任务在线程 Thread-2 中进行后续操作 2016-05-01 00:42:02
主任务结束 2016-05-01 00:42:02
子任务在线程 Thread-1 中进行后续操作 2016-05-01 00:42:02
</code></pre><p>1个CyclicBarrier例子，模拟抽奖，每个用户都可以抽奖，当所有的用户抽完奖之后才能开始颁发奖项：</p>
<pre><code>public class CyclicBarrierTest {

    public static void main(String[] args) throws InterruptedException {
        System.out.println(&quot;5个用户开始抽奖&quot; + DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;));
        CyclicBarrier cyclicBarrier = new CyclicBarrier(5);
        for(int i = 0; i &lt; 5; i ++) {
            final int index = i;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName() + &quot; 用户开始抽奖，持续&quot;+(index+1)+&quot;秒&quot; + DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;));
                    try {
                        Thread.sleep((index + 1) * 1000);
                        cyclicBarrier.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } catch (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                    System.out.println(&quot;所有用户抽奖完毕，颁发奖项。为用户&quot; + Thread.currentThread().getName() + &quot;颁奖。&quot; + DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;));
                }
            }, &quot;Thread-&quot; + i).start();
        }
    }

}
</code></pre><p>输出：</p>
<pre><code>5个用户开始抽奖2016-05-01 00:57:16
Thread-1 用户开始抽奖，持续2秒2016-05-01 00:57:16
Thread-2 用户开始抽奖，持续3秒2016-05-01 00:57:16
Thread-3 用户开始抽奖，持续4秒2016-05-01 00:57:16
Thread-4 用户开始抽奖，持续5秒2016-05-01 00:57:16
Thread-0 用户开始抽奖，持续1秒2016-05-01 00:57:16
所有用户抽奖完毕，颁发奖项。为用户Thread-0颁奖。2016-05-01 00:57:21
所有用户抽奖完毕，颁发奖项。为用户Thread-2颁奖。2016-05-01 00:57:21
所有用户抽奖完毕，颁发奖项。为用户Thread-1颁奖。2016-05-01 00:57:21
所有用户抽奖完毕，颁发奖项。为用户Thread-4颁奖。2016-05-01 00:57:21
所有用户抽奖完毕，颁发奖项。为用户Thread-3颁奖。2016-05-01 00:57:21
</code></pre><p>CyclicBarrier中的计数器到0之后，可以重用：</p>
<pre><code>public class CyclicBarrierTest2 {

    public static void main(String[] args) throws InterruptedException {
        System.out.println(&quot;5个用户开始抽奖&quot; + DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;));
        CyclicBarrier cyclicBarrier = new CyclicBarrier(5);
        for(int i = 0; i &lt; 5; i ++) {
            final int index = i;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName() + &quot; 用户开始抽奖，持续&quot;+(index+1)+&quot;秒&quot; + DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;));
                    try {
                        Thread.sleep((index + 1) * 1000);
                        cyclicBarrier.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } catch (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                    System.out.println(&quot;所有用户抽奖完毕，颁发奖项。为用户&quot; + Thread.currentThread().getName() + &quot;颁奖。&quot; + DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;));
                }
            }, &quot;Thread-&quot; + i).start();
        }
        Thread.sleep(5000l);
        System.out.println(&quot;下一轮抽奖开始&quot; + DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;));
        for(int i = 0; i &lt; 5; i ++) {
            final int index = i;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName() + &quot; 用户开始抽奖，持续&quot;+(index+1)+&quot;秒&quot; + DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;));
                    try {
                        Thread.sleep((index + 1) * 1000);
                        cyclicBarrier.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } catch (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                    System.out.println(&quot;所有用户抽奖完毕，颁发奖项。为用户&quot; + Thread.currentThread().getName() + &quot;颁奖。&quot; + DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;));
                }
            }, &quot;Thread-&quot; + i).start();
        }
    }

}
</code></pre><p>输出：</p>
<pre><code>5个用户开始抽奖2016-05-01 00:59:40
Thread-1 用户开始抽奖，持续2秒2016-05-01 00:59:40
Thread-2 用户开始抽奖，持续3秒2016-05-01 00:59:40
Thread-3 用户开始抽奖，持续4秒2016-05-01 00:59:40
Thread-4 用户开始抽奖，持续5秒2016-05-01 00:59:40
Thread-0 用户开始抽奖，持续1秒2016-05-01 00:59:40
所有用户抽奖完毕，颁发奖项。为用户Thread-4颁奖。2016-05-01 00:59:45
所有用户抽奖完毕，颁发奖项。为用户Thread-0颁奖。2016-05-01 00:59:45
所有用户抽奖完毕，颁发奖项。为用户Thread-1颁奖。2016-05-01 00:59:45
下一轮抽奖开始2016-05-01 00:59:45
所有用户抽奖完毕，颁发奖项。为用户Thread-3颁奖。2016-05-01 00:59:45
所有用户抽奖完毕，颁发奖项。为用户Thread-2颁奖。2016-05-01 00:59:45
Thread-1 用户开始抽奖，持续2秒2016-05-01 00:59:45
Thread-0 用户开始抽奖，持续1秒2016-05-01 00:59:45
Thread-2 用户开始抽奖，持续3秒2016-05-01 00:59:45
Thread-3 用户开始抽奖，持续4秒2016-05-01 00:59:45
Thread-4 用户开始抽奖，持续5秒2016-05-01 00:59:45
所有用户抽奖完毕，颁发奖项。为用户Thread-1颁奖。2016-05-01 00:59:50
所有用户抽奖完毕，颁发奖项。为用户Thread-2颁奖。2016-05-01 00:59:50
所有用户抽奖完毕，颁发奖项。为用户Thread-0颁奖。2016-05-01 00:59:50
所有用户抽奖完毕，颁发奖项。为用户Thread-4颁奖。2016-05-01 00:59:50
所有用户抽奖完毕，颁发奖项。为用户Thread-3颁奖。2016-05-01 00:59:50
</code></pre><h2 id="底层分析"><a href="#底层分析" class="headerlink" title="底层分析"></a>底层分析</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch底层使用的是共享锁，它有个内部类Sync，这个Sync继承AQS，实现了共享锁。</p>
<p>简单画了一下共享锁的实现。</p>
<p>比如有4个线程在等待队列里，并且节点类型都是共享锁。 会唤醒head节点的下一节点中的线程Thread1。head节点就变成了之前head节点的下个节点，然后再做重复操作。 这个过程是一个传播过程，会依次唤醒各个共享节点中的线程。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/lockqueue01.jpg" alt=""></p>
<p>并发包下的另外一个工具类Semaphore底层也是使用共享锁实现的。但是它跟CountDownLatch唯一的区别就是它不会唤醒所有的共享节点中的线程，而是唤醒它能唤醒的最大线程数(由信号量可用大小决定)。</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier底层使用的是ReentrantLock和这个lock的条件对象Condition。</p>
<p>它拥有的属性如下：</p>
<pre><code>private static class Generation {
    boolean broken = false;
}

private final ReentrantLock lock = new ReentrantLock(); // 可重入锁
private final Condition trip = lock.newCondition(); // 可重入锁的条件对象
private final int parties; // 计数器原始值，永远不会变
private final Runnable barrierCommand; // 计数器到了之后需要执行的Runnable，可为空
private Generation generation = new Generation(); // 一个Generation对象的实例，当计数器为0的时候这个实例将会重新被构造
private int count; // 计数器当前的值
</code></pre><p>await方法：</p>
<pre><code>private int dowait(boolean timed, long nanos)
    throws InterruptedException, BrokenBarrierException,
           TimeoutException {
    final ReentrantLock lock = this.lock;
    lock.lock(); // 加锁，确保每次只有1个线程调用
    try {
        final Generation g = generation;

        if (g.broken) // 查看generation是否已经损坏
            throw new BrokenBarrierException();

        if (Thread.interrupted()) {
            breakBarrier();
            throw new InterruptedException();
        }

        int index = --count; // 计数器减一
        if (index == 0) {  // 如果计数器为0
            boolean ranAction = false;
            try {
                final Runnable command = barrierCommand;
                if (command != null) // 如果Runnable不为空，执行run方法。注意，这里是直接调用run方法，而不是启动1个新的线程
                    command.run();
                ranAction = true;
                nextGeneration(); // 一个过程结束，重新开始
                return 0;
            } finally {
                if (!ranAction)
                    breakBarrier();
            }
        }


        for (;;) {
            try {
                if (!timed)
                    trip.await(); // 放到Conditon的等待队列里，同时释放锁，让其他线程执行await方法
                else if (nanos &gt; 0L)
                    nanos = trip.awaitNanos(nanos);
            } catch (InterruptedException ie) {
                if (g == generation &amp;&amp; ! g.broken) {
                    breakBarrier();
                    throw ie;
                } else {
                    // We&apos;re about to finish waiting even if we had not
                    // been interrupted, so this interrupt is deemed to
                    // &quot;belong&quot; to subsequent execution.
                    Thread.currentThread().interrupt();
                }
            }

            if (g.broken)
                throw new BrokenBarrierException();

            if (g != generation) // 说明执行了nextGeneration方法，计数器到了0
                return index;

            if (timed &amp;&amp; nanos &lt;= 0L) {
                breakBarrier();
                throw new TimeoutException();
            }
        }
    } finally {
        lock.unlock(); // 解锁
    }
}

private void nextGeneration() {
    // 唤醒Conditon等待队列上的所有线程
    trip.signalAll();
    // 计数器值变成原始值，重新开始
    count = parties;
    // generation被重新构造
    generation = new Generation();
}
</code></pre><p>执行过程解释：</p>
<p>比如Thread1执行了await方法，这个时候await方法加锁，确保其他线程不能再次调用await方法。</p>
<p>然后在await方法中把计数器数字减一。</p>
<p>如果计数器还没到0：将Thread1加入到Condition的条件队列，同时释放锁。这个时候其他线程就可以获得await方法的锁并执行。</p>
<p>如果计数器到了0：调用Conditon的signalAll方法，把Condition等待队列上的所有线程移除，移到AQS的等待队列里，然后返回index，释放锁，之后AQS等待队列上的节点中的线程就可以被唤醒了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CountDownLatch和CyclicBarrier都是java并发包下的工具类。&lt;/p&gt;
&lt;p&gt;CountDownLatch用于处理一个或多个线程等待其他所有线程完毕之后再继续进行操作。&lt;/p&gt;
&lt;p&gt;比如要处理一个非常耗时的任务，处理完之后需要更新这个任务的状态，需要开多线程去分批次处理任务中的各个子任务，当所有的子任务全部执行完毕之后，就可以更新任务状态了。这个时候就需要使用CountDownLatch。&lt;/p&gt;
&lt;p&gt;CyclicBarrier用于N个线程相互等待，当到达条件之后所有线程继续执行。&lt;/p&gt;
&lt;p&gt;比如一个抽奖活动，每个线程进行抽奖，当奖品全部抽完之后对各个线程中的用户进行后续操作。&lt;/p&gt;
&lt;p&gt;个人理解的两者之间的区别有3点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CountDownLatch可以阻塞1个或N个线程，CyclicBarrier必须要阻塞N个线程&lt;/li&gt;
&lt;li&gt;CountDownLatch用完之后就不能再次使用了，CyclicBarrier用完之后可以再次使用，CyclicBarrier还可以做reset操作&lt;/li&gt;
&lt;li&gt;CountDownLatch底层使用的是共享锁，CyclicBarrier底层使用的是ReentrantLock和这个lock的条件对象Condition&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java实现同步的几种方式</title>
    <link href="http://fangjian0423.github.io/2016/04/18/java-synchronize-way/"/>
    <id>http://fangjian0423.github.io/2016/04/18/java-synchronize-way/</id>
    <published>2016-04-18T12:57:57.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java提供了很多同步操作，比如synchronized关键字、wait/notifyAll、ReentrantLock、Condition、一些并发包下的工具类、Semaphore，ThreadLocal、AbstractQueuedSynchronizer等。</p>
<p>本文简单说明一下这几种方式的使用。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/synchronize-way.jpeg" alt=""></p>
<a id="more"></a>
<h2 id="ReentrantLock可重入锁"><a href="#ReentrantLock可重入锁" class="headerlink" title="ReentrantLock可重入锁"></a>ReentrantLock可重入锁</h2><p>ReentrantLock可重入锁是jdk内置的一个锁对象，可以用来实现同步，基本使用方法如下：</p>
<pre><code>public class ReentrantLockTest {

    private ReentrantLock lock = new ReentrantLock();

    public void execute() {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + &quot; do something synchronize&quot;);
            try {
                Thread.sleep(5000l);
            } catch (InterruptedException e) {
                System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);
                Thread.currentThread().interrupt();
            }
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        ReentrantLockTest reentrantLockTest = new ReentrantLockTest();
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                reentrantLockTest.execute();
            }
        });
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                reentrantLockTest.execute();
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><p>输出：</p>
<pre><code>Thread-0 do something synchronize
// 隔了5秒钟 输入下面
Thread-1 do something synchronize
</code></pre><p>这个例子表示同一时间段只能有1个线程执行execute方法。</p>
<p>可重入锁中可重入表示的意义在于<strong>对于同一个线程，可以继续调用加锁的方法，而不会被挂起</strong>。可重入锁内部维护一个计数器，对于同一个线程调用lock方法，计数器+1，调用unlock方法，计数器-1。</p>
<p>举个例子再次说明一下可重入的意思，在一个加锁方法execute中调用另外一个加锁方法anotherLock并不会被挂起，可以直接调用(调用execute方法时计数器+1，然后内部又调用了anotherLock方法，计数器+1，变成了2)：</p>
<pre><code>public void execute() {
    lock.lock();
    try {
        System.out.println(Thread.currentThread().getName() + &quot; do something synchronize&quot;);
        try {
            anotherLock();
            Thread.sleep(5000l);
        } catch (InterruptedException e) {
            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);
            Thread.currentThread().interrupt();
        }
    } finally {
        lock.unlock();
    }
}

public void anotherLock() {
    lock.lock();
    try {
        System.out.println(Thread.currentThread().getName() + &quot; invoke anotherLock&quot;);
    } finally {
        lock.unlock();
    }
}
</code></pre><p>输出：</p>
<pre><code>Thread-0 do something synchronize
Thread-0 invoke anotherLock
// 隔了5秒钟 输入下面
Thread-1 do something synchronize
Thread-1 invoke anotherLock
</code></pre><h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p>synchronized关键跟ReentrantLock一样，也支持可重入锁。但是它是一个关键字，是一种语法级别的同步方式，称为内置锁：</p>
<pre><code>public class SynchronizedKeyWordTest {

    public synchronized void execute() {
            System.out.println(Thread.currentThread().getName() + &quot; do something synchronize&quot;);
        try {
            anotherLock();
            Thread.sleep(5000l);
        } catch (InterruptedException e) {
            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);
            Thread.currentThread().interrupt();
        }
    }

    public synchronized void anotherLock() {
        System.out.println(Thread.currentThread().getName() + &quot; invoke anotherLock&quot;);
    }

    public static void main(String[] args) {
        SynchronizedKeyWordTest reentrantLockTest = new SynchronizedKeyWordTest();
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                reentrantLockTest.execute();
            }
        });
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                reentrantLockTest.execute();
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><p>输出结果跟ReentrantLock一样，这个例子说明内置锁可以作用在方法上。它还可以作用到变量，静态方法上。</p>
<p>synchronized跟ReentrantLock相比，有几点局限性：</p>
<ol>
<li>加锁的时候不能设置超时。ReentrantLock有提供tryLock方法，可以设置超时时间，如果超过了这个时间并且没有获取到锁，就会放弃，而synchronized却没有这种功能</li>
<li>ReentrantLock可以使用多个Condition，而synchronized却只能有1个</li>
<li>不能中断一个试图获得锁的线程</li>
<li>ReentrantLock可以选择公平锁和非公平锁</li>
<li>ReentrantLock可以获得正在等待线程的个数，计数器等</li>
</ol>
<h2 id="Condition条件对象"><a href="#Condition条件对象" class="headerlink" title="Condition条件对象"></a>Condition条件对象</h2><p>条件对象的意义在于对于一个已经获取锁的线程，如果还需要等待其他条件才能继续执行的情况下，才会使用Condition条件对象。</p>
<pre><code>public class ConditionTest {

    public static void main(String[] args) {
        ReentrantLock lock = new ReentrantLock();
        Condition condition = lock.newCondition();
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                lock.lock();
                try {
                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);
                    System.out.println(Thread.currentThread().getName() + &quot; wait for condition&quot;);
                    try {
                        condition.await();
                        System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);
                    } catch (InterruptedException e) {
                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);
                        Thread.currentThread().interrupt();
                    }
                } finally {
                    lock.unlock();
                }
            }
        });
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                lock.lock();
                try {
                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);
                    System.out.println(Thread.currentThread().getName() + &quot; sleep 5 secs&quot;);
                    try {
                        Thread.sleep(5000l);
                    } catch (InterruptedException e) {
                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);
                        Thread.currentThread().interrupt();
                    }
                    condition.signalAll();
                } finally {
                    lock.unlock();
                }
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><p>这个例子中thread1执行到condition.await()时，当前线程会被挂起，直到thread2调用了condition.signalAll()方法之后，thread1才会重新被激活执行。</p>
<p>这里需要注意的是thread1调用Condition的await方法之后，thread1线程释放锁，然后马上加入到Condition的等待队列，由于thread1释放了锁，thread2获得锁并执行，thread2执行signalAll方法之后，Condition中的等待队列thread1被取出并加入到AQS中，接下来thread2执行完毕之后释放锁，由于thread1已经在AQS的等待队列中，所以thread1被唤醒，继续执行。</p>
<h2 id="wait-notifyAll-方式"><a href="#wait-notifyAll-方式" class="headerlink" title="wait/notifyAll 方式"></a>wait/notifyAll 方式</h2><p>wait/notifyAll方式跟ReentrantLock/Condition方式的原理是一样的。</p>
<p>Java中每个对象都拥有一个内置锁，在内置锁中调用wait，notify方法相当于调用锁的Condition条件对象的await和signalAll方法。</p>
<p>使用wait/notifyAll实现上面的那个Condition例子：</p>
<pre><code>public class WaitNotifyAllTest {

    public synchronized void doWait() {
        System.out.println(Thread.currentThread().getName() + &quot; run&quot;);
        System.out.println(Thread.currentThread().getName() + &quot; wait for condition&quot;);
        try {
            this.wait();
            System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);
        } catch (InterruptedException e) {
            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);
            Thread.currentThread().interrupt();
        }
    }

    public synchronized void doNotify() {
        try {
            System.out.println(Thread.currentThread().getName() + &quot; run&quot;);
            System.out.println(Thread.currentThread().getName() + &quot; sleep 5 secs&quot;);
            Thread.sleep(5000l);
            this.notifyAll();
        } catch (InterruptedException e) {
            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);
            Thread.currentThread().interrupt();
        }
    }

    public static void main(String[] args) {
        WaitNotifyAllTest waitNotifyAllTest = new WaitNotifyAllTest();
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                waitNotifyAllTest.doWait();
            }
        });
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                waitNotifyAllTest.doNotify();
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><p>这里需要注意的是由于Condition是由锁创建的，所以调用wait/notifyAll方法的时候需要获得当前线程的锁，否则会发生IllegalMonitorStateException异常。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal是一种把变量放到线程本地的方式来实现线程同步的。</p>
<p>比如SimpleDateFormat不是一个线程安全的类，可以使用ThreadLocal实现同步。</p>
<pre><code>public class ThreadLocalTest {

    private static ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = new ThreadLocal&lt;SimpleDateFormat&gt;() {
        @Override
        protected SimpleDateFormat initialValue() {
            return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        }
    };

    public static void main(String[] args) {
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                Date date = new Date();
                System.out.println(dateFormatThreadLocal.get().format(date));
            }
        });
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                Date date = new Date();
                System.out.println(dateFormatThreadLocal.get().format(date));
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><h2 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h2><p>Semaphore信号量被用于控制特定资源在同一个时间被访问的个数。类似连接池的概念，保证资源可以被合理的使用。可以使用构造器初始化资源个数：</p>
<pre><code>public class SemaphoreTest {

    private static Semaphore semaphore = new Semaphore(2);

    public static void main(String[] args) {
        for(int i = 0; i &lt; 5; i ++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        semaphore.acquire();
                        System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date());
                        Thread.sleep(5000l);
                        semaphore.release();
                    } catch (InterruptedException e) {
                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);
                    }
                }
            }).start();
        }
    }

}
</code></pre><p>输出：</p>
<pre><code>Thread-1 Mon Apr 18 18:03:46 CST 2016
Thread-0 Mon Apr 18 18:03:46 CST 2016
Thread-3 Mon Apr 18 18:03:51 CST 2016
Thread-2 Mon Apr 18 18:03:51 CST 2016
Thread-4 Mon Apr 18 18:03:56 CST 2016
</code></pre><h2 id="并发包下的工具类"><a href="#并发包下的工具类" class="headerlink" title="并发包下的工具类"></a>并发包下的工具类</h2><p>一般情况下，我们不会使用wait/notifyAll或者ReentrantLock这种比较底层的类，而是使用并发包下提供的一些工具类。</p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch是一个计数器，它的构造方法中需要设置一个数值，用来设定计数的次数。每次调用countDown()方法之后，这个计数器都会减去1，CountDownLatch会一直阻塞着调用await()方法的线程，直到计数器的值变为0。</p>
<pre><code>public class CountDownLatchTest {

    public static void main(String[] args) {
        CountDownLatch countDownLatch = new CountDownLatch(5);
        for(int i = 0; i &lt; 5; i ++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date() + &quot; run&quot;);
                    try {
                        Thread.sleep(5000l);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    countDownLatch.countDown();
                }
            }).start();
        }
        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;all thread over&quot;);
    }

}
</code></pre><p>输出：</p>
<pre><code>Thread-2 Mon Apr 18 18:18:30 CST 2016 run
Thread-3 Mon Apr 18 18:18:30 CST 2016 run
Thread-4 Mon Apr 18 18:18:30 CST 2016 run
Thread-0 Mon Apr 18 18:18:30 CST 2016 run
Thread-1 Mon Apr 18 18:18:30 CST 2016 run
all thread over
</code></pre><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier阻塞调用的线程，直到条件满足时，阻塞的线程同时被打开。</p>
<p>调用await()方法的时候，这个线程就会被阻塞，当调用await()的线程数量到达屏障数的时候，主线程就会取消所有被阻塞线程的状态。</p>
<p>在CyclicBarrier的构造方法中，还可以设置一个barrierAction。</p>
<p>在所有的屏障都到达之后，会启动一个线程来运行这里面的代码。</p>
<pre><code>public class CyclicBarrierTest {

    public static void main(String[] args) {
        Random random = new Random();
        CyclicBarrier cyclicBarrier = new CyclicBarrier(5);
        for(int i = 0; i &lt; 5; i ++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    int secs = random.nextInt(5);
                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date() + &quot; run, sleep &quot; + secs + &quot; secs&quot;);
                    try {
                        Thread.sleep(secs * 1000);
                        cyclicBarrier.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } catch (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date() + &quot; runs over&quot;);
                }
            }).start();
        }
    }

}
</code></pre><p>相比CountDownLatch，CyclicBarrier是可以被循环使用的，而且遇到线程中断等情况时，还可以利用reset()方法，重置计数器，从这些方面来说，CyclicBarrier会比CountDownLatch更加灵活一些。        </p>
<h2 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h2><p>AQS是很多同步工具类的基础，比如ReentrentLock里的公平锁和非公平锁，Semaphore里的公平锁和非公平锁，CountDownLatch里的锁等他们的底层都是使用AbstractQueuedSynchronizer完成的。</p>
<p>基于AbstractQueuedSynchronizer自定义实现一个独占锁：</p>
<pre><code>public class MySynchronizer extends AbstractQueuedSynchronizer {

    @Override
    protected boolean tryAcquire(int arg) {
        if(compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }

    @Override
    protected boolean tryRelease(int arg) {
        setState(0);
        setExclusiveOwnerThread(null);
        return true;
    }

    public void lock() {
        acquire(1);
    }

    public void unlock() {
        release(1);
    }

    public static void main(String[] args) {
        MySynchronizer mySynchronizer = new MySynchronizer();
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                mySynchronizer.lock();
                try {
                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);
                    System.out.println(Thread.currentThread().getName() + &quot; will sleep 5 secs&quot;);
                    try {
                        Thread.sleep(5000l);
                        System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);
                    } catch (InterruptedException e) {
                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);
                        Thread.currentThread().interrupt();
                    }
                } finally {
                    mySynchronizer.unlock();
                }
            }
        });
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                mySynchronizer.lock();
                try {
                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);
                } finally {
                    mySynchronizer.unlock();
                }
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><p>MySynchronizer并没有实现可重入功能，只是简单的一个独占锁。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java提供了很多同步操作，比如synchronized关键字、wait/notifyAll、ReentrantLock、Condition、一些并发包下的工具类、Semaphore，ThreadLocal、AbstractQueuedSynchronizer等。&lt;/p&gt;
&lt;p&gt;本文简单说明一下这几种方式的使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wh6.com1.z0.glb.clouddn.com/synchronize-way.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>jdk ConcurrentSkipListMap工作原理分析</title>
    <link href="http://fangjian0423.github.io/2016/04/12/jdk-concurrentskiplistmap/"/>
    <id>http://fangjian0423.github.io/2016/04/12/jdk-concurrentskiplistmap/</id>
    <published>2016-04-12T11:49:11.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>ConcurrentSkipListMap是一个内部使用跳表，并且支持排序和并发的一个Map。</p>
<p>跳表的介绍：</p>
<p>跳表是一种允许在一个有顺序的序列中进行快速查询的数据结构。</p>
<p>如果在普通的顺序链表中查询一个元素，需要从链表头部开始一个一个节点进行遍历，然后找到节点，如下图所示，要查找234元素的话需要从5元素节点开始一个一个节点进行遍历，这样的效率是非常低的。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist01.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>跳表可以解决这种查询时间过长的问题：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist02.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>从上图可以看到，跳表具有以下几种特性：</p>
<ol>
<li>由很多层组成，level越高的层节点越少，最后一层level用有所有的节点数据</li>
<li>每一层的节点数据也都是有顺序的</li>
<li>上面层的节点肯定会在下面层中出现</li>
<li>每个节点都有两个指针，分别是同一层的下一个节点指针和下一层节点的指针</li>
</ol>
<p>使用跳表查询元素的时间复杂度是O(log n)，跟红黑树一样。查询效率还是不错的，</p>
<p>但是跳表的存储容量变大了，本来一共只有7个节点的数据，使用跳表之后变成了14个节点。</p>
<p>所以跳表是一种使用”空间换时间”的概念用来提高查询效率的链表，开源软件Redis、LevelDB都使用到了跳表。跳表相比B树，红黑树，AVL树时间复杂度一样，但是耗费更多存储空间，但是跳表的优势就是它相比树，实现简单，不需要考虑树的一些rebalance问题。</p>
<a id="more"></a>
<p>下图是一个级别更高的跳表：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist03.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<h2 id="跳表的查询"><a href="#跳表的查询" class="headerlink" title="跳表的查询"></a>跳表的查询</h2><p>比如要在下面这个跳表中查找93元素，过程如下：</p>
<ol>
<li>从head节点(最上层的第一个节点)开始找，发现5比93小，继续同一层(Level3)的下一个节点150进行比较</li>
<li>发现105比93大，往下一层(Level2)走，然后找Level2的5元素的下一个节点67，发现67比93小，继续同一层(Level2)的下一个节点150进行比较</li>
<li>发现105比93大，往下一层(Level1)走，然后找Level1的67元素的下一个节点93，找到，返回</li>
</ol>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist04.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<h2 id="跳表新增元素"><a href="#跳表新增元素" class="headerlink" title="跳表新增元素"></a>跳表新增元素</h2><p>跳表中新增元素的话首先会确定Level层，在这个Level以及这个Level以下的层中都加入新的元素，具体的Level层数是通过一个通过一种随机算法获取的，比如之前这个跳表在Level2和Level1中插入666元素：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist05.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>如果Level大于目前跳表的层数，那么会添加新的一层。</p>
<h2 id="跳表删除元素"><a href="#跳表删除元素" class="headerlink" title="跳表删除元素"></a>跳表删除元素</h2><p>在各个层中找到对应的元素并删除即可。</p>
<h2 id="ConcurrentSkipListMap分析"><a href="#ConcurrentSkipListMap分析" class="headerlink" title="ConcurrentSkipListMap分析"></a>ConcurrentSkipListMap分析</h2><p>ConcurrentSkipListMap对跳表中的几个概念做了一层封装，如下：</p>
<pre><code>// 每个节点的封装，跟层数没有关系
static final class Node&lt;K,V&gt; {
    final K key; // 节点的关键字
    volatile Object value; // 节点的值
    volatile Node&lt;K,V&gt; next; // 节点的next节点引用
    ...
}

// 每一层节点的封装，叫做索引
static class Index&lt;K,V&gt; {
    final Node&lt;K,V&gt; node; // 对应的节点
    final Index&lt;K,V&gt; down; // 下一层索引
    volatile Index&lt;K,V&gt; right; // 同一层的下一个索引
    ...
}

// 每一层的头索引
static final class HeadIndex&lt;K,V&gt; extends Index&lt;K,V&gt; {
    final int level; // Level 级别
    HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, int level) {
        super(node, down, right);
        this.level = level;
    }
    ...
}
</code></pre><p>简单分析下ConcurrentSkipListMap的get方法：</p>
<pre><code>private V doGet(Object key) {
    if (key == null)
        throw new NullPointerException();
    Comparator&lt;? super K&gt; cmp = comparator;
    outer: for (;;) {
        // findPredecessor方法表示找到最接近要查找节点的节点，并且这个节点在最下面那一层，这样就保证会遍历所有节点
        for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) {
            Object v; int c;
            if (n == null) // 已经遍历节点到最后还是没有找到，break，返回null
                break outer;
            Node&lt;K,V&gt; f = n.next;
            if (n != b.next) // 判断比较下一个节点是否发生了变化，如果发生变化break重新开始死循环
                break;
            if ((v = n.value) == null) {    // 如果下一个节点已经被删除了
                n.helpDelete(b, f);
                break;
            }
            if (b.value == null || v == n)  // b is deleted
                break;
            if ((c = cpr(cmp, key, n.key)) == 0) {  // 比较并且找到了，直接返回
                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;
                return vv;
            }
            if (c &lt; 0) // 找过头了，说明没有对应节点了，跳出循环，返回null
                break outer;
            b = n; // 继续遍历
            n = f; // 继续遍历
        }
    }
    return null;
}

private Node&lt;K,V&gt; findPredecessor(Object key, Comparator&lt;? super K&gt; cmp) {
    if (key == null)
        throw new NullPointerException(); // don&apos;t postpone errors
    for (;;) { // 一个死循环内部套着另外一个循环
        for (Index&lt;K,V&gt; q = head, r = q.right, d;;) { // head表示最顶层的第一个索引，从这个索引开始找
            if (r != null) { // 如果索引的同一层下一个索引不为null
                Node&lt;K,V&gt; n = r.node;
                K k = n.key;
                if (n.value == null) { // 如果是个已删除节点
                    if (!q.unlink(r)) // 使用cas把已删除节点从跳表上删除掉
                        break;           // 已删除节点从跳表上删除失败，跳出重新循环
                    r = q.right;         // 继续遍历
                    continue;
                }
                if (cpr(cmp, key, k) &gt; 0) { // 使用cas比较要找的关键字和索引内节点的关键字，如果满足比较条件
                    q = r; // 当前所在索引变成同一层下一个索引
                    r = r.right;  // 当前所在索引的下一个索引变成下下个索引，继续遍历
                    continue;
                }
            }
            // 直到找出上一层满足不了条件的那个索引
            if ((d = q.down) == null) // 找到下一层的索引
                return q.node; // 如果下一层没有索引了，返回找到的最接近的节点
            q = d; // 下一层开始做相同的操作
            r = d.right; // 下一层开始做相同的操作
        }
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ConcurrentSkipListMap是一个内部使用跳表，并且支持排序和并发的一个Map。&lt;/p&gt;
&lt;p&gt;跳表的介绍：&lt;/p&gt;
&lt;p&gt;跳表是一种允许在一个有顺序的序列中进行快速查询的数据结构。&lt;/p&gt;
&lt;p&gt;如果在普通的顺序链表中查询一个元素，需要从链表头部开始一个一个节点进行遍历，然后找到节点，如下图所示，要查找234元素的话需要从5元素节点开始一个一个节点进行遍历，这样的效率是非常低的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wh6.com1.z0.glb.clouddn.com/skiplist01.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;跳表可以解决这种查询时间过长的问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wh6.com1.z0.glb.clouddn.com/skiplist02.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到，跳表具有以下几种特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由很多层组成，level越高的层节点越少，最后一层level用有所有的节点数据&lt;/li&gt;
&lt;li&gt;每一层的节点数据也都是有顺序的&lt;/li&gt;
&lt;li&gt;上面层的节点肯定会在下面层中出现&lt;/li&gt;
&lt;li&gt;每个节点都有两个指针，分别是同一层的下一个节点指针和下一层节点的指针&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用跳表查询元素的时间复杂度是O(log n)，跟红黑树一样。查询效率还是不错的，&lt;/p&gt;
&lt;p&gt;但是跳表的存储容量变大了，本来一共只有7个节点的数据，使用跳表之后变成了14个节点。&lt;/p&gt;
&lt;p&gt;所以跳表是一种使用”空间换时间”的概念用来提高查询效率的链表，开源软件Redis、LevelDB都使用到了跳表。跳表相比B树，红黑树，AVL树时间复杂度一样，但是耗费更多存储空间，但是跳表的优势就是它相比树，实现简单，不需要考虑树的一些rebalance问题。&lt;/p&gt;
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="map" scheme="http://fangjian0423.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>jdk PriorityQueue优先队列工作原理分析</title>
    <link href="http://fangjian0423.github.io/2016/04/10/jdk_priorityqueue/"/>
    <id>http://fangjian0423.github.io/2016/04/10/jdk_priorityqueue/</id>
    <published>2016-04-10T13:36:08.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>优先队列跟普通的队列不一样，普通队列是一种遵循FIFO规则的队列，拿数据的时候按照加入队列的顺序拿取。   而优先队列每次拿数据的时候都会拿出优先级最高的数据。</p>
<p>优先队列内部维护着一个堆，每次取数据的时候都从堆顶拿数据，这就是优先队列的原理。</p>
<p>jdk的优先队列使用PriorityQueue这个类，使用者可以自己定义优先级规则。</p>
<a id="more"></a>
<h2 id="一个PriorityQueue例子"><a href="#一个PriorityQueue例子" class="headerlink" title="一个PriorityQueue例子"></a>一个PriorityQueue例子</h2><p>定义一个Task类，有2个属性name和level。这个类放到PriorityQueue里，level越大优先级越高：</p>
<pre><code>private static class Task {
    String name;
    int level;

    public Task(String name, int level) {
        this.name = name;
        this.level = level;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getLevel() {
        return level;
    }

    public void setLevel(int level) {
        this.level = level;
    }

    @Override
    public String toString() {
        return &quot;Task{&quot; +
                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +
                &quot;, level=&quot; + level +
                &apos;}&apos;;
    }
}

public static void main(String[] args) {
    PriorityQueue&lt;Task&gt; queue = new PriorityQueue&lt;Task&gt;(6, new Comparator&lt;Task&gt;() {
        @Override
        public int compare(Task t1, Task t2) {
            return t2.getLevel() - t1.getLevel();
        }
    });
    queue.add(new Task(&quot;游戏&quot;, 20));
    queue.add(new Task(&quot;吃饭&quot;, 100));
    queue.add(new Task(&quot;睡觉&quot;, 90));
    queue.add(new Task(&quot;看书&quot;, 70));
    queue.add(new Task(&quot;工作&quot;, 80));
    queue.add(new Task(&quot;撩妹&quot;, 10));
    while(!queue.isEmpty()) {
        System.out.println(queue.poll());
    }
}
</code></pre><p>输出结果：</p>
<pre><code>Task{name=&apos;吃饭&apos;, level=100}
Task{name=&apos;睡觉&apos;, level=90}
Task{name=&apos;工作&apos;, level=80}
Task{name=&apos;看书&apos;, level=70}
Task{name=&apos;游戏&apos;, level=20}
Task{name=&apos;撩妹&apos;, level=10}
</code></pre><p>add过程其实就是在最大堆里添加新的元素，添加之后再进行调整：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/priorityqueue01.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>出队相当于每次都是堆顶出堆，堆顶出堆之后然后重新调整：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/priorityqueue02.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<h2 id="PriorityQueue原理分析"><a href="#PriorityQueue原理分析" class="headerlink" title="PriorityQueue原理分析"></a>PriorityQueue原理分析</h2><p>首先看下PriorityQueue的属性：</p>
<pre><code>transient Object[] queue; // 堆
private int size = 0; // 元素个数
private final Comparator&lt;? super E&gt; comparator; // 比较器，如果是null，使用元素自身的比较器
</code></pre><p>接下来是PriorityQueue的几个方法介绍。</p>
<p>add，添加元素：</p>
<pre><code>public boolean add(E e) {
    return offer(e); // add方法内部调用offer方法
}

public boolean offer(E e) {
    if (e == null) // 元素为空的话，抛出NullPointerException异常
        throw new NullPointerException();
    modCount++;
    int i = size;
    if (i &gt;= queue.length) // 如果当前用堆表示的数组已经满了，调用grow方法扩容
        grow(i + 1); // 扩容
    size = i + 1; // 元素个数+1
    if (i == 0) // 堆还没有元素的情况
        queue[0] = e; // 直接给堆顶赋值元素
    else // 堆中已有元素的情况
        siftUp(i, e); // 重新调整堆，从下往上调整，因为新增元素是加到最后一个叶子节点
    return true;
}

private void siftUp(int k, E x) {
    if (comparator != null)  // 比较器存在的情况下
        siftUpUsingComparator(k, x); // 使用比较器调整
    else // 比较器不存在的情况下
        siftUpComparable(k, x); // 使用元素自身的比较器调整
}

private void siftUpUsingComparator(int k, E x) {
    while (k &gt; 0) { // 一直循环直到父节点还存在
        int parent = (k - 1) &gt;&gt;&gt; 1; // 找到父节点索引
        Object e = queue[parent]; // 赋值父节点元素
        if (comparator.compare(x, (E) e) &gt;= 0) // 新元素与父元素进行比较，如果满足比较器结果，直接跳出，否则进行调整
            break;
        queue[k] = e; // 进行调整，新位置的元素变成了父元素
        k = parent; // 新位置索引变成父元素索引，进行递归操作
    }
    queue[k] = x; // 新添加的元素添加到堆中
}
</code></pre><p>siftUp方法调用过程如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/priorityqueue03.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>poll，出队方法：</p>
<pre><code>public E poll() {
    if (size == 0)
        return null;
    int s = --size; // 元素个数-1
    modCount++;
    E result = (E) queue[0]; // 得到堆顶元素
    E x = (E) queue[s]; // 最后一个叶子节点
    queue[s] = null; // 最后1个叶子节点置空
    if (s != 0)
        siftDown(0, x); // 从上往下调整，因为删除元素是删除堆顶的元素
    return result;
}

private void siftDown(int k, E x) {
    if (comparator != null) // 比较器存在的情况下
        siftDownUsingComparator(k, x); // 使用比较器调整
    else // 比较器不存在的情况下
        siftDownComparable(k, x); // 使用元素自身的比较器调整
}

private void siftDownUsingComparator(int k, E x) {
    int half = size &gt;&gt;&gt; 1; // 只需循环节点个数的一般即可
    while (k &lt; half) {
        int child = (k &lt;&lt; 1) + 1; // 得到父节点的左子节点索引
        Object c = queue[child]; // 得到左子元素
        int right = child + 1; // 得到父节点的右子节点索引
        if (right &lt; size &amp;&amp;
            comparator.compare((E) c, (E) queue[right]) &gt; 0) // 左子节点跟右子节点比较，取更大的值
            c = queue[child = right];
        if (comparator.compare(x, (E) c) &lt;= 0)  // 然后这个更大的值跟最后一个叶子节点比较

            break;
        queue[k] = c; // 新位置使用更大的值
        k = child; // 新位置索引变成子元素索引，进行递归操作
    }
    queue[k] = x; // 最后一个叶子节点添加到合适的位置
}
</code></pre><p>siftDown方法调用过程如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/priorityqueue04.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>grow扩容方法：</p>
<pre><code>private void grow(int minCapacity) {
    int oldCapacity = queue.length;
    // 新容量
    // 如果老容量小于64 新容量 = 老容量 + 老容量 + 2
    // 如果老容量大于等于64 老容量 = 老容量 + 老容量/2
    int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?
                                     (oldCapacity + 2) :
                                     (oldCapacity &gt;&gt; 1));
    // 溢出处理
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // 使用新容量
    queue = Arrays.copyOf(queue, newCapacity);
}
</code></pre><p>remove，删除队列元素操作：</p>
<pre><code>public boolean remove(Object o) {
    int i = indexOf(o); // 找到数据对应的索引
    if (i == -1) // 不存在的话返回false
        return false;
    else { // 存在的话调用removeAt方法，返回true
        removeAt(i);
        return true;
    }
}

private E removeAt(int i) {
    modCount++;
    int s = --size; // 元素个数-1
    if (s == i) // 如果是删除最后一个叶子节点
        queue[i] = null; // 直接置空，删除即可，堆还是保持特质，不需要调整
    else { // 如果是删除的不是最后一个叶子节点
        E moved = (E) queue[s]; // 获得最后1个叶子节点元素
        queue[s] = null; // 最后1个叶子节点置空
        siftDown(i, moved); // 从上往下调整
        if (queue[i] == moved) { // 如果从上往下调整完毕之后发现元素位置没变，从下往上调整
            siftUp(i, moved); // 从下往上调整
            if (queue[i] != moved)
                return moved;
        }
    }
    return null;
}
</code></pre><p>下图这个堆如果删除红色节点100的时候，siftDown之后元素位置没变，所以还得siftUp：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/priorityqueue05.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>jdk内置的优先队列PriorityQueue内部使用一个堆维护数据，每当有数据add进来或者poll出去的时候会对堆做从下往上的调整和从上往下的调整</li>
<li>PriorityQueue不是一个线程安全的类，如果要在多线程环境下使用，可以使用PriorityBlockingQueue这个优先阻塞队列</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;优先队列跟普通的队列不一样，普通队列是一种遵循FIFO规则的队列，拿数据的时候按照加入队列的顺序拿取。   而优先队列每次拿数据的时候都会拿出优先级最高的数据。&lt;/p&gt;
&lt;p&gt;优先队列内部维护着一个堆，每次取数据的时候都从堆顶拿数据，这就是优先队列的原理。&lt;/p&gt;
&lt;p&gt;jdk的优先队列使用PriorityQueue这个类，使用者可以自己定义优先级规则。&lt;/p&gt;
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="queue" scheme="http://fangjian0423.github.io/tags/queue/"/>
    
  </entry>
  
  <entry>
    <title>堆、二叉堆、堆排序</title>
    <link href="http://fangjian0423.github.io/2016/04/09/heap-heapsort/"/>
    <id>http://fangjian0423.github.io/2016/04/09/heap-heapsort/</id>
    <published>2016-04-09T09:42:18.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>堆的概念：</p>
<p>n个元素序列 { k1, k2, k3, k4, k5, k6 …. kn } 当且仅当满足以下关系时才会被称为堆：</p>
<pre><code>ki &lt;= k2i,ki &lt;= k2i+1 或者 ki &gt;= k2i,ki &gt;= k2i+1 (i = 1,2,3,4 .. n/2)
</code></pre><p>如果数组的下表是从0开始，那么需要满足 </p>
<pre><code>ki &lt;= k2i+1,ki &lt;= k2i+2 或者 ki &gt;= k2i+1,ki &gt;= k2i+2 (i = 0,1,2,3 .. n/2)
</code></pre><p>比如 { 1,3,5,10,15,9 } 这个序列就满足 [1 &lt;= 3; 1 &lt;= 5],  [3 &lt;= 10; 3 &lt;= 15], [5 &lt;= 9] 这3个条件，这个序列就是一个堆。</p>
<p>所以堆其实是一个序列(数组)，如果这个序列满足上述条件，那么就把这个序列看成堆。</p>
<p>堆的实现通常是通过构造二叉堆，因为二叉堆应用很普遍，当不加限定时，堆通常指的就是二叉堆。</p>
<a id="more"></a>
<p>二叉堆的概念：</p>
<p>二叉堆是一种特殊的堆，是一棵完全二叉树或者是近似完全二叉树，同时二叉堆还满足堆的特性：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。</p>
<p>当父节点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父节点的键值总是小于或等于任何一个子节点的键值时为最小堆。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/heap01.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>上图中的最小堆对应的序列是： [1,3,5,9,10,15]  满足最小堆的特性(父节点的键值小于或等于任何一个子节点的键值，并且也满足堆的性质 [1 &lt;= 3; 1 &lt;= 5], [3 &lt;= 9; 3 &lt;= 10], [5 &lt;= 15])</p>
<p>上图中的最大堆对应的序列是： [15,10,9,7,5,3]  满足最大堆的特性(父节点的键值大于或等于任何一个子节点的键值，并且也满足堆的性质 [15 &gt;= 10; 15 &gt;= 9], [10 &gt;= 7; 10 &gt;= 5], [9 &gt;= 3])</p>
<h2 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h2><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序指的是对堆这种数据结构进行排序的一种算法。其基本思想如下，以最大堆为例：</p>
<ol>
<li>将数组序列构建成最大堆[ A1, A2, A3 .. An]，这个堆是一个刚初始化无序区，同时有序区为空</li>
<li>堆顶元素A1与最后一个元素An进行交换，得到新的有序区[An]，无序区变成[A1 … An-1]</li>
<li>交换之后可能导致[A1 … An-1]这个无序区不是一个最大堆，[A1 … An-1]无序区重新调整成最大堆。重复步骤2，A1与An-1进行交换，得到新的有序区[An,An-1]，无序区变成[A1 … An-2].. 不断重复，直到有序区的个数为n-1才结束排序过程</li>
</ol>
<p>构造堆的过程如下(以最大堆为例)：</p>
<p>从最后一个非叶子节点开始调整，遍历节点和2个子节点，选择键值最大的节点的键值代替父节点的键值，如果进行了调整，调整之后的两个子节点可能不符合堆特性，递归调整。一直直到调整完根节点。</p>
<p>以序列[3,5,15,9,10,1]为例进行的堆排序：</p>
<p>首先第1步先把数组转换成完全二叉树：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/heap02.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>接下来是第2、3步构造有序区和无序区：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/heap03.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>构造完之后有序区的元素依次是：1，3，5，9，10，15</p>
<p>简单地使用java写一下堆排序：</p>
<pre><code>public class HeapSort {

    public static void maxHeapify(int[] arr, int size, int index) {
        int leftSonIndex = 2 * index + 1;
        int rightSonIndex = 2 * index + 2;
        int temp = index;
        if(index &lt;= size / 2) {
            if(leftSonIndex &lt; size &amp;&amp; arr[temp] &lt; arr[leftSonIndex]) {
                temp = leftSonIndex;
            }
            if(rightSonIndex &lt; size &amp;&amp; arr[temp] &lt; arr[rightSonIndex]) {
                temp = rightSonIndex;
            }
            // 左右子节点的值存在比父节点的值更大
            if(temp != index) {
                swap(arr, index, temp); // 交换值
                maxHeapify(arr, size, temp); // 递归调整
            }
        }
    }

    public static void heapSort(int[] arr, int size) {
        // 构造成最大堆
        buildMaxHeap(arr, arr.length);
        for(int i = size - 1; i &gt; 0; i --) {
            // 先交换堆顶元素和无序区最后一个元素
            swap(arr, 0, i);
            // 重新调整无序区
            buildMaxHeap(arr, i - 1);
        }
    }

    public static void buildMaxHeap(int[] arr, int size) {
        for(int i = size / 2; i &gt;= 0; i --) { // 最后一个非叶子节点开始调整
            maxHeapify(arr, size, i);
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static void main(String[] args) {
        int[] arr = { 3, 5, 15, 9, 10, 1};
        System.out.println(&quot;before build: &quot; + Arrays.toString(arr)); // before build: [3, 5, 15, 9, 10, 1]
        buildMaxHeap(arr, arr.length);
        System.out.println(&quot;after build: &quot; + Arrays.toString(arr)); // after build: [15, 10, 3, 9, 5, 1]
        heapSort(arr, arr.length);
        System.out.println(&quot;after sort: &quot; + Arrays.toString(arr)); // after sort: [1, 3, 5, 9, 10, 15]
    }

}
</code></pre><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>在最大堆[ 15,10,9,7,5,3 ]上添加一个新的元素 11 ，执行的步骤如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/heap04.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>在最大堆[ 15,10,9,7,5,3 ]上删除元素 10 ，执行的步骤如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/heap05.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;堆的概念：&lt;/p&gt;
&lt;p&gt;n个元素序列 { k1, k2, k3, k4, k5, k6 …. kn } 当且仅当满足以下关系时才会被称为堆：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ki &amp;lt;= k2i,ki &amp;lt;= k2i+1 或者 ki &amp;gt;= k2i,ki &amp;gt;= k2i+1 (i = 1,2,3,4 .. n/2)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果数组的下表是从0开始，那么需要满足 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ki &amp;lt;= k2i+1,ki &amp;lt;= k2i+2 或者 ki &amp;gt;= k2i+1,ki &amp;gt;= k2i+2 (i = 0,1,2,3 .. n/2)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比如 { 1,3,5,10,15,9 } 这个序列就满足 [1 &amp;lt;= 3; 1 &amp;lt;= 5],  [3 &amp;lt;= 10; 3 &amp;lt;= 15], [5 &amp;lt;= 9] 这3个条件，这个序列就是一个堆。&lt;/p&gt;
&lt;p&gt;所以堆其实是一个序列(数组)，如果这个序列满足上述条件，那么就把这个序列看成堆。&lt;/p&gt;
&lt;p&gt;堆的实现通常是通过构造二叉堆，因为二叉堆应用很普遍，当不加限定时，堆通常指的就是二叉堆。&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://fangjian0423.github.io/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://fangjian0423.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>jdk TreeSet工作原理分析</title>
    <link href="http://fangjian0423.github.io/2016/04/08/jdk_treeset/"/>
    <id>http://fangjian0423.github.io/2016/04/08/jdk_treeset/</id>
    <published>2016-04-07T16:20:23.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>TreeSet跟HashSet，LinkedHashSet一样，都是Set接口的实现类。</p>
<p>HashSet内部使用的HashMap，LinkedHashSet继承HashSet，内部使用的是LinkedHashMap。</p>
<p>TreeSet实现的是NavigableSet接口，而不是HashSet和LinkedHashSet实现的Set接口。</p>
<p>NavigableSet接口继承自SortedSet接口，SortedSet接口继承自Set接口。</p>
<p>NavigableSet接口比Set更方便，可以使用firstKey[最小关键字]，lastKey[最大关键字]，pollFirstEntry[最小键值对]，pollLastEntry[最大键值对]，higherEntry[比参数关键字要大的键值对]，lowerEntry[比参数关键字要小的键值对]等等方便方法，可以使用这些方法方便地获取期望位置上的键值对。</p>
<a id="more"></a>
<h2 id="TreeSet原理分析"><a href="#TreeSet原理分析" class="headerlink" title="TreeSet原理分析"></a>TreeSet原理分析</h2><p>TreeSet跟HashSet一样，内部都使用Map，HashSet内部使用的是HashMap，但是TreeSet使用的是NavigableMap。</p>
<p>TreeSet的几个构造方法会构造NavigableMap，如果使用没有参数的构造函数，NavigableMap是TreeMap：</p>
<pre><code>TreeSet(NavigableMap&lt;E,Object&gt; m) {
    this.m = m;
}

public TreeSet() {
    this(new TreeMap&lt;E,Object&gt;());
}

public TreeSet(Comparator&lt;? super E&gt; comparator) {
    this(new TreeMap&lt;&gt;(comparator));
}
</code></pre><p>add方法调用Map的put方法：</p>
<pre><code>public boolean add(E e) {
    return m.put(e, PRESENT)==null;
}
</code></pre><p>remove方法调用Map的remove方法：</p>
<pre><code>public boolean remove(Object o) {
    return m.remove(o)==PRESENT;
}
</code></pre><p>原理基本跟HashSet一样。</p>
<pre><code>// 最小的关键字
public E first() {
    return m.firstKey();
}

// 最大的关键字
public E last() {
    return m.lastKey();
}

// 比参数小的关键字
public E lower(E e) {
    return m.lowerKey(e);
}
</code></pre><h2 id="一个TreeSet例子"><a href="#一个TreeSet例子" class="headerlink" title="一个TreeSet例子"></a>一个TreeSet例子</h2><p>使用没有参数的TreeMap构造函数，内部的Map使用TreeMap红黑树：</p>
<pre><code>TreeSet&lt;String&gt; set = new TreeSet&lt;String&gt;();
set.add(&quot;1:语文&quot;);
set.add(&quot;2:数学&quot;);
set.add(&quot;3:英语&quot;);
set.add(&quot;4:政治&quot;);
set.add(&quot;5:物理&quot;);
set.add(&quot;6:化学&quot;);
set.add(&quot;7:生物&quot;);
set.add(&quot;8:体育&quot;);
</code></pre><p>内部红黑树结构如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treeset01.jpg" alt=""></p>
<p>还可以调用TreeSet的其他方法：</p>
<pre><code>set.first(); // 1:语文
set.last(); // 8:体育
set.higher(&quot;5:物理&quot;); // 6:化学
set.lower(&quot;5:物理&quot;); // 4:政治
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TreeSet跟HashSet，LinkedHashSet一样，都是Set接口的实现类。&lt;/p&gt;
&lt;p&gt;HashSet内部使用的HashMap，LinkedHashSet继承HashSet，内部使用的是LinkedHashMap。&lt;/p&gt;
&lt;p&gt;TreeSet实现的是NavigableSet接口，而不是HashSet和LinkedHashSet实现的Set接口。&lt;/p&gt;
&lt;p&gt;NavigableSet接口继承自SortedSet接口，SortedSet接口继承自Set接口。&lt;/p&gt;
&lt;p&gt;NavigableSet接口比Set更方便，可以使用firstKey[最小关键字]，lastKey[最大关键字]，pollFirstEntry[最小键值对]，pollLastEntry[最大键值对]，higherEntry[比参数关键字要大的键值对]，lowerEntry[比参数关键字要小的键值对]等等方便方法，可以使用这些方法方便地获取期望位置上的键值对。&lt;/p&gt;
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="set" scheme="http://fangjian0423.github.io/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>jdk TreeMap工作原理分析</title>
    <link href="http://fangjian0423.github.io/2016/04/07/jdk_treemap/"/>
    <id>http://fangjian0423.github.io/2016/04/07/jdk_treemap/</id>
    <published>2016-04-06T16:55:31.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>TreeMap是jdk中基于红黑树的一种map实现。HashMap底层是使用链表法解决冲突的哈希表，LinkedHashMap继承自HashMap，内部同样也是使用链表法解决冲突的哈希表，但是额外添加了一个双向链表用于处理元素的插入顺序或访问访问。</p>
<p>既然TreeMap底层使用的是红黑树，首先先来简单了解一下红黑树的定义。</p>
<p>红黑树是一棵平衡二叉查找树，同时还需要满足以下5个规则：</p>
<ol>
<li>每个节点只能是红色或者黑点</li>
<li>根节点是黑点</li>
<li>叶子节点(Nil节点，空节点)是黑色节点</li>
<li>如果一个节点是红色节点，那么它的两个子节点必须是黑色节点(一条路径上不能出现相邻的两个红色节点)</li>
<li>从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点</li>
</ol>
<p>红黑树的这些特性决定了它的查询、插入、删除操作的时间复杂度均为O(log n)。</p>
<a id="more"></a>
<h2 id="一个TreeMap例子"><a href="#一个TreeMap例子" class="headerlink" title="一个TreeMap例子"></a>一个TreeMap例子</h2><p>一段TreeMap代码：</p>
<pre><code>TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;Integer, String&gt;();
treeMap.put(1, &quot;语文&quot;);
treeMap.put(2, &quot;数学&quot;);
treeMap.put(3, &quot;英语&quot;);
treeMap.put(4, &quot;政治&quot;);
treeMap.put(5, &quot;物理&quot;);
treeMap.put(6, &quot;化学&quot;);
treeMap.put(7, &quot;生物&quot;);
treeMap.put(8, &quot;体育&quot;);
</code></pre><p>执行过程：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap01.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>从上面这个例子看到，红黑树添加新节点的时候可能会对节点进行旋转，以保证树的局部平衡。</p>
<h2 id="TreeMap原理分析"><a href="#TreeMap原理分析" class="headerlink" title="TreeMap原理分析"></a>TreeMap原理分析</h2><p>TreeMap内部类Entry表示红黑树中的节点：</p>
<pre><code>static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    K key; // 关键字
    V value; // 值
    Entry&lt;K,V&gt; left; // 左节点
    Entry&lt;K,V&gt; right; // 右节点
    Entry&lt;K,V&gt; parent; // 父节点
    boolean color = BLACK; // 颜色，默认为黑色

    Entry(K key, V value, Entry&lt;K,V&gt; parent) {
        this.key = key;
        this.value = value;
        this.parent = parent;
    }

    ...
}
</code></pre><p>TreeMap的属性：</p>
<pre><code>private transient Entry&lt;K,V&gt; root; // 根节点

private transient int size = 0; // 节点个数
</code></pre><h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3><p>红黑树新节点的添加一定是红色节点，添加完新的节点之后会进行旋转操作以保持红黑树的特性。</p>
<p>为什么新添加的节点一定是红色节点，如果添加的是黑色节点，那么就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的；但是如果插入的是红色节点，只需要解决其父节点也为红色节点的这个冲突即可。</p>
<p>以N为新插入节点，P为其父节点，U为其父节点的兄弟节点，R为P和U的父亲节点进行分析。如果N的父节点为黑色节点，那直接添加新节点即可，没有产生冲突。如果出现P节点是红色节点，那便产生冲突，可以分为以下几种冲突：</p>
<p>(1) P为红色节点，且U也为红色节点，P不论是R的左节点还是右节点</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap04.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>将P和U接口变成黑色节点，R节点变成红色节点。修改之后如果R节点的父节点也是红色节点，那么在R节点上执行相同操作，形成了一个递归过程。如果R节点是根节点的话，那么直接把R节点修改成黑色节点。</p>
<p>(2) P为红色节点，U为黑色节点或缺少，且N是P的右节点、P是R的左节点 或者 P为红色节点，U为黑色节点或缺少，且N是P的左节点、P是R的右节点</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap07.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>这两种情况分别对P进行左旋和右旋操作。操作结果就变成了冲突3。 (总结起来就是左右变左左，右左变右右)</p>
<p>(3) P为红色节点，U为黑色节点或缺少，且N是P的左节点、P是R的左节点 或者 P为红色节点，U为黑色节点或缺少，且N是P的右节点、P是R的右节点</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap08.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>这两种情况分别对祖父R进行右旋和左旋操作。完美解决冲突。(总结起来就是左左祖右，右右祖左)</p>
<p>这3个新增节点的冲突处理方法了解之后，我们回过头来看本文一开始的例子中添加最后一个[8:体育]节点是如何处理冲突的：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap09.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>接下来我们看TreeMap是如何实现新增节点并处理冲突的。</p>
<p>TreeMap对应的put方法：</p>
<pre><code>public V put(K key, V value) {
    Entry&lt;K,V&gt; t = root;
    if (t == null) { // 如果根节点是空的，说明是第一次插入数据
        compare(key, key);

        root = new Entry&lt;&gt;(key, value, null); // 构造根节点，并赋值给属性root，默认颜色是黑色
        size = 1; // 节点数 = 1
        modCount++;
        return null;
    }
    int cmp;
    Entry&lt;K,V&gt; parent;
    // split comparator and comparable paths
    Comparator&lt;? super K&gt; cpr = comparator;
    if (cpr != null) { // 比较器存在
        do { // 遍历寻找节点，关键字比节点小找左节点，比节点大的找右节点，直到找到那个叶子节点，会保存需要新构造节点的父节点到parent变量里
            parent = t;
            cmp = cpr.compare(key, t.key);
            if (cmp &lt; 0)
                t = t.left;
            else if (cmp &gt; 0)
                t = t.right;
            else
                return t.setValue(value); // 关键字存在的话，直接用值覆盖原节点的关键字的值，并返回
        } while (t != null);
    }
    else { // 比较器不存在
        if (key == null)
            throw new NullPointerException();
        @SuppressWarnings(&quot;unchecked&quot;)
            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 比较器不存在直接将关键字转换成比较器，如果关键字不是一个Comparable接口实现类，将会报错
        do { // 遍历寻找节点，关键字比节点小找左节点，比节点大的找右节点，直到找到那个叶子节点，会保存需要新构造节点的父节点到parent变量里
            parent = t;
            cmp = k.compareTo(t.key);
            if (cmp &lt; 0)
                t = t.left;
            else if (cmp &gt; 0)
                t = t.right;
            else
                return t.setValue(value); // 关键字存在的话，直接用值覆盖原节点的关键字的值，并返回
        } while (t != null);
    }
    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); // 构造新的关键字节点
    if (cmp &lt; 0) // 需要在左节点构造
        parent.left = e;
    else // 需要在右节点构造
        parent.right = e;
    fixAfterInsertion(e); // 插入节点之后，处理冲突以保持树符合红黑树的特性
    size++;
    modCount++;
    return null;
}
</code></pre><p>fixAfterInsertion方法处理红黑树冲突实现如下：</p>
<pre><code>private void fixAfterInsertion(Entry&lt;K,V&gt; x) {
    x.color = RED; // 新增的节点一定是红色节点

    while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) { // P节点是红色节点并且N节点不是根节点的话一直循环
        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) { // P节点是R节点的左节点
            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); // y就是U节点
            if (colorOf(y) == RED) { // 如果U节点是红色节点，说明P和U这两个节点都是红色节点，满足冲突(1)
                setColor(parentOf(x), BLACK); // 冲突(1)解决方案 把P设置为黑色
                setColor(y, BLACK); // 冲突(1)解决方案 把U设置为黑色
                setColor(parentOf(parentOf(x)), RED); // 冲突(1)解决方案 把R设置为红色
                x = parentOf(parentOf(x)); // 递归处理R节点
            } else { // 如果U节点是黑色节点，满足冲突(2)或(3)
                if (x == rightOf(parentOf(x))) { // 如果N节点是P节点的右节点，满足冲突(2)的第一种情况
                    x = parentOf(x);
                    rotateLeft(x); // P节点进行左旋操作
                }
                // P节点左旋操作之后，满足了冲突(3)的第一种情况或者N一开始就是P节点的左节点，这本来就是冲突(3)的第一种情况
                setColor(parentOf(x), BLACK);  // P节点和R节点交换颜色，P节点变成黑色
                setColor(parentOf(parentOf(x)), RED); // P节点和R节点交换颜色，R节点变成红色
                rotateRight(parentOf(parentOf(x))); // R节点右旋操作
            }
        } else { // P节点是R节点的右节点
            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); // y就是U节点
            if (colorOf(y) == RED) { // 如果U节点是红色节点，说明P和U这两个节点都是红色节点，满足冲突(1)
                setColor(parentOf(x), BLACK); // 冲突(1)解决方案 把P设置为黑色
                setColor(y, BLACK); // 冲突(1)解决方案 把U设置为黑色
                setColor(parentOf(parentOf(x)), RED); // 冲突(1)解决方案 把R设置为红色
                x = parentOf(parentOf(x)); // 递归处理R节点
            } else { // 如果U节点是黑色节点，满足冲突(2)或(3)
                if (x == leftOf(parentOf(x))) { // 如果N节点是P节点的左节点，满足冲突(2)的第二种情况
                    x = parentOf(x);
                    rotateRight(x); // P节点右旋
                }
                // P节点右旋操作之后，满足了冲突(3)的第二种情况或者N一开始就是P节点的右节点，这本来就是冲突(3)的第二种情况
                setColor(parentOf(x), BLACK); // P节点和R节点交换颜色，P节点变成黑色
                setColor(parentOf(parentOf(x)), RED); // P节点和R节点交换颜色，R节点变成红色
                rotateLeft(parentOf(parentOf(x))); // R节点左旋操作
            }
        }
    }
    root.color = BLACK; // 根节点是黑色节点
}
</code></pre><p>fixAfterInsertion方法的代码跟之前分析的冲突解决方案一模一样。</p>
<h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><p>红黑树的get操作相比add操作简单不少，只需要比较关键字即可，要查找的关键字比节点关键字要小的话找左节点，否则找右节点，一直递归操作，直到找到或找不到。代码如下：</p>
<pre><code>final Entry&lt;K,V&gt; getEntry(Object key) {
    if (comparator != null)
        return getEntryUsingComparator(key);
    if (key == null)
        throw new NullPointerException();
    @SuppressWarnings(&quot;unchecked&quot;)
        Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
    Entry&lt;K,V&gt; p = root;
    while (p != null) {
        int cmp = k.compareTo(p.key); // 得到比较值
        if (cmp &lt; 0) // 小的话找左节点
            p = p.left;
        else if (cmp &gt; 0) // 大的话找右节点
            p = p.right;
        else
            return p;
    }
    return null;
}
</code></pre><h3 id="remove操作"><a href="#remove操作" class="headerlink" title="remove操作"></a>remove操作</h3><p>红黑树的删除节点跟添加节点一样，比较复杂，删除节点也会让树不符合红黑树的特性，也需要解决这些冲突。</p>
<p>删除操作分为2个步骤：</p>
<ol>
<li>将红黑树当作一颗二叉查找树，将节点删除</li>
<li>通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树</li>
</ol>
<p>步骤1的删除操作可分为几种情况：</p>
<ol>
<li>删除节点没有儿子：直接删除该节点</li>
<li>删除节点有1个儿子：删除该节点，并用该节点的儿子节点顶替它的位置</li>
<li>删除节点有2个儿子：可以转成成删除节点只有1个儿子的情况，跟二叉查找树一样，找出节点的右子树的最小元素(或者左子树的最大元素，这种节点称为后继节点)，并把它的值转移到删除节点，然后删除这个后继节点。这个后继节点最多只有1个子节点(如果有2个子节点，说明还能找出右子树更小的值)，所以这样删除2个儿子的节点就演变成了删除没有儿子的节点和删除只有1个儿子的节点的情况</li>
</ol>
<p>删除节点之后要考虑的问题就是红黑树失衡的调整问题。</p>
<p>步骤2遇到的调整问题只有2种情况：</p>
<ol>
<li>删除节点没有儿子节点</li>
<li>删除节点只有1个儿子节点</li>
</ol>
<p>删除节点没有儿子节点的话，直接把节点删除即可。如果节点是黑色节点，需要进行平衡性调整，否则，不用调整平衡性。这里的平衡性调整跟删除只有1个儿子节点一样，删除只有1个儿子的调整会先把节点删除，然后儿子节点顶上来，顶上来之后再进行平衡性调整。而删除没有儿子节点的节点的话，先进行调整，调整之后再把这个节点删除。他们的调整策略是一样的，只不过没有儿子节点的情况下先进行调整，然后再删除节点，而有儿子节点的情况下，先把节点删除，删除之后儿子节点顶上来，然后再做平衡性调整。</p>
<p>删除节点只有1个儿子节点还分几种情况：</p>
<ol>
<li>如果被删除的节点是红色节点，那说明它的父节点是黑色节点，儿子节点也是黑色节点，那么删除这个节点就不会影响红黑树的属性，直接使用它的黑色子节点代替它即可</li>
<li>如果被删除的节点是黑色节点，而它的儿子节点是红色节点。删除这个黑色节点之后，它的红色儿子节点顶替之后，会破坏性质5，只需要把儿子节点重绘为黑色节点即可，这样原先通过黑色删除节点的所有路径被现在的重绘后的儿子节点所代替</li>
<li>如果被删除的节点是黑色节点，而它的儿子节点也是黑色节点。这是一种复杂的情况，因为路径路过被删除节点的黑色节点路径少了1个，导致违反了性质5，所以需要对红黑树进行平衡调整。可分为以下几种情况进行调整：</li>
</ol>
<p>以N为删除节点的儿子节点(删除之后，处于新的位置上)，它的兄弟节点为S，它们的父节点为P，Sl和Sr为S节点的左右子节点为例，进行讲解，其中<strong>N是父节点P的左子节点</strong>，如果N是父节点P的右子节点，做对称处理。</p>
<p>3.1：N是新的根节点。这种情况下不用做任何处理，因为原先的节点也是一个根节点，相当于所有的路径都需要经过这个根节点，删除之后没有什么影响，而且新根也是黑色节点，符合所有特性，不需要进行调整</p>
<p>3.2: S节点是红色节点，那么P节点，Sl，Sr节点是黑色节点。在这种情况下，对P节点进行左选操作并且交换P和S的颜色。完成这2个操作之后，所有路径上的黑色节点没有变化，但是N节点有了一个黑色兄弟节点Sl和一个红色的父亲节点P，左子树删除节点后还有存在着少1个黑色节点路径的问题。接下来按照N节点新的位置(兄弟节点S是个黑色节点，父节点P是个红色节点)进行3.4、3.5或3.6情况处理<br><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap10.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>3.3：N的父亲节点P、兄弟节点S，还有S的两个子节点Sl，Sr均为黑色节点。在这种情况下，重绘S为红色。重绘之后路过S节点这边的路径跟N节点一样也少了一个黑色节点，但是出现了另外一个问题：不经过P节点的路径还是少了一个黑色节点。 接下来，要调整以P作为N递归调整树</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap11.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>3.4：S和S的儿子节点Sl、Sr为黑色节点，但是N的父亲节点P为红色节点。在这种情况下，交换N的兄弟S与父亲P的颜色，颜色交换之后左子树多了1个黑色节点路径，刚好填补了左子树删除节点的少一个黑色节点路径的问题，而右子树的黑色路径没有改变，解决平衡问题</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap12.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>3.5：S是黑色节点，S的左儿子节点Sl是红色，S的右儿子节点Sr是黑色节点。在这种情况下，在S上做右旋操作交换S和它新父亲的颜色。操作之后，左子树的黑色节点路径和右子树的黑色节点路径没有改变。但是现在N节点有了一个黑色的兄弟节点，黑色的兄弟节点有个红色的右儿子节点，满足了3.6的情况，按照3.6处理</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap13.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>3.6：S是黑色节点，S的右儿子节点Sr为红色节点，S的左儿子Sl是黑色节点，P是红色或黑色节点。在这种情况下，N的父亲P做左旋操作，交换N父亲P和S的颜色，S的右子节点Sr变成黑色。这样操作以后，左子树的黑色路径+1，补了删除节点的黑色路径，右子树黑色路径不变，解决平衡问题</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap14.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>了解了删除节点之后的平衡性调整之后，我们回过头来看本文一开始的例子进行节点删除的操作过程：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap15.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>TreeMap删除方法如下：</p>
<pre><code>private void deleteEntry(Entry&lt;K,V&gt; p) {
    modCount++;
    size--; // 节点个数 -1

    if (p.left != null &amp;&amp; p.right != null) { // 如果要删除的节点有2个子节点，去找后继节点
        Entry&lt;K,V&gt; s = successor(p); // 找出后继节点
        p.key = s.key; // 后继节点的关键字赋值给删除节点
        p.value = s.value; // 后继节点的值赋值给删除节点
        p = s; // 改为删除后继节点
    }

    Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); // 找出替代节点，左子树存在的话使用左子树，否则使用右子树。这个替代节点就是被删除节点的左子节点或右子节点

    if (replacement != null) { // 替代节点如果存在的话
        replacement.parent = p.parent; // 删除要删除的节点
        // 有子节点的删除节点先删除节点，然后再做平衡性调整
        if (p.parent == null) // 如果被删除节点的父节点为空，说明被删除节点是根节点
            root = replacement; // 用替代节点替代根节点
        else if (p == p.parent.left)
            p.parent.left  = replacement; // 用替代节点替代原先被删除的节点
        else
            p.parent.right = replacement; // 用替代节点替代原先被删除的节点

        p.left = p.right = p.parent = null;

        if (p.color == BLACK) // 被删除节点如果是黑色节点，需要进行平衡性调整
            fixAfterDeletion(replacement);
    } else if (p.parent == null) { // 如果被删除节点的父节点为空，说明被删除节点是根节点
        root = null; // 根节点的删除直接把根节点置空即可
    } else { //   如果要删除的节点没有子节点
        if (p.color == BLACK) // 如果要删除的节点是个黑色节点，需要进行平衡性调整
            fixAfterDeletion(p); // 调整平衡性，没有子节点的删除节点先进行平衡性调整

        if (p.parent != null) { // 没有子节点的删除节点平衡性调整完毕之后再进行节点删除
            if (p == p.parent.left)
                p.parent.left = null;
            else if (p == p.parent.right)
                p.parent.right = null;
            p.parent = null;
        }
    }
}

// 删除节点后的平衡性调整，对应之前分析的节点昵称，N、S、P、Sl、Sr
private void fixAfterDeletion(Entry&lt;K,V&gt; x) {
    while (x != root &amp;&amp; colorOf(x) == BLACK) { // N节点是黑色节点并且不是根节点就一直循环
        if (x == leftOf(parentOf(x))) { // 如果N是P的左子节点
            Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); // sib就是N节点的兄弟节点S

            if (colorOf(sib) == RED) { // 如果S节点是红色节点，满足删除冲突3.2，对P节点进行左旋操作并交换P和S的颜色
                // 交换P和S的颜色，S原先为红色，P原先为黑色(2个红色节点不能相连)
                setColor(sib, BLACK); // S节点从红色变成黑色
                setColor(parentOf(x), RED); // P节点从黑色变成红色
                rotateLeft(parentOf(x)); // 删除冲突3.2中P节点进行左旋
                sib = rightOf(parentOf(x)); // 左旋之后N节点有了一个黑色的兄弟节点和红色的父亲节点，S节点重新赋值成N节点现在的兄弟节点。接下来按照删除冲突3.4、3.5、3.6处理
            }

            // 执行到这里S节点一定是黑色节点，如果是红色节点，会按照冲突3.2交换成黑色节点
            // 如果S节点的左右子节点Sl、Sr均为黑色节点并且S节点也为黑色节点
            if (colorOf(leftOf(sib))  == BLACK &amp;&amp;
                colorOf(rightOf(sib)) == BLACK) {
                // 按照删除冲突3.3和3.4进行处理
                // 如果是冲突3.3，说明P节点也是黑色节点
                // 如果是冲突3.4，说明P节点是红色节点，P节点和S节点需要交换颜色
                // 3.3和3.4冲突的处理结果S节点都为红色节点，但是3.4冲突处理完毕之后直接结束，而3.3冲突处理完毕之后继续调整
                setColor(sib, RED); // S节点变成红色节点，如果是3.4冲突需要交换颜色，N节点的颜色交换在跳出循环进行
                x = parentOf(x); // N节点重新赋值成N节点的父节点P之后继续递归处理
            } else { // S节点的2个子节点Sl，Sr中存在红色节点
                if (colorOf(rightOf(sib)) == BLACK) { // 如果S节点的右子节点Sr为黑色节点，Sl为红色节点[Sl如果为黑色节点的话就在上一个if逻辑里处理了]，满足删除冲突3.5
                    // 删除冲突3.5，对S节点做右旋操作，交换S和Sl的颜色，S变成红色节点，Sl变成黑色节点
                    setColor(leftOf(sib), BLACK); // Sl节点变成黑色节点
                    setColor(sib, RED); // S节点变成红色节点
                    rotateRight(sib); // S节点进行右旋操作
                    sib = rightOf(parentOf(x)); // S节点赋值现在N节点的兄弟节点
                }
                // 删除冲突3.5处理之后变成了删除冲突3.6或者一开始就是删除冲突3.6
                // 删除冲突3.6，P节点做左旋操作，P节点和S接口交换颜色，Sr节点变成黑色
                setColor(sib, colorOf(parentOf(x))); // S节点颜色变成P节点颜色，红色
                setColor(parentOf(x), BLACK); // P节点变成S节点颜色，也就是黑色
                setColor(rightOf(sib), BLACK); // Sr节点变成黑色
                rotateLeft(parentOf(x)); // P节点做左旋操作
                x = root; // 准备跳出循环
            }
        } else { // 如果N是P的右子节点，处理过程跟N是P的左子节点一样，左右对换即可
            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));

            if (colorOf(sib) == RED) {
                setColor(sib, BLACK);
                setColor(parentOf(x), RED);
                rotateRight(parentOf(x));
                sib = leftOf(parentOf(x));
            }

            if (colorOf(rightOf(sib)) == BLACK &amp;&amp;
                colorOf(leftOf(sib)) == BLACK) {
                setColor(sib, RED);
                x = parentOf(x);
            } else {
                if (colorOf(leftOf(sib)) == BLACK) {
                    setColor(rightOf(sib), BLACK);
                    setColor(sib, RED);
                    rotateLeft(sib);
                    sib = leftOf(parentOf(x));
                }
                setColor(sib, colorOf(parentOf(x)));
                setColor(parentOf(x), BLACK);
                setColor(leftOf(sib), BLACK);
                rotateRight(parentOf(x));
                x = root;
            }
        }
    }

    setColor(x, BLACK); // 删除冲突3.4循环调出来之后N节点颜色设置为黑色 或者 删除节点只有1个红色子节点的时候，将顶上来的红色节点设置为黑色
}
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://dongxicheng.org/structure/red-black-tree/" target="_blank" rel="external">http://dongxicheng.org/structure/red-black-tree/</a></p>
<p><a href="http://blog.csdn.net/chenssy/article/details/26668941" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/26668941</a></p>
<p><a href="http://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91</a></p>
<p><a href="http://www.cnblogs.com/fanzhidongyzby/p/3187912.html" target="_blank" rel="external">http://www.cnblogs.com/fanzhidongyzby/p/3187912.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TreeMap是jdk中基于红黑树的一种map实现。HashMap底层是使用链表法解决冲突的哈希表，LinkedHashMap继承自HashMap，内部同样也是使用链表法解决冲突的哈希表，但是额外添加了一个双向链表用于处理元素的插入顺序或访问访问。&lt;/p&gt;
&lt;p&gt;既然TreeMap底层使用的是红黑树，首先先来简单了解一下红黑树的定义。&lt;/p&gt;
&lt;p&gt;红黑树是一棵平衡二叉查找树，同时还需要满足以下5个规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个节点只能是红色或者黑点&lt;/li&gt;
&lt;li&gt;根节点是黑点&lt;/li&gt;
&lt;li&gt;叶子节点(Nil节点，空节点)是黑色节点&lt;/li&gt;
&lt;li&gt;如果一个节点是红色节点，那么它的两个子节点必须是黑色节点(一条路径上不能出现相邻的两个红色节点)&lt;/li&gt;
&lt;li&gt;从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;红黑树的这些特性决定了它的查询、插入、删除操作的时间复杂度均为O(log n)。&lt;/p&gt;
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="map" scheme="http://fangjian0423.github.io/tags/map/"/>
    
  </entry>
  
</feed>
