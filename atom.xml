<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Format's Notes]]></title>
  <subtitle><![CDATA[吃饭睡觉撸代码]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://fangjian0423.github.io/"/>
  <updated>2016-09-03T12:47:41.000Z</updated>
  <id>http://fangjian0423.github.io/</id>
  
  <author>
    <name><![CDATA[Format]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Netty的单元测试]]></title>
    <link href="http://fangjian0423.github.io/2016/09/03/netty-unittest/"/>
    <id>http://fangjian0423.github.io/2016/09/03/netty-unittest/</id>
    <published>2016-09-03T13:04:52.000Z</published>
    <updated>2016-09-03T12:47:41.000Z</updated>
    <content type="html"><![CDATA[<p>我们在编写完Netty程序之后，会需要进行ChannelHandler的一些测试。</p>
<p>在初学Netty的时候，我们都是直接起一个Server，然后再写一个Client去连接Server，看传输的数据和接收到的数据是否正确。</p>
<p>在<a href="https://book.douban.com/subject/24700704/" target="_blank" rel="external">Netty in Action</a>书中的Transport和Unit-test your code这两章就提出了可以使用EmbeddedChannel进行ChanndlHandler的单元测试。</p>
<a id="more"></a>
<h2 id="EmbeddedChannel介绍">EmbeddedChannel介绍</h2><p>EmbeddedChannel中提供了一些方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>writeInbound</td>
<td>写数据到Channel中，但是这些数据只会被ChannelPipeline中的inbound handler处理。如果可以从EmbeddedChannel的readInbound方法中读取出数据的话，就返回true</td>
</tr>
<tr>
<td>readInbound</td>
<td>读取在EmbeddedChannel上被所有inbound handler处理过的数据，如果已经没有数据可以读取就返回null</td>
</tr>
<tr>
<td>writeInbound</td>
<td>写数据到Channel中，但是这些数据只会被ChannelPipeline中的outbound handler处理。如果可以从EmbeddedChannel的readOutbound方法中读取出数据的话，就返回true</td>
</tr>
<tr>
<td>readOutbound</td>
<td>读取在EmbeddedChannel上被所有outbound handler处理过的数据，如果已经没有数据可以读取就返回null</td>
</tr>
<tr>
<td>finish</td>
<td>标记EmbeddedChannel已经完成。如果可以从inbound或者outbound中返回数据，该方法就返回true。这个方法还会关闭Channel</td>
</tr>
</tbody>
</table>
<p>下图就是EmbeddedChannel的处理流程图：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty10.png" alt=""></p>
<p>使用writeInbound方法写入的数据，并经过Pipeline中所有的inbound handler，之后可以使用readInbound方法读取经过inbound handler之后的数据。</p>
<p>使用writeOutbound方法写入的数据，并经过Pipeline中所有的outbound handler，之后可以使用readOutbound方法读取经过outbound handler之后的数据。</p>
<p>调用finish方法可以标记EmbeddedChannel已经完成。</p>
<h2 id="Inbound_Handler的测试">Inbound Handler的测试</h2><p>Netty内部提供了一个FixedLengthFrameDecoder解码器用于把长度不固定的字节转换成固定长度的字节，处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty11.png" alt=""></p>
<p>针对这个Decoder编写单元测试。</p>
<p>由于是个Decoder，针对的是inbound中的数据，所以需要使用的方法是writeInbound和readInbound：</p>
<pre><code>ByteBuf buf = Unpooled.buffer(); <span class="comment">// 构造heap buffer</span>
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++) { <span class="comment">// 写入9个字节</span>
    buf.writeByte(i);
}

ByteBuf input = buf.copy();

<span class="comment">// 构造EmbeddedChannel，并在Pipeline中加入FixedLengthFrameDecoder</span>
EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(<span class="keyword">new</span> FixedLengthFrameDecoder(<span class="number">3</span>));

<span class="comment">// 使用writeInbound方法写入数据</span>
Assert.assertTrue(channel.writeInbound(input));
<span class="comment">// 标记EmbeddedChannel状态已经complete</span>
Assert.assertTrue(channel.finish());

<span class="comment">// 读取经过FixedLengthFrameDecoder处理过后的字节</span>
Assert.assertEquals(buf.readBytes(<span class="number">3</span>), channel.readInbound());
Assert.assertEquals(buf.readBytes(<span class="number">3</span>), channel.readInbound());
Assert.assertEquals(buf.readBytes(<span class="number">3</span>), channel.readInbound());
Assert.assertNull(channel.readInbound());
</code></pre><p>我们在<a href="http://fangjian0423.github.io/2016/08/30/netty-custom-protocol/">使用Netty编写自定义的协议</a>文章中编写的自定义协议CustomProtocol的解码器，并最后通过一个server和client的编写完成了测试。</p>
<p>现在我们可以使用EmbeddedChannel进行Decoder的unit test：</p>
<pre><code>EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(<span class="keyword">new</span> CustomProtocolDecoder());
<span class="typename">String</span> uuid = UUID.randomUUID().toString();
channel.writeInbound(<span class="keyword">new</span> CustomProtocol(<span class="number">1024</span>l, uuid, <span class="string">"content content"</span>));
<span class="keyword">Assert</span>.assertTrue(channel.finish());

CustomProtocol customProtocol = (CustomProtocol) channel.readInbound();
// 判断是否正确
<span class="keyword">Assert</span>.assertEquals(<span class="number">1024</span>l, customProtocol.getVersion());
<span class="keyword">Assert</span>.assertEquals(uuid, customProtocol.getHeader());
<span class="keyword">Assert</span>.assertEquals(<span class="string">"content content"</span>, customProtocol.getContent());
<span class="keyword">Assert</span>.assertNull(channel.readInbound());
</code></pre><h2 id="Outbound_Handler的测试">Outbound Handler的测试</h2><p>AbsIntegerEncoder对所有的int数据取绝对值。处理流过图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty12.png" alt=""></p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">AbsIntegerEncoder</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">MessageToMessageEncoder&lt;ByteBuf&gt;</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void encode(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">ByteBuf</span> msg, <span class="type">List</span>&lt;<span class="type">Object</span>&gt; out) <span class="keyword">throws</span> <span class="type">Exception</span> {
        <span class="keyword">while</span>(msg.readableBytes() &gt;= <span class="number">4</span>) {
            int value = <span class="type">Math</span>.abs(msg.readInt());
            out.add(value);
        }
    }
}
</code></pre><p>针对这个Encoder编写单元测试。</p>
<p>由于是个Encoder，针对的是outbound中的数据，所以需要使用的方法是writeOutbound和readOutbound：</p>
<pre><code>ByteBuf buf = Unpooled.buffer(); <span class="comment">// 构造heap buffer</span>
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++) { <span class="comment">// 写入10个负数</span>
    buf.writeInt(i * -<span class="number">1</span>);
}
<span class="comment">// 构造EmbeddedChannel，并在Pipeline中加入AbsIntegerEncoder</span>
EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(<span class="keyword">new</span> AbsIntegerEncoder());
<span class="comment">// 使用writeOutbound方法写入数据</span>
Assert.assertTrue(channel.writeOutbound(buf));
<span class="comment">// 标记EmbeddedChannel状态已经complete</span>
Assert.assertTrue(channel.finish());

<span class="comment">// 测试是否所有的int数据都取了绝对值</span>
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++) {
    Assert.assertEquals(i, (<span class="keyword">int</span>)channel.readOutbound());
}
Assert.assertNull(channel.readOutbound());
</code></pre><p>同理我们可以使用EmbeddedChannel进行CustomProtocol的Encoder的unit test：</p>
<pre><code>EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(<span class="keyword">new</span> CustomProtocolEncoder());
<span class="typename">String</span> uuid = UUID.randomUUID().toString();

channel.writeOutbound(<span class="keyword">new</span> CustomProtocol(<span class="number">1024</span>l, uuid, <span class="string">"content content"</span>));
<span class="keyword">Assert</span>.assertTrue(channel.finish());

ByteBuf buf = (ByteBuf) channel.readOutbound();
<span class="keyword">Assert</span>.assertEquals(<span class="number">1024</span>l, buf.readLong());
byte[] headerBytes = <span class="keyword">new</span> byte[<span class="number">36</span>];
buf.readBytes(headerBytes);
<span class="keyword">Assert</span>.assertEquals(uuid, <span class="keyword">new</span> <span class="typename">String</span>(headerBytes));
byte[] contentBytes = <span class="keyword">new</span> byte[buf.readableBytes()];
buf.readBytes(contentBytes);
<span class="keyword">Assert</span>.assertEquals(<span class="string">"content content"</span>, <span class="keyword">new</span> <span class="typename">String</span>(contentBytes));
<span class="keyword">Assert</span>.assertNull(channel.readOutbound());
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>我们在编写完Netty程序之后，会需要进行ChannelHandler的一些测试。</p>
<p>在初学Netty的时候，我们都是直接起一个Server，然后再写一个Client去连接Server，看传输的数据和接收到的数据是否正确。</p>
<p>在<a href="https://book.douban.com/subject/24700704/">Netty in Action</a>书中的Transport和Unit-test your code这两章就提出了可以使用EmbeddedChannel进行ChanndlHandler的单元测试。</p>]]>
    
    </summary>
    
      <category term="netty" scheme="http://fangjian0423.github.io/tags/netty/"/>
    
      <category term="nio" scheme="http://fangjian0423.github.io/tags/nio/"/>
    
      <category term="netty" scheme="http://fangjian0423.github.io/categories/netty/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Netty编写自定义的协议]]></title>
    <link href="http://fangjian0423.github.io/2016/08/30/netty-custom-protocol/"/>
    <id>http://fangjian0423.github.io/2016/08/30/netty-custom-protocol/</id>
    <published>2016-08-30T14:04:52.000Z</published>
    <updated>2016-08-30T13:28:26.000Z</updated>
    <content type="html"><![CDATA[<p>Netty内部提供的Codec用于处理消息的编解码问题，比如Http，Ftp，SMTP这些协议，都需要进行编解码。</p>
<p>Netty内部直接提供了Http协议的Codec组件用于编解码Http协议。</p>
<p>在开发过程中，有时候我们需要构建一些适应自己业务的应用层协议，Netty可以很方便地实现自定义协议。</p>
<p>比如我们的自定义协议CucstomProtocol结构如下：</p>
<pre><code>|<span class="string"> version </span>|<span class="string"> header </span>|<span class="string"> content </span>|
</code></pre><p>其中version表示版本号，long类型；header是一个uuid，string类型，content则是具体的内容，string类型。</p>
<a id="more"></a>
<p>对应的POJO如下：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> CustomProtocol {
    <span class="keyword">private</span> <span class="built_in">long</span> <span class="keyword">version</span>; <span class="comment">// 版本</span>
    <span class="keyword">private</span> String header; <span class="comment">// 头信息(UUID)</span>
    <span class="keyword">private</span> String content; <span class="comment">// 具体内容</span>
    <span class="comment">// GET SET ...</span>
    <span class="keyword">@Override</span>
    <span class="keyword">public</span> String toString() {
        <span class="keyword">return</span> <span class="string">"CustomProtocol{"</span> +
                <span class="string">"version="</span> + <span class="keyword">version</span> +
                <span class="string">", header='"</span> + header + <span class="string">'\''</span> +
                <span class="string">", content='"</span> + content + <span class="string">'\''</span> +
                <span class="string">'}'</span>;
    }
}
</code></pre><p>解码器把byte转换成CustomProtocol，在server中使用：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> CustomProtocolDecoder extends ByteToMessageDecoder {
    <span class="keyword">@Override</span>
    <span class="keyword">protected</span> <span class="keyword">void</span> decode(ChannelHandlerContext ctx, ByteBuf <span class="keyword">in</span>, List&lt;Object&gt; <span class="keyword">out</span>) throws Exception {
        <span class="built_in">long</span> <span class="keyword">version</span> = <span class="keyword">in</span>.readLong(); <span class="comment">// 读取version</span>

        <span class="keyword">byte</span>[] headerBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">36</span>];
        <span class="keyword">in</span>.readBytes(headerBytes); <span class="comment">// 读取header</span>

        String header = <span class="keyword">new</span> String(headerBytes);

        <span class="keyword">byte</span>[] contentBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="keyword">in</span>.readableBytes()]; <span class="comment">// 读取content</span>
        <span class="keyword">in</span>.readBytes(contentBytes);

        <span class="keyword">out</span>.add(<span class="keyword">new</span> CustomProtocol(<span class="keyword">version</span>, header, <span class="keyword">new</span> String(contentBytes)));
    }
}
</code></pre><p>编码器把CustomProtocol转换成byte，在client中使用：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">CustomProtocolEncoder</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">MessageToByteEncoder&lt;CustomProtocol&gt;</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void encode(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">CustomProtocol</span> msg, <span class="type">ByteBuf</span> out) <span class="keyword">throws</span> <span class="type">Exception</span> {
        out.writeLong(msg.getVersion());
        out.writeBytes(msg.getHeader().getBytes());
        out.writeBytes(msg.getContent().getBytes());
    }
}
</code></pre><p>server代码：</p>
<pre><code>ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();
EventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();
EventLoopGroup childEventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();

<span class="keyword">try</span> {
    serverBootstrap
            .group(eventLoopGroup, childEventLoopGroup)
            .channel(NioServerSocketChannel.class)
            .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() {
                <span class="annotation">@Override</span>
                <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>{
                    ch.pipeline().addLast(<span class="keyword">new</span> CustomProtocolDecoder()); <span class="comment">// 解码器</span>
                    ch.pipeline().addLast(<span class="keyword">new</span> ServerHandler()); <span class="comment">// 打印数据</span>
                }
            });

    ChannelFuture future = serverBootstrap.bind(<span class="string">"localhost"</span>, <span class="number">9999</span>).sync();

    future.channel().closeFuture().sync();
} <span class="keyword">catch</span> (Exception e) {
    e.printStackTrace();
} <span class="keyword">finally</span> {
    <span class="keyword">try</span> {
        eventLoopGroup.shutdownGracefully().sync();
        childEventLoopGroup.shutdownGracefully().sync();
    } <span class="keyword">catch</span> (Exception e1) {
        e1.printStackTrace();
    }
}
</code></pre><p>ServerHandler用于打印接收到的数据，并写数据回去给客户端表示接收到了数据：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">SimpleChannelInboundHandler&lt;CustomProtocol&gt;</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void channelRead0(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">CustomProtocol</span> msg) <span class="keyword">throws</span> <span class="type">Exception</span> {
        <span class="type">System</span>.out.println(<span class="string">"server receive: "</span> + msg);
        ctx.writeAndFlush(<span class="type">Unpooled</span>.copiedBuffer(<span class="string">"server get"</span>, <span class="type">CharsetUtil</span>.<span class="type">UTF_8</span>)).addListener(<span class="type">ChannelFutureListener</span>.<span class="type">CLOSE</span>);
    }
}
</code></pre><p>client代码：</p>
<pre><code>Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();

EventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();

<span class="keyword">try</span> {
    bootstrap
            .group(eventLoopGroup)
            .channel(NioSocketChannel.class)
            .<span class="keyword">handler</span>(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() {
                <span class="annotation">@Override</span>
                <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>{
                    ch.pipeline().addLast(<span class="keyword">new</span> CustomProtocolEncoder()); <span class="comment">// 编码器</span>
                    ch.pipeline().addLast(<span class="keyword">new</span> ClientHandler()); <span class="comment">// 接收服务端数据</span>
                }
            });
    ChannelFuture channelFuture = bootstrap.connect(<span class="string">"localhost"</span>, <span class="number">9999</span>).sync();

    channelFuture.channel().writeAndFlush(<span class="keyword">new</span> CustomProtocol(<span class="number">1024</span>l, UUID.randomUUID().toString(), <span class="string">"content detail"</span>));

    channelFuture.channel().closeFuture().sync();
} <span class="keyword">catch</span> (Exception e) {
    e.printStackTrace();
} <span class="keyword">finally</span> {
    <span class="keyword">try</span> {
        eventLoopGroup.shutdownGracefully().sync();
    } <span class="keyword">catch</span> (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre><p>ClientHandler用于接收服务端返回回来的数据：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">SimpleChannelInboundHandler&lt;ByteBuf&gt;</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void channelRead0(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">ByteBuf</span> msg) <span class="keyword">throws</span> <span class="type">Exception</span> {
        <span class="type">System</span>.out.println(<span class="string">"send success, response is: "</span> + msg.toString(<span class="type">CharsetUtil</span>.<span class="type">UTF_8</span>));
    }
}
</code></pre><p>启动服务端和客户端之后，服务端收到客户端发来的CustomProtocol：</p>
<pre><code><span class="keyword">server</span> receive: CustomProtocol{version=<span class="number">1024</span>, header=<span class="string">'6ed7fa3d-7d54-4add-9081-d659d4b37d3f'</span>, content=<span class="string">'content detail'</span>}
</code></pre><p>之后客户端也收到服务端成功接收数据的反馈：</p>
<pre><code>send success, <span class="built_in">response</span> <span class="keyword">is</span>: <span class="built_in">server</span> <span class="keyword">get</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Netty内部提供的Codec用于处理消息的编解码问题，比如Http，Ftp，SMTP这些协议，都需要进行编解码。</p>
<p>Netty内部直接提供了Http协议的Codec组件用于编解码Http协议。</p>
<p>在开发过程中，有时候我们需要构建一些适应自己业务的应用层协议，Netty可以很方便地实现自定义协议。</p>
<p>比如我们的自定义协议CucstomProtocol结构如下：</p>
<pre><code>|<span class="string"> version </span>|<span class="string"> header </span>|<span class="string"> content </span>|
</code></pre><p>其中version表示版本号，long类型；header是一个uuid，string类型，content则是具体的内容，string类型。</p>]]>
    
    </summary>
    
      <category term="netty" scheme="http://fangjian0423.github.io/tags/netty/"/>
    
      <category term="nio" scheme="http://fangjian0423.github.io/tags/nio/"/>
    
      <category term="netty" scheme="http://fangjian0423.github.io/categories/netty/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Netty in Action笔记(二)]]></title>
    <link href="http://fangjian0423.github.io/2016/08/29/netty-in-action-note2/"/>
    <id>http://fangjian0423.github.io/2016/08/29/netty-in-action-note2/</id>
    <published>2016-08-29T12:36:52.000Z</published>
    <updated>2016-08-29T12:07:20.000Z</updated>
    <content type="html"><![CDATA[<p>主要记录ChannelHandler、Codec以及Bootstrap的作用，还有Netty内置的一些ChannelHandler、Codec，以及Bootstrap的分类。</p>
<a id="more"></a>
<h2 id="第六章">第六章</h2><p>介绍Netty中的Channel、ChannelHandler、ChannelHandlerContext以及ChannelPipeline。</p>
<h3 id="Channel">Channel</h3><p>定义：一个Channel表示一个通道，跟io中的stream的角色一样，但是有几点不同。 1. stream是单向的，只支持读或者写，channel是双向的，既支持读也支持写。2. stream是阻塞的，channel是并行的。</p>
<p>其中Channel的生命周期状态如下：</p>
<table>
<thead>
<tr>
<th>状态说明</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>channelUnregistered</td>
<td>channel创建之后，还未注册到EventLoop</td>
</tr>
<tr>
<td>channelRegistered</td>
<td>channel注册到了对应的EventLoop</td>
</tr>
<tr>
<td>channelActive</td>
<td>channel处于活跃状态，活跃状态表示已经连接到了远程服务器，现在可以接收和发送数据</td>
</tr>
<tr>
<td>channelInactive</td>
<td>channel未连接到远程服务器</td>
</tr>
</tbody>
</table>
<p>一个Channel正常的生命周期如下：</p>
<p>channelRegistered -&gt; channelActice -&gt; channelInactive -&gt; channelUnregistered</p>
<p>在另外一种特殊情况下，会发生多次channelRegistered和channelUnregistered，这是因为用户可以从EventLoop上取消注册Channel来阻止事件的执行并在之后重新注册。状态变化如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty03.png" alt=""></p>
<h3 id="ChannelHandler">ChannelHandler</h3><p>ChannelHandler有2种类型：</p>
<ol>
<li>Inbound Handler: 处理inbound数据(接收到的数据)以及所有类型的channel状态修改事件</li>
<li>Outbound Handler: 处理outbound数据(发送出去的数据)并且可以拦截各种操作，比如bind、connect、disconnect、close、write等操作</li>
</ol>
<p>Inbound和Outbound Handler都属于ChannelHandler，它们都可以被添加到ChannelPipeline中，它们内部也提供了handlerAdded、handlerRemoved这两种方法分别在ChannelHandler添加到ChannelPipeline和ChannelHandler从ChannelPipeline中被删除的时候触发。</p>
<h4 id="ChannelInboundHandler">ChannelInboundHandler</h4><p>ChannelInboundHandler方法在两种情况下触发：channel状态的改变和channel接收到数据。</p>
<p>一些方法说明：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>channelRegistered(..)</td>
<td>Channel注册到EventLoop，并且可以处理IO请求</td>
</tr>
<tr>
<td>channelUnregistered(…)</td>
<td>Channel从EventLoop中被取消注册，并且不能处理任何IO请求</td>
</tr>
<tr>
<td>channelActive(…)</td>
<td>Channel已经连接到远程服务器，并准备好了接收数据</td>
</tr>
<tr>
<td>channelInactive(…)</td>
<td>Channel还没有连接到远程服务器</td>
</tr>
<tr>
<td>channelReadComplete(…)</td>
<td>Channel的读取操作已经完成</td>
</tr>
<tr>
<td>channelRead(…)</td>
<td>有数据可以读取的时候触发</td>
</tr>
<tr>
<td>userEventTriggered(…)</td>
<td>当用户调用Channel.fireUserEventTriggered方法的时候触发，用户可以传递一个自定义的对象当这个方法里</td>
</tr>
</tbody>
</table>
<p>ChannelInboundHandler有一个实现ChannelInboundHandlerAdapter，它实现了所有的方法，我们只需要继承这个类然后复写需要的方法即可。</p>
<p>ChannelInboundHandler中的channelRead方法中有读取的ByteBuf。由于Netty在ByteBuf的使用上使用了池的概念，当不需要这个ByteBuf的时候需要进行资源的释放以减少内存的消耗。</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>{
      <span class="comment">// do something</span>
      ReferenceCountUtil.release(msg);
}
</code></pre><p>Netty内部提供了一个SimpleChannelInboundHandler类，这个类读取数据会自动释放资源。它继承ChannelInboundHandlerAdapter并复写了channelRead方法，在channelRead方法里面finally代码里会自动release资源，并提供了channelRead0方法：</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>{
      <span class="comment">// do something, do not need release</span>
}
</code></pre><p>所以一般使用ChannelInboundHandler的话，有3种方法。 </p>
<ol>
<li>直接实现ChannelInBoundHandler接口 </li>
<li>继承ChannelInboundHandlerAdapter</li>
<li>继承SimpleChannelInboundHandler</li>
</ol>
<p>第1种基本不用，第3种用来处理接收消息，第2种用来处理事件状态的改变</p>
<h4 id="ChannelOutboundHandler">ChannelOutboundHandler</h4><p>ChannelOutboundHandler方法在两种情况下触发：发送数据和拦截操作。</p>
<p>ChannelOutboundHandler有一个强大的功能，可以按需推迟一个操作，这使得处理请求可以用到更为复杂的策略。比如，如果写数据到远端被暂停，你可以推迟flush操作，稍后再试。</p>
<p>一些方法说明：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>bind(..)</td>
<td>请求绑定channel到本地地址</td>
</tr>
<tr>
<td>connect(…)</td>
<td>channel连接到远程地址</td>
</tr>
<tr>
<td>disconnect(…)</td>
<td>channel从远程服务器上断开</td>
</tr>
<tr>
<td>close(…)</td>
<td>关闭channel</td>
</tr>
<tr>
<td>deregister(…)</td>
<td>取消channel在eventloop上的注册</td>
</tr>
<tr>
<td>read(…)</td>
<td>在channel中读数据</td>
</tr>
<tr>
<td>flush(…)</td>
<td>flush数据到远程服务器</td>
</tr>
<tr>
<td>write(…)</td>
<td>写数据到远程服务器</td>
</tr>
</tbody>
</table>
<p>ChannelOutboundHandler有一个实现ChannelOutboundHandlerAdapter，它实现了所有的方法，我们只需要继承这个类然后复写需要的方法即可。</p>
<p>在outboundhandler中有时候也需要释放资源，当消息被消费并且不再需要传递给下一个outbound handler的时候，调用ReferenceCountUtil.release(message)释放消息。</p>
<p>当消息被写回去或者channel关闭的时候，这个消息的资源会被自动释放，所以没有一个类似SimpleChannelInboundHandler的概念。</p>
<h3 id="ChannelHandlerContext">ChannelHandlerContext</h3><p>当ChannelHandler被添加到ChannelPipeline中的时候，ChannelHandlerContext会被创建。<br>所以说ChannelHandlerContext属于ChannelHandler。</p>
<p>可以通过ChannelHandlerContext的channel方法得到Channel和pipeline方法得到ChannelPipeline。</p>
<p>ChannelHandlerContext可以被保留下来并且在其他地方进行调用，比如在其他线程，或者在handler外部进行调用。</p>
<p>可以使用以下方法保留ChannelHandlerContext：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">WriterHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ChannelHandlerAdapter</span> {</span>
  <span class="keyword">private</span> <span class="type">ChannelHandlerContext</span> ctx;

  <span class="annotation">@Override</span>
  public void handlerAdded(<span class="type">ChannelHandlerContext</span> ctx) <span class="keyword">throws</span> <span class="type">Exception</span> {
      <span class="keyword">this</span>.ctx = ctx;
  }

  public void send(<span class="type">String</span> msg) {
      ctx.write(msg);
  }
}
</code></pre><p>Netty中提供了一个@Sharable注解用来将一个实例的ChannelHandler添加到多个ChannelPipeline中，如果不加上这个注解，被多个ChannelPipeline使用的话会抛出异常。</p>
<h3 id="ChannelPipeline">ChannelPipeline</h3><p>多个ChannelHandler可以组成一个ChannelPipeline，里面的每个ChannelHandler可以转发给下一个ChannelHandler。</p>
<p>ChannelPipeline内部的所有ChannelHandler的处理流程图：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty01.png" alt=""></p>
<p>ChannelPipeline提供了多种方法用于添加或删除或代替ChannelHandler，比如addLast, addFirst, remove, replace等方法。</p>
<h2 id="第七章">第七章</h2><p>介绍Netty中的编码器、解码器。我们知道网络中传输的是字节-ByteBuf。我们需要对ByteBuf进行一些解码用于解码成熟悉的POJO，对ByteBuf进行编码用于网络传输。</p>
<h3 id="Decoder">Decoder</h3><p>解码器，针对的是inbound的数据，也就是读取数据的解码。</p>
<p>2种类型：</p>
<ol>
<li>bytes到message的解码(ByteToMessageDecoder和ReplayingDecoder)</li>
<li>message到message的解码(MessageToMessageDecoder)</li>
</ol>
<p>decoders的作用是把inbound中读取的数据从一种格式转换成另一种格式，由于decoders处理的是inbound中的数据，所以它也是ChannelInboundHandler的一种实现类。</p>
<p>ByteToMessageDecoder和ReplayingDecoder属于bytes到message的解码。</p>
<p>一个ByteToMessageDecoder例子，将byte转换成integer：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ByteToMessageDecoder</span> {</span>
    <span class="annotation">@Override</span>  <span class="keyword">protected</span> void decode(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">ByteBuf</span> in,     <span class="type">List</span>&lt;<span class="type">Object</span>&gt; out) <span class="keyword">throws</span> <span class="type">Exception</span> {
        <span class="keyword">if</span>(in.readableBytes() &gt;= <span class="number">4</span>) {
            out.add(in.readInt());
        }
    }    
}
</code></pre><p>处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty04.png" alt=""></p>
<p>如果使用ReplayingDecoder，不需要进行可读字节的判断，直接添加到List里即可。跟ToIntegerDecoder实现一样的功能，ReplayingDecoder只需要这样即可。(但是有一定的局限性：1.不是所有的操作都被ByteBuf支持 2.ByteBuf.readableBytes方法大部分时间不会返回期望的值)</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder2</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ReplayingDecoder&lt;Void&gt;</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void decode(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">ByteBuf</span> in, <span class="type">List</span>&lt;<span class="type">Object</span>&gt;     out) <span class="keyword">throws</span> <span class="type">Exception</span> {
        out.add(in.readInt());
    }
}
</code></pre><p>一个MessageToMessageDecoder例子，将integer转换成string：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">IntegerToStringDecoder</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">MessageToMessageDecoder&lt;Integer&gt;</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void decode(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Integer</span> msg, <span class="type">List</span>&lt;<span class="type">Object</span>&gt; out) <span class="keyword">throws</span> <span class="type">Exception</span> {
        out.add(<span class="type">String</span>.valueOf(msg));
    }
}
</code></pre><p>处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty05.png" alt=""></p>
<h3 id="Encoder">Encoder</h3><p>编码器，针对的是outbound的数据，也就是发送出去的数据的编码。</p>
<p>2种类型：</p>
<ol>
<li>message到message的编码(MessageToMessageEncoder)</li>
<li>message到byte的编码(MessageToByteEncoder)</li>
</ol>
<p>decoders的作用是把outbound中发送出去的数据从一种格式转换成另一种格式，由于eecoders处理的是outbound中的数据，所以它也是ChannelOutboundHandler的一种实现类。</p>
<p>一个MessageToByteEncoder例子，将integer转换成byte：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">IntegerToByteEncoder</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">MessageToByteEncoder&lt;Integer&gt;</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void encode(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Integer</span> msg, <span class="type">ByteBuf</span> out) <span class="keyword">throws</span> <span class="type">Exception</span> {
        out.writeInt(msg);
    }
}
</code></pre><p>处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty06.png" alt=""></p>
<p>一个MessageToMessageEncoder例子，将integer转换成string：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">IntegerToStringEncoder</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">MessageToMessageEncoder&lt;Integer&gt;</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void encode(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Integer</span> msg, <span class="type">List</span>&lt;<span class="type">Object</span>&gt; out) <span class="keyword">throws</span> <span class="type">Exception</span> {
        out.add(<span class="type">String</span>.valueOf(msg));
    }
}
</code></pre><p>处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty07.png" alt=""></p>
<h3 id="Codec">Codec</h3><p>编解码器，既支持编码器的功能，也支持解码器的功能。</p>
<p>2种类型：</p>
<ol>
<li>ByteToMessageCodec：message到byte的编解码</li>
<li>MessageToMessageCodec：message到message的编解码</li>
</ol>
<h3 id="CombinedChannelDuplexHandler">CombinedChannelDuplexHandler</h3><p>结合解码器和编码器在一起可能会牺牲可重用性。为了避免这种方式，可以使用CombinedChannelDuplexHandler。</p>
<p>CombinedChannelDuplexHandler也就是codec的另外一种方式，如果已经有个encoder和decoder，不需要重新写了codec，直接使用CombinedChannelDuplexHandler整合这个encoder和decoder即可。</p>
<p>上面的ToIntegerDecoder和IntegerToByteEncoder就可以构成一个编解码器，直接使用CombinedChannelDuplexHandler即可。</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">CombinedByteIntegerCodec</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">CombinedChannelDuplexHandler&lt;ToIntegerDecoder</span>, <span class="title">IntegerToByteEncoder&gt;</span> {</span>
    public <span class="type">CombinedByteIntegerCodec</span>() {
        <span class="keyword">super</span>(<span class="keyword">new</span> <span class="type">ToIntegerDecoder</span>(), <span class="keyword">new</span> <span class="type">IntegerToByteEncoder</span>());
    }
}
</code></pre><h2 id="第八章">第八章</h2><p>主要说明jetty内置的一些ChannelHandler和Codec。</p>
<p>使用SSL/TLS加密Netty程序的话，可以使用内置的SslHandler。</p>
<p>要构建Http应用的话，可以使用HttpClientCodec/HttpServerCodec(http客户端和服务端的编解码)以及HttpObjectAggregator(Http的消息聚合)。</p>
<p>可以使用HttpContentDecompressor和HttpContentCompressor对http的内容进行解压和压缩。</p>
<p>还有一些WebSocket、SPDY，一些空置链接、超时链接等处理的内置解决方案。</p>
<h2 id="第九章">第九章</h2><p>主要讲解Bootstrap中Netty中的作用。</p>
<p>之前分析过各种ChannelHandler，各种Codec，以及把这两个东西添加到Channel 的ChannelPipeline中。有了这些东西之后，该用什么把他们整合起来呢，那就是Bootstrap。</p>
<p>Bootstrap分别ServerBootstrap(服务端)和Bootstrap(客户端)，它们都继承AbstractBootstrap。</p>
<h3 id="Bootstrap">Bootstrap</h3><p>客户端服务启动类，内部提供的一些方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>group(..)</td>
<td>设置Bootstrap使用的EventLoopGroup，用来处理Channel的IO操作</td>
</tr>
<tr>
<td>channel(..)</td>
<td>Channel的类型，比如有NioSocketChannel, OioSocketChannel等</td>
</tr>
<tr>
<td>channelFactory(..)</td>
<td>如果Channel没有没有参数的构造函数，需要使用ChannelFactory构造Channel</td>
</tr>
<tr>
<td>localAddress(..)</td>
<td>Channel需要绑定的地址和端口，可以不调用，使用connect或者bind再进行设置</td>
</tr>
<tr>
<td>option(..)</td>
<td>一些可选的设置，使用ChannelOptions完成。比如keep-alive时间，超时时间</td>
</tr>
<tr>
<td>handler(..)</td>
<td>设置ChannelHandler处理事件</td>
</tr>
<tr>
<td>clone(..)</td>
<td>复制一个新的Bootstrap，AbstractBootstrap实现了Cloneable接口</td>
</tr>
<tr>
<td>remoteAddress()..)</td>
<td>设置远程地址，也可以在调用connect方法的时候设置</td>
</tr>
<tr>
<td>connect()..)</td>
<td>链接到远程地址</td>
</tr>
<tr>
<td>bind()..)</td>
<td>绑定本地端口</td>
</tr>
</tbody>
</table>
<p>需要注意的是如果EventLoopGroup选择的是NioEventLoopGroup，那么对应的channel需要选择NioSocketChannel，否则会抛出兼容性的错误异常。</p>
<h3 id="ServerBootstrap">ServerBootstrap</h3><p>服务端服务启动类，内部提供的一些方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>group(..)</td>
<td>设置ServerBootstrap使用的EventLoopGroup，用来处理ServerChannel的IO操作并接收Channel</td>
</tr>
<tr>
<td>channel(..)</td>
<td>ServerChannel的类型，比如有NioServerSocketChannel, OioServerSocketChannel等</td>
</tr>
<tr>
<td>channelFactory(..)</td>
<td>如果ServerChannel没有没有参数的构造函数，需要使用ChannelFactory构造ServerChannel</td>
</tr>
<tr>
<td>localAddress(..)</td>
<td>ServerChannel需要绑定的地址和端口，可以不调用，使用connect或者bind再进行设置</td>
</tr>
<tr>
<td>option(..)</td>
<td>一些ServerChannel可选的设置，使用ChannelOptions完成。比如keep-alive时间，超时时间</td>
</tr>
<tr>
<td>childOption(..)</td>
<td>被ServerChannel接收的Channel的可选的设置，使用ChannelOptions完成</td>
</tr>
<tr>
<td>handler(..)</td>
<td>设置ServerChannel的ChannelHandler处理事件</td>
</tr>
<tr>
<td>childHandler(..)</td>
<td>设置被ServerChannel接收的Channel的ChannelHandler处理事件</td>
</tr>
<tr>
<td>clone(..)</td>
<td>复制一个新的ServerBootstrap，AbstractBootstrap实现了Cloneable接口</td>
</tr>
<tr>
<td>bind()..)</td>
<td>绑定本地端口</td>
</tr>
</tbody>
</table>
<p>ServerBootstrap的处理过程：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty08.png" alt=""></p>
<p>ServerBootstrap调用bind绑定地址和端口的时候，会创建ServerChannel。这个ServerChannel会接收客户的各个链接，针对各个链接创建Channel。</p>
<p>handler方法就是为ServerChannel服务的，而childHandler是给被ServerChannel接收的Channel服务器的。所以说只要服务器已起来，handler中的ChannelHandler就会触发，而有链接被ServerChannel接收之后childHandler中的ChannelHandler才会触发。</p>
<h3 id="从一个已经存在的Channel中使用Bootstrap启动客户端">从一个已经存在的Channel中使用Bootstrap启动客户端</h3><p>在ServerBootstrap接收到新的Channel的时候准备启动Bootstrap客户端的时候，可以使用一个全新的EventLoop用于处理Channel的IO模型。</p>
<p>但是没有必要，可以跟ServerBootstrap共享同一个EventLoop，因为一个EventLoop是跟一个线程绑定的，如果使用了多个EventLoop的话，那就相当于需要进行线程的上下文切换，需要消耗一定的资源。</p>
<p>1个在ServerBootstrap接收到链接之后，使用Bootstrap链接另外一个地址的处理过程：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty09.png" alt=""></p>
<p>其中第3点就是ServerChannel接收到的新的Channel，第5点是Bootstrap创建的连接到远程服务器的Channel，它们使用同一个EventLoop。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>主要记录ChannelHandler、Codec以及Bootstrap的作用，还有Netty内置的一些ChannelHandler、Codec，以及Bootstrap的分类。</p>]]>
    
    </summary>
    
      <category term="netty" scheme="http://fangjian0423.github.io/tags/netty/"/>
    
      <category term="nio" scheme="http://fangjian0423.github.io/tags/nio/"/>
    
      <category term="netty" scheme="http://fangjian0423.github.io/categories/netty/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Netty in Action笔记(一)]]></title>
    <link href="http://fangjian0423.github.io/2016/08/19/netty-in-action-note1/"/>
    <id>http://fangjian0423.github.io/2016/08/19/netty-in-action-note1/</id>
    <published>2016-08-18T17:36:52.000Z</published>
    <updated>2016-08-18T17:41:37.000Z</updated>
    <content type="html"><![CDATA[<p>一篇读书笔记，根据章节进行下总结。已经看了5章，先对这5个章节做个小总结。</p>
<a id="more"></a>
<h2 id="第一章">第一章</h2><p>然后介绍了一下Netty出来的背景以及Netty所拥有的一些强大的特性，比如Netty的设计高可用，可扩展，性能高，使用NIO这种非阻塞式的IO模型等特点。</p>
<p>然后介绍了一下异步编程的设计，有两种方式：</p>
<ol>
<li>基于Callback</li>
<li>基于Future</li>
</ol>
<p>基于Callback的跟javascript相似，这种方式比较大的问题就是当callback多的时候，代码就变得难以阅读。</p>
<p>基于Future的方式就是jdk里的concurrent包里的Future接口一样，代表着未来的一个值。</p>
<p>Netty内部这2种异步编程方式都有使用。</p>
<p>之后对IO阻塞模型和NIO非阻塞模型进行了一番比较。</p>
<p>其中IO阻塞模型对于每一个Socket都会创建一个线程进行处理，虽然可以使用线程池解决线程过多的问题，但是底层还是使用线程处理每一个请求，系统的瓶颈在于线程的个数，并且线程多了会导致频繁的线程切换，导致CPU利用效率不高。</p>
<p>NIO非阻塞模型采用Reactor模式，一个Reactor线程内部使用一个多路复用器selector，这个selector可以同时注册、监听和轮询成百上千个Channel，一个IO线程可以同时并发处理多个客户端连接，就不会存在频繁的IO线程之间的切换，CPU利用率高。</p>
<p>之后使用JDK的NIO Api编写了一个demo，发现JDK的NIO Api比较难用，比如在ByteBuffer中进行读操作后又要进行写操作，需要调用flip进行切换，api很难用，而netty很好地解决了这个问题，这也是netty的一个优点。</p>
<h2 id="第二章">第二章</h2><p>第二章主要就是使用netty的api编写了一个server端和client端，让读者先简单熟悉一下netty中的一些api的使用。</p>
<h2 id="第三章">第三章</h2><p>第三章主要对netty中的一些主要的组件做一个简单的介绍。</p>
<p>Channel: 一个Channel表示一个通道，跟io中的stream的角色一样，但是有几点不同。 1. stream是单向的，只支持读或者写，channel是双向的，既支持读也支持写。2. stream是阻塞的，channel是并行的。</p>
<p>EventLoop: 当一个channel注册之后，会将这个channel绑定到EventLoop里来处理channel的IO操作，一个EventLoop对应一个线程。</p>
<p>EventLoopGroup: 多个EventLoop的集合</p>
<p>Bootstrap: 用于配置客户端netty程序，比如连接的host和port，EventLoop等</p>
<p>ServerBootstrap: 用于配置服务端netty程序，比如绑定的port，EventLoop等</p>
<p>ChannelHandler: 主要用于处理关于Channel的业务逻辑。比如转换数据格式、当channel状态改变的时候被通知到，当channel注册到EventLoop的时候被通知到以及通知一些用户执行的特殊事件等。ChannelHandler有很多很多的实现类</p>
<p>ChannelPipeline: 把很多ChannelHandler整合在一起并进行处理</p>
<p>Future or ChannelFuture: 由于所有的netty都是异步操作。异步操作的结果就是ChannelFuture</p>
<p>ChannelInBoundHandler和ChannelOutBoundHandler是ChannelHandler的两种很常见的实现类，他们分别用于读取socket中的数据和写数据到socket中，他们存储在ChannelPipeline中用于处理socket，有一张很经典关于ChannelInboundHandler和ChannelOutboundHandler的图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty01.png" alt="image"></p>
<p>最后讲解了关于java对象的编码和解码，因为使用netty开发的时候需要传输字节数据，而这些字节数据可以跟java对象之间进行互相转换使编程更加方便。</p>
<h2 id="第四章">第四章</h2><p>第四章主要讲解了netty中的4种transport，分别是OIO、NIO、Local和Embedded。</p>
<p>其中OIO这种transport在netty中的io.netty.channel.socket.oio包里，底层使用jdk的java.net包里的类，io模型为阻塞io模型</p>
<p>NIO在netty中的io.netty.channel.socket.nio包里，底层使用jdk的java.nio.channels包里的类，netty提供了2种nio的实现，分别是基于selector和基于epoll的实现。</p>
<p>Local在io.netty.channel.local包里，这是一种在同一个JVM中客户端与服务器进行通信的一种transport。</p>
<p>Embedded在io.netty.channel.embedded包里，主要用于测试，可以在不需要网络的情况下进行ChannelHandler的单元测试。</p>
<p>这4种transport的使用场景如下：</p>
<p>OIO: 低连接数，低延迟，需要阻塞时使用<br>NIO: 搞链接数<br>Local: 同一个JVM中进行通信时使用<br>Embedded: ChannelHandler单元测试时使用</p>
<h2 id="第五章">第五章</h2><p>第五章主要讲解netty中的ByteBuf的使用。</p>
<p>Jdk的NIO中的ByteBuffer使用成本过多，netty发现了这一缺点并进行了改造，设计出了ByteBuf这个类来代替ByteBuffer，相比ByteBuffer，ByteBuf有如下几个特点：</p>
<ol>
<li>可以定义自己的buffer类型，比如heap buffer, direct buffer等</li>
<li>可以使用内置的composite buffer类型完成零拷贝</li>
<li>buffer容量可以扩展</li>
<li>不需要调用flip来切换读写模式</li>
<li>区分readerIndex和writerIndex</li>
<li>方法链式调用</li>
<li>使用引用计数</li>
<li>可以使用pool来创建buffer</li>
</ol>
<p>ByteBuf工作原理：内部有2个索引，分别是readerIndex和writerIndex，初始化时，这2个值都是0，当写入数据到buffer中，writerIndex会增加；当读取数据时，readerIndex会增加。当readerIndex = writerIndex的时候，再进行读取将会抛出IndexOutOfBoundsException异常。</p>
<p>ByteBuf是有容量概念的，默认情况下的最大的容量是Integer.MAX_VALUE。当writerIndex超过这个容量大小时，将会抛出异常。</p>
<p>下图就是一个ByteBuf的结构：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty02.png" alt="image"></p>
<p>ByteBuf共有3种类型：</p>
<ol>
<li>heap buffer: 存储在JVM的堆中，内部使用一个字节数组存储字节。可以使用ByteBuf的hasArray方法判断是否是heap buffer</li>
<li>direct buffer：在堆外直接内存中分配，效率高，相比于堆内分配的buffer，在堆外直接内存中分配的buffer少了一次缓冲区的内存拷贝(实际上，当使用一个非直接内存buffer的时候，在发送buffer数据出去之前jvm内部会拷贝这个buffer到堆外直接内存中)</li>
<li>composite buffer：组合型的buffer，比如一个ByteBuf由2个ByteBuf构成，可以使用Composite Buffer完成，可以避免创建一个新的ByteBuf来整合这2个ByteBuf导致的内存拷贝</li>
</ol>
<p>以上2、3点再加上netty文件传输采用的transferTo方法(可以直接将文件缓存区的数据发送到目标Channel，不需要通过循环write方式导致的内存拷贝问题)构成了Netty的零拷贝。</p>
<p>接下来就是ByteBuf的一些常用方法介绍，比如copy, slice, duplicate, readInt, writeInt, indexOf, clear, discardReadBytes方法等等。</p>
<p>一些参考资料：</p>
<p><a href="http://www.open-open.com/news/view/1d31d83" target="_blank" rel="external">http://www.open-open.com/news/view/1d31d83</a></p>
<p><a href="http://www.infoq.com/cn/articles/netty-high-performance" target="_blank" rel="external">http://www.infoq.com/cn/articles/netty-high-performance</a></p>
<p><a href="http://www.infoq.com/cn/author/%E6%9D%8E%E6%9E%97%E9%94%8B#%E6%96%87%E7%AB%A0" target="_blank" rel="external">http://www.infoq.com/cn/author/%E6%9D%8E%E6%9E%97%E9%94%8B#%E6%96%87%E7%AB%A0</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一篇读书笔记，根据章节进行下总结。已经看了5章，先对这5个章节做个小总结。</p>]]>
    
    </summary>
    
      <category term="netty" scheme="http://fangjian0423.github.io/tags/netty/"/>
    
      <category term="nio" scheme="http://fangjian0423.github.io/tags/nio/"/>
    
      <category term="netty" scheme="http://fangjian0423.github.io/categories/netty/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SpringBoot的actuator模块]]></title>
    <link href="http://fangjian0423.github.io/2016/06/25/springboot-actuator/"/>
    <id>http://fangjian0423.github.io/2016/06/25/springboot-actuator/</id>
    <published>2016-06-25T06:52:52.000Z</published>
    <updated>2016-06-25T07:38:28.000Z</updated>
    <content type="html"><![CDATA[<p>springboot内部提供了一个模块spring-boot-actuator用于监控和管理springboot应用。</p>
<p>这个模块内部提供了很多功能，endpoint就是其中一块功能。</p>
<p>我们在sbt中加入这个模块的依赖：</p>
<pre><code><span class="title">libraryDependencies</span> += <span class="string">"org.springframework.boot"</span> % <span class="string">"spring-boot-starter-actuator"</span> % <span class="string">"1.3.5.RELEASE"</span>
</code></pre><p>然后启动项目，访问地址 <a href="http://localhost:8080/health，看到以下页面：" target="_blank" rel="external">http://localhost:8080/health，看到以下页面：</a></p>
<pre><code><span class="rules">{
    <span class="rule"><span class="attribute">status</span>:<span class="value"> <span class="string">"UP"</span>,
    diskSpace: {
        status: <span class="string">"UP"</span>,
        total: <span class="number">249779191808</span>,
        free: <span class="number">22231089152</span>,
        threshold: <span class="number">10485760</span>
    </span></span></span>},
    <span class="tag">db</span>: <span class="rules">{
        <span class="rule"><span class="attribute">status</span>:<span class="value"> <span class="string">"UP"</span>,
        database: <span class="string">"H2"</span>,
        hello: <span class="number">1</span>
    </span></span></span>}
}
</code></pre><a id="more"></a>
<p>这个/health endpoint显示了目前应用的一些健康情况。</p>
<h2 id="Endpoint">Endpoint</h2><p>spring-boot-autoconfigure模块中还提供了其他很多endpoint，比如 /beans(查看spring工厂信息，里面存在哪些bean)、/dump(应用中的所有线程状态)、/env(应用环境信息，比如jvm环境信息、配置文件内容、应用端口等信息)、/mappings(SpringMVC的RequestMapping映射信息)、/configprops(框架配置信息，比如数据源、freemarker、spring的配置信息)、/metrics(度量信息)等等。</p>
<p>具体其他的endpoint可以查看springboot官方文档上的信息： <a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready-endpoints" target="_blank" rel="external">http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready-endpoints</a></p>
<p>这些endpoint是如何暴露出来的呢，是通过SpringBoot内部的一个Endpoint接口完成的。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Endpoint</span>&lt;<span class="title">T</span>&gt; </span>{
    <span class="function">String <span class="title">getId</span><span class="params">()</span></span>; <span class="comment">// endpoint的唯一标识</span>
    <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>; <span class="comment">// 是否可用</span>
    <span class="function"><span class="keyword">boolean</span> <span class="title">isSensitive</span><span class="params">()</span></span>; <span class="comment">// 是否对一般用户可见</span>
    <span class="function">T <span class="title">invoke</span><span class="params">()</span></span>; <span class="comment">// 具体的执行过程，返回值会被解析成json暴露出口</span>
}
</code></pre><p>这个接口的实现类有DumpEndpoint、BeansEndpoint、InfoEndpoint、HealthEndpoint、RequestMappingEndpoint等等。这些EndPoint实现类就是对应对外暴露的endpoint。BeansEndpoint的代码如下：</p>
<pre><code><span class="annotation">@ConfigurationProperties</span>(prefix = <span class="string">"endpoints.beans"</span>) <span class="comment">// 配置以endpoints.beans开头，可以覆盖</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeansEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span>&lt;<span class="title">List</span>&lt;<span class="title">Object</span>&gt;&gt;
        <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>{

    <span class="keyword">private</span> <span class="keyword">final</span> LiveBeansView liveBeansView = <span class="keyword">new</span> LiveBeansView();

    <span class="keyword">private</span> <span class="keyword">final</span> JsonParser parser = JsonParserFactory.getJsonParser();

    <span class="function"><span class="keyword">public</span> <span class="title">BeansEndpoint</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>(<span class="string">"beans"</span>); <span class="comment">// id为beans</span>
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext context)</span> <span class="keyword">throws</span> BeansException </span>{
        <span class="keyword">if</span> (context.getEnvironment()
                .getProperty(LiveBeansView.MBEAN_DOMAIN_PROPERTY_NAME) == <span class="keyword">null</span>) {
            <span class="keyword">this</span>.liveBeansView.setApplicationContext(context);
        }
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">invoke</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">this</span>.parser.parseList(<span class="keyword">this</span>.liveBeansView.getSnapshotAsJson()); <span class="comment">// 返回值就是最后展示的json数组</span>
    }
}
</code></pre><p>可以使用配置覆盖默认的beans endpoint中的信息：</p>
<pre><code>endpoints.beans.enabled= <span class="comment"># Enable the endpoint.</span>
endpoints.beans.<span class="property">id</span>= <span class="comment"># Endpoint identifier.</span>
endpoints.beans.path= <span class="comment"># Endpoint path.</span>
endpoints.beans.sensitive= <span class="comment"># Mark if the endpoint exposes sensitive information.</span>
</code></pre><h2 id="Health_Indicator">Health Indicator</h2><p>HealthEndpoint这个endpoint是暴露通过扫描出的HealthIndicator接口的实现类完成的。</p>
<p>用于查看应用的健康状况。</p>
<p>在我们的应用中只使用了h2数据库，最终/health显示出来的内容如下(只有硬盘容量和数据库健康状况)：</p>
<pre><code><span class="rules">{
    <span class="rule"><span class="attribute">status</span>:<span class="value"> <span class="string">"UP"</span>,
    diskSpace: {
        status: <span class="string">"UP"</span>,
        total: <span class="number">249779191808</span>,
        free: <span class="number">20595720192</span>,
        threshold: <span class="number">10485760</span>
    </span></span></span>},
    <span class="tag">db</span>: <span class="rules">{
        <span class="rule"><span class="attribute">status</span>:<span class="value"> <span class="string">"UP"</span>,
        database: <span class="string">"H2"</span>,
        hello: <span class="number">1</span>
    </span></span></span>}
}
</code></pre><p>springboot内置的HealthIndicator有这些：SolrHealthIndicator、RedisHealthIndicator、RabbitHealthIndicator、MongoHealthIndicator、ElasticsearchHealthIndicator、CassandraHealthIndicator、DiskSpaceHealthIndicator、DataSourceHealthIndicator等。</p>
<p>这些都是springboot内置的，我们也可以编写自定义的health indicator。</p>
<p>以服务器中某个目录中的文件个数不能超过某个值为健康指标作为需求进行编写health indicator。</p>
<p>编写HealthIndicator：</p>
<pre><code><span class="annotation">@Component</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TempDirHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span> </span>{

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function">Health <span class="title">health</span><span class="params">()</span> </span>{
        Health.Builder builder = <span class="keyword">new</span> Health.Builder();
        File file = <span class="keyword">new</span> File(<span class="string">"youdirpath"</span>);
        File[] fileList = file.listFiles();
        <span class="keyword">if</span>(fileList.length &gt; <span class="number">10</span>) {
            builder.down().withDetail(<span class="string">"file num"</span>,fileList.length);
        } <span class="keyword">else</span> {
            builder.up();
        }
        <span class="function"><span class="keyword">return</span> builder.<span class="title">build</span><span class="params">()</span></span>;
    }

}
</code></pre><p>访问 <a href="http://localhost:8080/health" target="_blank" rel="external">http://localhost:8080/health</a></p>
<pre><code><span class="rules">{
    <span class="rule"><span class="attribute">status</span>:<span class="value"> <span class="string">"DOWN"</span>,
    tempDir: {
        status: <span class="string">"DOWN"</span>,
        file num: <span class="number">34</span>
    </span></span></span>},
    <span class="tag">diskSpace</span>: <span class="rules">{
        <span class="rule"><span class="attribute">status</span>:<span class="value"> <span class="string">"UP"</span>,
        total: <span class="number">249779191808</span>,
        free: <span class="number">20690649088</span>,
        threshold: <span class="number">10485760</span>
    </span></span></span>},
    <span class="tag">db</span>: <span class="rules">{
        <span class="rule"><span class="attribute">status</span>:<span class="value"> <span class="string">"UP"</span>,
        database: <span class="string">"H2"</span>,
        hello: <span class="number">1</span>
    </span></span></span>}
}
</code></pre><h2 id="Metrics">Metrics</h2><p>Metrics服务用来做一些度量支持，springboot提供了两种Metrics，分别是gauge(单一的值)和counter(计数器，自增或自减)。springboot提供了PublicMetrics接口用来支持Metrics服务。</p>
<p>metrics这个endpoint中使用的metrics都是由SystemPublicMetrics完成的：</p>
<pre><code>{
    mem: <span class="number">388503</span>,
    mem.<span class="built_in">free</span>: <span class="number">199992</span>,
    processors: <span class="number">4</span>,
    instance.uptime: <span class="number">58260089</span>,
    uptime: <span class="number">21843805</span>,
    systemload.average: <span class="number">3.28369140625</span>,
    heap.committed: <span class="number">320000</span>,
    heap.init: <span class="number">131072</span>,
    heap.used: <span class="number">120007</span>,
    heap: <span class="number">1864192</span>,
    nonheap.committed: <span class="number">69528</span>,
    nonheap.init: <span class="number">2496</span>,
    nonheap.used: <span class="number">68501</span>,
    nonheap: <span class="number">0</span>,
    threads.peak: <span class="number">15</span>,
    threads.daemon: <span class="number">13</span>,
    threads.totalStarted: <span class="number">20</span>,
    threads: <span class="number">15</span>,
    classes: <span class="number">9483</span>,
    classes.loaded: <span class="number">9484</span>,
    classes.unloaded: <span class="number">1</span>,
    gc.ps_scavenge.count: <span class="number">9</span>,
    gc.ps_scavenge.time: <span class="number">152</span>,
    gc.ps_marksweep.count: <span class="number">2</span>,
    gc.ps_marksweep.time: <span class="number">167</span>,
    httpsessions.max: -<span class="number">1</span>,
    httpsessions.active: <span class="number">0</span>,
    datasource.primary.active: <span class="number">0</span>,
    datasource.primary.usage: <span class="number">0</span>,
    gauge.response.health: <span class="number">218</span>,
    gauge.response.star-star.favicon.ico: <span class="number">29</span>,
    counter.status<span class="number">.200</span>.star-star.favicon.ico: <span class="number">1</span>,
    counter.status<span class="number">.503</span>.health: <span class="number">1</span>
}
</code></pre><p>gauge和counter度量通过GaugeService和CounterService完成。</p>
<p>比如我们要查看各个Controller中的接口被调用的次数话，可以使用CounterService和aop完成：</p>
<pre><code><span class="variable">@Aspect</span>
<span class="variable">@Component</span>
<span class="class"><span class="keyword">class</span> <span class="title">ControllerAspect</span> @<span class="title">Autowired</span>() (</span>
  <span class="symbol">counterService:</span> <span class="constant">CounterService</span>
) {

  <span class="variable">@Before</span>(<span class="string">"execution(* me.format.controller.*.*(..))"</span>)
  <span class="function"><span class="keyword">def</span> <span class="title">controllerCounter</span><span class="params">(<span class="symbol">joinPoint:</span> <span class="constant">JoinPoint</span>)</span>: <span class="title">Unit</span> = {</span>
    counterService.increment(joinPoint.getSignature.toString + <span class="string">"-invokeNum"</span>)
  }

}
</code></pre><p>启动应用，调用getPersons接口4次，调用get/{long} 2次，查看metrics endpoint，得到以下信息：</p>
<pre><code>counter<span class="class">.List</span> me<span class="class">.format</span><span class="class">.controller</span><span class="class">.PersonController</span><span class="class">.get</span>(HttpServletRequest)-invokeNum: <span class="number">4</span>,
counter<span class="class">.Person</span> me<span class="class">.format</span><span class="class">.controller</span><span class="class">.PersonController</span><span class="class">.get</span>(long)-invokeNum: <span class="number">2</span>,
</code></pre><p>比如我们要查看各个Controller中的接口的延迟情况，可以使用GaugeService和aop完成：</p>
<pre><code>@<span class="type">Aspect</span>
@<span class="type">Component</span>
class <span class="type">ControllerAspect</span> @<span class="type">Autowired</span>() (
  counterService: <span class="type">CounterService</span>,
  gaugeService: <span class="type">GaugeService</span>
) {

  @<span class="type">Before</span>(<span class="string">"execution(* me.format.controller.*.*(..))"</span>)
  def controllerCounter(joinPoint: <span class="type">JoinPoint</span>): <span class="type">Unit</span> = {
    counterService.increment(joinPoint.getSignature.toString + <span class="string">"-invokeNum"</span>)
  }

  @<span class="type">Around</span>(<span class="string">"execution(* me.format.controller.*.*(..))"</span>)
  def controllerGauge(proceedingJoinPoint: <span class="type">ProceedingJoinPoint</span>): <span class="type">AnyRef</span> = {
    val st = <span class="type">System</span>.currentTimeMillis()
    val <span class="literal">result</span> = proceedingJoinPoint.proceed()
    val et = <span class="type">System</span>.currentTimeMillis()
    gaugeService.submit(proceedingJoinPoint.getSignature.toString + <span class="string">"-invokeTime"</span>, (et - st))
    <span class="literal">result</span>
  }

}
</code></pre><p>启动应用，调用getPersons接口4次，调用get/{long} 2次，查看metrics endpoint，得到以下信息：</p>
<pre><code>gauge<span class="class">.List</span> me<span class="class">.format</span><span class="class">.controller</span><span class="class">.PersonController</span><span class="class">.get</span>(HttpServletRequest)-invokeTime: <span class="number">4</span>,
gauge<span class="class">.Person</span> me<span class="class">.format</span><span class="class">.controller</span><span class="class">.PersonController</span><span class="class">.get</span>(long)-invokeTime: <span class="number">11</span>,
counter<span class="class">.List</span> me<span class="class">.format</span><span class="class">.controller</span><span class="class">.PersonController</span><span class="class">.get</span>(HttpServletRequest)-invokeNum: <span class="number">4</span>,
counter<span class="class">.Person</span> me<span class="class">.format</span><span class="class">.controller</span><span class="class">.PersonController</span><span class="class">.get</span>(long)-invokeNum: <span class="number">2</span>,
</code></pre><p>当然，actuator模块提供的功能远不止这些，更多的信息可以查看官方文档。</p>
<p><a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready" target="_blank" rel="external">http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>springboot内部提供了一个模块spring-boot-actuator用于监控和管理springboot应用。</p>
<p>这个模块内部提供了很多功能，endpoint就是其中一块功能。</p>
<p>我们在sbt中加入这个模块的依赖：</p>
<pre><code><span class="title">libraryDependencies</span> += <span class="string">"org.springframework.boot"</span> % <span class="string">"spring-boot-starter-actuator"</span> % <span class="string">"1.3.5.RELEASE"</span>
</code></pre><p>然后启动项目，访问地址 <a href="http://localhost:8080/health，看到以下页面：">http://localhost:8080/health，看到以下页面：</a></p>
<pre><code><span class="rules">{
    <span class="rule"><span class="attribute">status</span>:<span class="value"> <span class="string">"UP"</span>,
    diskSpace: {
        status: <span class="string">"UP"</span>,
        total: <span class="number">249779191808</span>,
        free: <span class="number">22231089152</span>,
        threshold: <span class="number">10485760</span>
    </span></span></span>},
    <span class="tag">db</span>: <span class="rules">{
        <span class="rule"><span class="attribute">status</span>:<span class="value"> <span class="string">"UP"</span>,
        database: <span class="string">"H2"</span>,
        hello: <span class="number">1</span>
    </span></span></span>}
}
</code></pre>]]>
    
    </summary>
    
      <category term="scala" scheme="http://fangjian0423.github.io/tags/scala/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SpringBoot with Scala]]></title>
    <link href="http://fangjian0423.github.io/2016/06/22/springboot-with-scala/"/>
    <id>http://fangjian0423.github.io/2016/06/22/springboot-with-scala/</id>
    <published>2016-06-22T15:22:39.000Z</published>
    <updated>2016-06-23T06:06:31.000Z</updated>
    <content type="html"><![CDATA[<p>一般情况下，我们使用java开发springboot应用，可以使用scala开发springboot应用吗？</p>
<p>答案当然是可以的。</p>
<p>今天参考了阿福老师的这篇<a href="http://afoo.me/posts/2015-07-21-scala-developers-springboot-guide.html" target="_blank" rel="external">Scala开发者的SpringBoot快速入门指南</a>以及一位国际友人的一个<a href="https://github.com/bijukunjummen/spring-boot-scala-web" target="_blank" rel="external">spring-boot-scala-web</a> demo。</p>
<p>自己尝试地搭建了一下环境，发现用scala编写springboot应用这种体验也是非常赞的。</p>
<p>下面是具体的环境搭建流程：</p>
<a id="more"></a>
<p>1.使用sbt作为构建工具，由于springboot官方只有基于maven或者gradle的构建方法，所以我们只能自己写了。</p>
<p>参考了springboot的maven配置，比如要开发web应用，需要1个spring-boot-starter-web模块，这个spring-boot-starter-web模块内地又引用了spring-boot-starter模块，spring-boot-starter模块是一个基础的starter模块，内部的依赖如下：</p>
<pre><code><span class="tag">&lt;<span class="title">dependencies</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">exclusions</span>&gt;</span>
            <span class="tag">&lt;<span class="title">exclusion</span>&gt;</span>
                <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
                <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">exclusion</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">exclusions</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.yaml<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>snakeyaml<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span>
</code></pre><p>其中springb-boot模块内部使用了spring的依赖，spring-boot-autoconfigure模块内部有很多自动化配置的类，spring-boot-starter-web模块内部使用了spring的web模块，一些tomcat模块等。</p>
<p>我们将这3个模块加入到sbt中：</p>
<pre><code><span class="title">libraryDependencies</span> += <span class="string">"org.springframework.boot"</span> % <span class="string">"spring-boot"</span> % <span class="string">"1.3.5.RELEASE"</span>
libraryDependencies += <span class="string">"org.springframework.boot"</span> % <span class="string">"spring-boot-autoconfigure"</span> % <span class="string">"1.3.5.RELEASE"</span>
libraryDependencies += <span class="string">"org.springframework.boot"</span> % <span class="string">"spring-boot-starter-web"</span> % <span class="string">"1.3.5.RELEASE"</span>
</code></pre><p>再加入jpa的依赖：</p>
<pre><code><span class="title">libraryDependencies</span> += <span class="string">"org.springframework.boot"</span> % <span class="string">"spring-boot-starter-data-jpa"</span> % <span class="string">"1.3.5.RELEASE"</span>
libraryDependencies += <span class="string">"com.h2database"</span> % <span class="string">"h2"</span> % <span class="string">"1.4.192"</span>
</code></pre><p>2.编写domain，使用BeanProperty可以自动给field加入get，set方法。</p>
<pre><code><span class="annotation">@Entity</span>
<span class="class"><span class="keyword">class</span> <span class="title">Person</span>(</span>pName: <span class="type">String</span>, pAge: <span class="type">Int</span>) {

  <span class="annotation">@Id</span>
  <span class="annotation">@GeneratedValue</span>
  <span class="annotation">@BeanProperty</span>
  <span class="keyword">var</span> id: <span class="type">Long</span> = _

  <span class="annotation">@BeanProperty</span>
  <span class="keyword">var</span> name: <span class="type">String</span> = pName

  <span class="annotation">@BeanProperty</span>
  <span class="keyword">var</span> age: <span class="type">Int</span> = pAge

  <span class="function"><span class="keyword">def</span> <span class="title">this</span>(</span>) = <span class="keyword">this</span>(<span class="string">"unknown"</span>, -<span class="number">1</span>)

}

<span class="class"><span class="keyword">object</span> <span class="title">Person</span> {</span>
  <span class="function"><span class="keyword">def</span> <span class="title">apply</span>(</span>name: <span class="type">String</span>, age: <span class="type">Int</span>) = <span class="keyword">new</span> <span class="type">Person</span>(name, age)
}
</code></pre><p>3.编写Repository，由于scala中没有接口这个概念，我们使用trait代替。</p>
<pre><code><span class="annotation">@Repository</span>
<span class="class"><span class="keyword">trait</span> <span class="title">PersonRepository</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">CrudRepository</span>[</span><span class="type">Person</span>, <span class="type">Long</span>]
</code></pre><p>4.编写Controller。利用构造器依赖注入将PersonRepository注入到属性里。</p>
<pre><code><span class="variable">@RestController</span>
<span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> @<span class="title">Autowired</span>() (</span>
  private val <span class="symbol">personRepository:</span> <span class="constant">PersonRepository</span>
) {

  <span class="variable">@RequestMapping</span>(value = <span class="constant">Array</span>(<span class="string">"/index"</span>))
  <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>: <span class="title">String</span> = {</span>
    <span class="string">"hello springboot"</span>
  }

  <span class="variable">@RequestMapping</span>(value = <span class="constant">Array</span>(<span class="string">"/add"</span>))
  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(<span class="symbol">req:</span> <span class="constant">HttpServletRequest</span>)</span>: <span class="title">String</span> = {</span>
    val p = <span class="constant">Person</span>(req.getParameter(<span class="string">"name"</span>), <span class="constant">Some</span>(req.getParameter(<span class="string">"age"</span>).toInt).getOrElse(-<span class="number">1</span>))
    personRepository.save(p)
    <span class="string">"ok"</span>
  }

  <span class="variable">@RequestMapping</span>(value = <span class="constant">Array</span>(<span class="string">"/getAll"</span>))
  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(<span class="symbol">req:</span> <span class="constant">HttpServletRequest</span>)</span>: <span class="title">java</span>.<span class="title">util</span>.<span class="title">List</span>[<span class="title">Person</span>] = {</span>
    personRepository.findAll().toList
  }

  <span class="variable">@RequestMapping</span>(value = <span class="constant">Array</span>(<span class="string">"/get/{id}"</span>))
  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(<span class="variable">@PathVariable</span>()</span> <span class="title">id</span>: <span class="title">Long</span>): <span class="title">Person</span> = {</span>
    personRepository.findOne(id)
  }

}
</code></pre><p>5.使用CommandLineRunner做一些初始化工作。</p>
<pre><code><span class="variable">@SpringBootApplication</span>
<span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> {</span>

  <span class="variable">@Bean</span>
  <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(<span class="symbol">personRepository:</span> <span class="constant">PersonRepository</span>)</span>: <span class="title">CommandLineRunner</span> = {</span>
    <span class="keyword">return</span> new <span class="constant">CommandLineRunner</span> {
      override <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(<span class="symbol">strings:</span> <span class="constant">String</span>*)</span>: <span class="title">Unit</span> = {</span>
        personRepository.save(<span class="constant">Person</span>(<span class="string">"jim"</span>, <span class="number">1</span>))
        personRepository.save(<span class="constant">Person</span>(<span class="string">"tom"</span>, <span class="number">2</span>))
        personRepository.save(<span class="constant">Person</span>(<span class="string">"jerry"</span>, <span class="number">3</span>))
      }
    }
  }

}
</code></pre><p>6.配置文件application.properties中加入以下配置。</p>
<pre><code><span class="keyword">spring</span>.datasource.url=jdbc:h2:mem:AZ;DB_CLOSE_DELAY=-<span class="number">1</span>;DB_CLOSE_ON_EXIT=FALSE
<span class="keyword">spring</span>.datasource.driverClassName=org.h2.Driver
<span class="keyword">spring</span>.datasource.username=sa
<span class="keyword">spring</span>.datasource.password=
<span class="keyword">spring</span>.jpa.database-platform=org.hibernate.dialect.H2Dialect
</code></pre><p>7.写一个入口对象启动应用。</p>
<pre><code><span class="class"><span class="keyword">object</span> <span class="title">Application</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">App</span> {</span>
  <span class="type">SpringApplication</span>.run(classOf[<span class="type">MainClass</span>]);
}
</code></pre><p>测试：</p>
<pre><code>curl http:<span class="comment">//localhost:8080/index</span>

hello springboot

curl http:<span class="comment">//localhost:8080/getPersons</span>

[{<span class="string">"id"</span>:<span class="number">1</span>,<span class="string">"name"</span>:<span class="string">"jim"</span>,<span class="string">"age"</span>:<span class="number">1</span>},{<span class="string">"id"</span>:<span class="number">2</span>,<span class="string">"name"</span>:<span class="string">"tom"</span>,<span class="string">"age"</span>:<span class="number">2</span>},{<span class="string">"id"</span>:<span class="number">3</span>,<span class="string">"name"</span>:<span class="string">"jerry"</span>,<span class="string">"age"</span>:<span class="number">3</span>}]

curl http:<span class="comment">//localhost:8080/get/1</span>

{<span class="string">"id"</span>:<span class="number">1</span>,<span class="string">"name"</span>:<span class="string">"jim"</span>,<span class="string">"age"</span>:<span class="number">1</span>}

curl http:<span class="comment">//localhost:8080/add\?name\=format\&amp;age\=4</span>

ok

curl http:<span class="comment">//localhost:8080/getPersons</span>

[{<span class="string">"id"</span>:<span class="number">1</span>,<span class="string">"name"</span>:<span class="string">"jim"</span>,<span class="string">"age"</span>:<span class="number">1</span>},{<span class="string">"id"</span>:<span class="number">2</span>,<span class="string">"name"</span>:<span class="string">"tom"</span>,<span class="string">"age"</span>:<span class="number">2</span>},{<span class="string">"id"</span>:<span class="number">3</span>,<span class="string">"name"</span>:<span class="string">"jerry"</span>,<span class="string">"age"</span>:<span class="number">3</span>},{<span class="string">"id"</span>:<span class="number">4</span>,<span class="string">"name"</span>:<span class="string">"format"</span>,<span class="string">"age"</span>:<span class="number">4</span>}]
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>一般情况下，我们使用java开发springboot应用，可以使用scala开发springboot应用吗？</p>
<p>答案当然是可以的。</p>
<p>今天参考了阿福老师的这篇<a href="http://afoo.me/posts/2015-07-21-scala-developers-springboot-guide.html">Scala开发者的SpringBoot快速入门指南</a>以及一位国际友人的一个<a href="https://github.com/bijukunjummen/spring-boot-scala-web">spring-boot-scala-web</a> demo。</p>
<p>自己尝试地搭建了一下环境，发现用scala编写springboot应用这种体验也是非常赞的。</p>
<p>下面是具体的环境搭建流程：</p>]]>
    
    </summary>
    
      <category term="scala" scheme="http://fangjian0423.github.io/tags/scala/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SpringBoot内部的一些自动化配置原理]]></title>
    <link href="http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/"/>
    <id>http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/</id>
    <published>2016-06-12T11:30:57.000Z</published>
    <updated>2016-06-22T15:31:29.000Z</updated>
    <content type="html"><![CDATA[<p>springboot用来简化Spring框架带来的大量XML配置以及复杂的依赖管理，让开发人员可以更加关注业务逻辑的开发。</p>
<p>比如不使用springboot而使用SpringMVC作为web框架进行开发的时候，需要配置相关的SpringMVC配置以及对应的依赖，比较繁琐；而使用springboot的话只需要以下短短的几行代码就可以使用SpringMVC，可谓相当地方便：</p>
<pre><code><span class="annotation">@RestController</span>
<span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{
  <span class="annotation">@RequestMapping</span>(<span class="string">"/"</span>)
  <span class="built_in">String</span> home() {
    <span class="string">"hello"</span>
  }
}
</code></pre><p>其中maven配置如下：</p>
<pre><code><span class="tag">&lt;<span class="title">parent</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.3.5.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">parent</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependencies</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span>
</code></pre><a id="more"></a>
<p>我们以使用SpringMVC并且视图使用freemarker为例，分析springboot内部是如何解析freemarker视图的。</p>
<p>如果要在springboot中使用freemarker视图框架，并且使用maven构建项目的时候，还需要加入以下依赖：</p>
<pre><code><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.3.5.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</code></pre><p>这个spring-boot-starter-freemarker依赖对应的jar包里的文件如下：</p>
<pre><code>META-INF
├── MANIFEST<span class="class">.MF</span>
├── maven
│   └── org<span class="class">.springframework</span><span class="class">.boot</span>
│       └── spring-boot-starter-freemarker
│           ├── pom<span class="class">.properties</span>
│           └── pom<span class="class">.xml</span>
└── spring.provides
</code></pre><p>内部的pom.xml里需要的依赖如下：</p>
<pre><code><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.freemarker<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</code></pre><p>我们可以看到这个spring-boot-starter-freemarker依赖内部并没有freemarker的ViewResolver，而是仅仅加入了freemarker的依赖，还有3个依赖，分别是spring-boot-starter、spring-boot-starter-web和spring-context-support。</p>
<p>接下来我们来分析一下为什么在springboot中加入了freemarker的依赖spring-boot-starter-freemarker后，SpringMVC自动地构造了一个freemarker的ViewResolver？</p>
<p>在分析之前，首先我们先看下maven配置，看到了一个parent配置：</p>
<pre><code><span class="tag">&lt;<span class="title">parent</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.3.5.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">parent</span>&gt;</span>
</code></pre><p>这个spring-boot-starter-parent的pom文件在 <a href="http://central.maven.org/maven2/org/springframework/boot/spring-boot-starter-parent/1.3.5.RELEASE/spring-boot-starter-parent-1.3.5.RELEASE.pom" target="_blank" rel="external">http://central.maven.org/maven2/org/springframework/boot/spring-boot-starter-parent/1.3.5.RELEASE/spring-boot-starter-parent-1.3.5.RELEASE.pom</a> 里。</p>
<p>它内部也有一个parent：</p>
<pre><code><span class="tag">&lt;<span class="title">parent</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.3.5.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;<span class="title">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="title">relativePath</span>&gt;</span>
<span class="tag">&lt;/<span class="title">parent</span>&gt;</span>
</code></pre><p>这个spring-boot-dependencies的pom文件在<a href="http://central.maven.org/maven2/org/springframework/boot/spring-boot-dependencies/1.3.5.RELEASE/spring-boot-dependencies-1.3.5.RELEASE.pom，内部有很多依赖。" target="_blank" rel="external">http://central.maven.org/maven2/org/springframework/boot/spring-boot-dependencies/1.3.5.RELEASE/spring-boot-dependencies-1.3.5.RELEASE.pom，内部有很多依赖。</a></p>
<p>比如spring-boot-starter-web、spring-boot-starter-websocket、spring-boot-starter-data-solrspring-boot-starter-freemarker等等，基本上所有的依赖都在这个parent里。</p>
<p>我们的例子中使用了parent依赖里的两个依赖，分别是spring-boot-starter-web和spring-boot-starter-freemarker。</p>
<p>其中spring-boot-starter-web内部依赖了spring的两个spring web依赖：spring-web和spring-webmvc。</p>
<p>spring-boot-starter-web内部还依赖spring-boot-starter，这个spring-boot-starter依赖了spring核心依赖spring-core；还依赖了<strong>spring-boot</strong>和<strong>spring-boot-autoconfigure</strong>这两个。</p>
<p><strong>spring-boot</strong>定义了很多基础功能类，像运行程序的SpringApplication，Logging系统，一些tomcat或者jetty这些EmbeddedServlet容器，配置属性loader等等。</p>
<p>包括了这些包：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/springboot01.png" alt="image"></p>
<p><strong>spring-boot-autoconfigure</strong>定义了很多自动配置的类，比如jpa，solr，redis，elasticsearch、mongo、freemarker、velocity，thymeleaf等等自动配置的类。</p>
<p>以freemarker为例，看一下它的自动化配置类：</p>
<pre><code><span class="annotation">@Configuration</span> <span class="comment">// 使用Configuration注解，自动构造一些内部定义的bean</span>
<span class="annotation">@ConditionalOnClass</span>({ freemarker.template.<span class="type">Configuration</span>.<span class="keyword">class</span>,
        <span class="type">FreeMarkerConfigurationFactory</span>.<span class="keyword">class</span> }) <span class="comment">// 需要freemarker.template.Configuration和FreeMarkerConfigurationFactory这两个类存在在classpath中才会进行自动配置</span>
<span class="annotation">@AutoConfigureAfter</span>(<span class="type">WebMvcAutoConfiguration</span>.<span class="keyword">class</span>) <span class="comment">// 本次自动配置需要依赖WebMvcAutoConfiguration这个配置类配置之后触发。这个WebMvcAutoConfiguration内部会配置很多Wen基础性的东西，比如RequestMappingHandlerMapping、RequestMappingHandlerAdapter等</span>
<span class="annotation">@EnableConfigurationProperties</span>(<span class="type">FreeMarkerProperties</span>.<span class="keyword">class</span>) <span class="comment">// 使用FreeMarkerProperties类中的配置</span>
public <span class="class"><span class="keyword">class</span> <span class="title">FreeMarkerAutoConfiguration</span> {</span>

    <span class="keyword">private</span> static <span class="keyword">final</span> <span class="type">Log</span> logger = <span class="type">LogFactory</span>
            .getLog(<span class="type">FreeMarkerAutoConfiguration</span>.<span class="keyword">class</span>);

    <span class="annotation">@Autowired</span>
    <span class="keyword">private</span> <span class="type">ApplicationContext</span> applicationContext;

    <span class="annotation">@Autowired</span>
    <span class="keyword">private</span> <span class="type">FreeMarkerProperties</span> properties;

    <span class="annotation">@PostConstruct</span> <span class="comment">// 构造之后调用的方法，组要检查模板位置是否存在</span>
    public void checkTemplateLocationExists() {
        <span class="keyword">if</span> (<span class="keyword">this</span>.properties.isCheckTemplateLocation()) {
            <span class="type">TemplateLocation</span> templatePathLocation = <span class="literal">null</span>;
            <span class="type">List</span>&lt;<span class="type">TemplateLocation</span>&gt; locations = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;<span class="type">TemplateLocation</span>&gt;();
            <span class="keyword">for</span> (<span class="type">String</span> templateLoaderPath : <span class="keyword">this</span>.properties.getTemplateLoaderPath()) {
                <span class="type">TemplateLocation</span> location = <span class="keyword">new</span> <span class="type">TemplateLocation</span>(templateLoaderPath);
                locations.add(location);
                <span class="keyword">if</span> (location.exists(<span class="keyword">this</span>.applicationContext)) {
                    templatePathLocation = location;
                    <span class="keyword">break</span>;
                }
            }
            <span class="keyword">if</span> (templatePathLocation == <span class="literal">null</span>) {
                logger.warn(<span class="string">"Cannot find template location(s): "</span> + locations
                        + <span class="string">" (please add some templates, "</span>
                        + <span class="string">"check your FreeMarker configuration, or set "</span>
                        + <span class="string">"spring.freemarker.checkTemplateLocation=false)"</span>);
            }
        }
    }

    <span class="keyword">protected</span> static <span class="class"><span class="keyword">class</span> <span class="title">FreeMarkerConfiguration</span> {</span>

        <span class="annotation">@Autowired</span>
        <span class="keyword">protected</span> <span class="type">FreeMarkerProperties</span> properties;

        <span class="keyword">protected</span> void applyProperties(<span class="type">FreeMarkerConfigurationFactory</span> factory) {
            factory.setTemplateLoaderPaths(<span class="keyword">this</span>.properties.getTemplateLoaderPath());
            factory.setPreferFileSystemAccess(<span class="keyword">this</span>.properties.isPreferFileSystemAccess());
            factory.setDefaultEncoding(<span class="keyword">this</span>.properties.getCharsetName());
            <span class="type">Properties</span> settings = <span class="keyword">new</span> <span class="type">Properties</span>();
            settings.putAll(<span class="keyword">this</span>.properties.getSettings());
            factory.setFreemarkerSettings(settings);
        }

    }

    <span class="annotation">@Configuration</span>
    <span class="annotation">@ConditionalOnNotWebApplication</span> <span class="comment">// 非Web项目的自动配置</span>
    public static <span class="class"><span class="keyword">class</span> <span class="title">FreeMarkerNonWebConfiguration</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">FreeMarkerConfiguration</span> {</span>

        <span class="annotation">@Bean</span>
        <span class="annotation">@ConditionalOnMissingBean</span>
        public <span class="type">FreeMarkerConfigurationFactoryBean</span> freeMarkerConfiguration() {
            <span class="type">FreeMarkerConfigurationFactoryBean</span> freeMarkerFactoryBean = <span class="keyword">new</span> <span class="type">FreeMarkerConfigurationFactoryBean</span>();
            applyProperties(freeMarkerFactoryBean);
            <span class="keyword">return</span> freeMarkerFactoryBean;
        }

    }

    <span class="annotation">@Configuration</span> <span class="comment">// 自动配置的类</span>
    <span class="annotation">@ConditionalOnClass</span>(<span class="type">Servlet</span>.<span class="keyword">class</span>) <span class="comment">// 需要运行在Servlet容器下</span>
    <span class="annotation">@ConditionalOnWebApplication</span> <span class="comment">// 需要在Web项目下</span>
    public static <span class="class"><span class="keyword">class</span> <span class="title">FreeMarkerWebConfiguration</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">FreeMarkerConfiguration</span> {</span>

        <span class="annotation">@Bean</span>
        <span class="annotation">@ConditionalOnMissingBean</span>(<span class="type">FreeMarkerConfig</span>.<span class="keyword">class</span>)
        public <span class="type">FreeMarkerConfigurer</span> freeMarkerConfigurer() {
            <span class="type">FreeMarkerConfigurer</span> configurer = <span class="keyword">new</span> <span class="type">FreeMarkerConfigurer</span>();
            applyProperties(configurer);
            <span class="keyword">return</span> configurer;
        }

        <span class="annotation">@Bean</span>
        public freemarker.template.<span class="type">Configuration</span> freeMarkerConfiguration(
                <span class="type">FreeMarkerConfig</span> configurer) {
            <span class="keyword">return</span> configurer.getConfiguration();
        }

        <span class="annotation">@Bean</span>
        <span class="annotation">@ConditionalOnMissingBean</span>(name = <span class="string">"freeMarkerViewResolver"</span>) <span class="comment">// 没有配置freeMarkerViewResolver这个bean的话，会自动构造一个freeMarkerViewResolver</span>
        <span class="annotation">@ConditionalOnProperty</span>(name = <span class="string">"spring.freemarker.enabled"</span>, matchIfMissing = <span class="literal">true</span>) <span class="comment">// 配置文件中开关开启的话，才会构造</span>
        public <span class="type">FreeMarkerViewResolver</span> freeMarkerViewResolver() {
            <span class="comment">// 构造了freemarker的ViewSolver，这就是一开始我们分析的为什么没有设置ViewResolver，但是最后却还是存在的原因</span>
            <span class="type">FreeMarkerViewResolver</span> resolver = <span class="keyword">new</span> <span class="type">FreeMarkerViewResolver</span>();
            <span class="keyword">this</span>.properties.applyToViewResolver(resolver);
            <span class="keyword">return</span> resolver;
        }

    }
}
</code></pre><p>freemarker对应的配置类：</p>
<pre><code><span class="annotation">@ConfigurationProperties</span>(prefix = <span class="string">"spring.freemarker"</span>) <span class="comment">// 使用配置文件中以spring.freemarker开头的配置</span>
public <span class="class"><span class="keyword">class</span> <span class="title">FreeMarkerProperties</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractTemplateViewResolverProperties</span> {</span>
    public static <span class="keyword">final</span> <span class="type">String</span> <span class="type">DEFAULT_TEMPLATE_LOADER_PATH</span> = <span class="string">"classpath:/templates/"</span>; <span class="comment">// 默认路径</span>

    public static <span class="keyword">final</span> <span class="type">String</span> <span class="type">DEFAULT_PREFIX</span> = <span class="string">""</span>; <span class="comment">// 默认前缀</span>

    public static <span class="keyword">final</span> <span class="type">String</span> <span class="type">DEFAULT_SUFFIX</span> = <span class="string">".ftl"</span>; <span class="comment">// 默认后缀</span>

    ...

}
</code></pre><p>下面是官网上的freemarker配置：</p>
<pre><code># FREEMARKER (FreeMarkerAutoConfiguration)
spring.freemarker.allow-request-override=false # <span class="operator"><span class="keyword">Set</span> whether HttpServletRequest <span class="keyword">attributes</span> <span class="keyword">are</span> allowed <span class="keyword">to</span> override (hide) controller <span class="keyword">generated</span> <span class="keyword">model</span> <span class="keyword">attributes</span> <span class="keyword">of</span> the same <span class="keyword">name</span>.
spring.freemarker.<span class="keyword">allow</span>-<span class="keyword">session</span>-override=<span class="literal">false</span> # <span class="keyword">Set</span> whether HttpSession <span class="keyword">attributes</span> <span class="keyword">are</span> allowed <span class="keyword">to</span> override (hide) controller <span class="keyword">generated</span> <span class="keyword">model</span> <span class="keyword">attributes</span> <span class="keyword">of</span> the same <span class="keyword">name</span>.
spring.freemarker.<span class="keyword">cache</span>=<span class="literal">false</span> # <span class="keyword">Enable</span> <span class="keyword">template</span> <span class="keyword">caching</span>.
spring.freemarker.<span class="keyword">charset</span>=UTF-<span class="number">8</span> # <span class="keyword">Template</span> <span class="keyword">encoding</span>.
spring.freemarker.<span class="keyword">check</span>-<span class="keyword">template</span>-location=<span class="literal">true</span> # <span class="keyword">Check</span> that the templates location <span class="keyword">exists</span>.
spring.freemarker.<span class="keyword">content</span>-<span class="keyword">type</span>=<span class="built_in">text</span>/html # <span class="keyword">Content</span>-<span class="keyword">Type</span> <span class="keyword">value</span>.
spring.freemarker.enabled=<span class="literal">true</span> # <span class="keyword">Enable</span> MVC <span class="keyword">view</span> resolution <span class="keyword">for</span> this technology.
spring.freemarker.expose-request-<span class="keyword">attributes</span>=<span class="literal">false</span> # <span class="keyword">Set</span> whether all request <span class="keyword">attributes</span> should be added <span class="keyword">to</span> the <span class="keyword">model</span> <span class="keyword">prior</span> <span class="keyword">to</span> merging <span class="keyword">with</span> the <span class="keyword">template</span>.
spring.freemarker.expose-<span class="keyword">session</span>-<span class="keyword">attributes</span>=<span class="literal">false</span> # <span class="keyword">Set</span> whether all HttpSession <span class="keyword">attributes</span> should be added <span class="keyword">to</span> the <span class="keyword">model</span> <span class="keyword">prior</span> <span class="keyword">to</span> merging <span class="keyword">with</span> the <span class="keyword">template</span>.
spring.freemarker.expose-spring-macro-helpers=<span class="literal">true</span> # <span class="keyword">Set</span> whether <span class="keyword">to</span> expose a RequestContext <span class="keyword">for</span> <span class="keyword">use</span> <span class="keyword">by</span> Spring<span class="string">'s macro library, under the name "springMacroRequestContext".
spring.freemarker.prefer-file-system-access=true # Prefer file system access for template loading. File system access enables hot detection of template changes.
spring.freemarker.prefix= # Prefix that gets prepended to view names when building a URL.
spring.freemarker.request-context-attribute= # Name of the RequestContext attribute for all views.
spring.freemarker.settings.*= # Well-known FreeMarker keys which will be passed to FreeMarker'</span>s Configuration.
spring.freemarker.suffix= # Suffix that gets appended <span class="keyword">to</span> <span class="keyword">view</span> <span class="keyword">names</span> <span class="keyword">when</span> building a <span class="keyword">URL</span>.
spring.freemarker.<span class="keyword">template</span>-loader-<span class="keyword">path</span>=classpath:/templates/ # Comma-separated <span class="keyword">list</span> <span class="keyword">of</span> <span class="keyword">template</span> paths.
spring.freemarker.<span class="keyword">view</span>-<span class="keyword">names</span>= # White <span class="keyword">list</span> <span class="keyword">of</span> <span class="keyword">view</span> <span class="keyword">names</span> that can be resolved.</span>
</code></pre><p>所以说一开始我们加入了一个spring-boot-starter-freemarker依赖，这个依赖中存在freemarker的lib，满足了FreeMarkerAutoConfiguration中的ConditionalOnClass里写的freemarker.template.Configuration.class这个类存在于classpath中。</p>
<p>所以就构造了FreeMarkerAutoConfiguration里的ViewResolver，这个ViewResolver被自动加入到SpringMVC中。</p>
<p>同样地，如果我们要使用velocity模板，springboot内部也有velocity的自动配置类VelocityAutoConfiguration，原理是跟freemarker一样的。</p>
<p>总结：</p>
<p>springboot内部提供了很多自动化配置的类，这些类会判断classpath中是否存在自己需要的那个类，如果存在则会自动配置相关的配置，否则就不会自动配置。</p>
<p>如果我们需要使用一些框架，只需要加入依赖即可，这些依赖内部是没有代码的，只是一些对应框架需要的lib，有了这些lib就会触发自动化配置，于是就能使用框架了。</p>
<p>这一点跟当时看springmvc的时候对response进行json或xml渲染的原理相同。springmvc中的requestmapping注解加上responsebody注解后会返回xml或者json，如果依赖中加入jackson依赖就会转换成json，如果依赖中加入xstream依赖就会转换成xml。当然，前提是springmvc中有了这两种依赖的HttpMessageConverter代码，这个HttpMessageConverter代码就相当于springboot中的各种AutoConfiguration。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>springboot用来简化Spring框架带来的大量XML配置以及复杂的依赖管理，让开发人员可以更加关注业务逻辑的开发。</p>
<p>比如不使用springboot而使用SpringMVC作为web框架进行开发的时候，需要配置相关的SpringMVC配置以及对应的依赖，比较繁琐；而使用springboot的话只需要以下短短的几行代码就可以使用SpringMVC，可谓相当地方便：</p>
<pre><code><span class="annotation">@RestController</span>
<span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{
  <span class="annotation">@RequestMapping</span>(<span class="string">"/"</span>)
  <span class="built_in">String</span> home() {
    <span class="string">"hello"</span>
  }
}
</code></pre><p>其中maven配置如下：</p>
<pre><code><span class="tag">&lt;<span class="title">parent</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.3.5.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">parent</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependencies</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span>
</code></pre>]]>
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java线程状态分析]]></title>
    <link href="http://fangjian0423.github.io/2016/06/04/java-thread-state/"/>
    <id>http://fangjian0423.github.io/2016/06/04/java-thread-state/</id>
    <published>2016-06-04T15:53:35.000Z</published>
    <updated>2016-06-04T15:53:47.000Z</updated>
    <content type="html"><![CDATA[<p>Java线程的生命周期中，存在几种状态。在Thread类里有一个枚举类型State，定义了线程的几种状态，分别有：</p>
<ol>
<li>NEW: 线程创建之后，但是还没有启动(not yet started)。这时候它的状态就是NEW</li>
<li>RUNNABLE: 正在Java虚拟机下跑任务的线程的状态。在RUNNABLE状态下的线程可能会处于等待状态， 因为它正在等待一些系统资源的释放，比如IO</li>
<li>BLOCKED: 阻塞状态，等待锁的释放，比如线程A进入了一个synchronized方法，线程B也想进入这个方法，但是这个方法的锁已经被线程A获取了，这个时候线程B就处于BLOCKED状态</li>
<li>WAITING: 等待状态，处于等待状态的线程是由于执行了3个方法中的任意方法。 1. Object的wait方法，并且没有使用timeout参数; 2. Thread的join方法，没有使用timeout参数 3. LockSupport的park方法。  处于waiting状态的线程会等待另外一个线程处理特殊的行为。 再举个例子，如果一个线程调用了一个对象的wait方法，那么这个线程就会处于waiting状态直到另外一个线程调用这个对象的notify或者notifyAll方法后才会解除这个状态</li>
<li>TIMED_WAITING: 有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。 1. Thread.sleep方法 2. Object的wait方法，带有时间 3. Thread.join方法，带有时间 4. LockSupport的parkNanos方法，带有时间 5. LockSupport的parkUntil方法，带有时间</li>
<li>TERMINATED: 线程中止的状态，这个线程已经完整地执行了它的任务</li>
</ol>
<a id="more"></a>
<p>下面通过几个例子再次说明一下在什么情况下，线程会处于这几种状态：</p>
<h2 id="NEW状态">NEW状态</h2><p>NEW状态比较简单，实例化一个线程之后，并且这个线程没有开始执行，这个时候的状态就是NEW：</p>
<pre><code><span class="keyword">Thread</span> <span class="keyword">thread</span> = <span class="literal">new</span> <span class="keyword">Thread</span>();
System<span class="built_in">.</span>out<span class="built_in">.</span>println(<span class="keyword">thread</span><span class="built_in">.</span>getState()); <span class="comment">// NEW</span>
</code></pre><h2 id="RUNNABLE状态">RUNNABLE状态</h2><p>正在运行的状态。</p>
<pre><code><span class="keyword">Thread</span> <span class="keyword">thread</span> = <span class="literal">new</span> <span class="keyword">Thread</span>(<span class="literal">new</span> Runnable() {
    @Override
    <span class="keyword">public</span> <span class="literal">void</span> run() {
        f<span class="subst">or</span>(int i = <span class="number">0</span>; i &lt; <span class="built_in">Integer</span><span class="built_in">.</span>MAX_VALUE; i ++) {
            System<span class="built_in">.</span>out<span class="built_in">.</span>println(i);
        }
    }
}, <span class="string">"RUNNABLE-Thread"</span>);
<span class="keyword">thread</span><span class="built_in">.</span>start();
</code></pre><p>使用jstack查看线程状态：</p>
<pre><code><span class="string">"RUNNABLE-Thread"</span> #<span class="number">10</span> prio=<span class="number">5</span> os_prio=<span class="number">31</span> tid=<span class="number">0</span>x00007f8e04981000 nid=<span class="number">0</span>x4f03 runnable [<span class="number">0</span>x000070000124c000]
   java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.State</span>: RUNNABLE
  at java<span class="class">.io</span><span class="class">.FileOutputStream</span><span class="class">.writeBytes</span>(Native Method)
  at java<span class="class">.io</span><span class="class">.FileOutputStream</span><span class="class">.write</span>(FileOutputStream<span class="class">.java</span>:<span class="number">315</span>)
  at java<span class="class">.io</span><span class="class">.BufferedOutputStream</span><span class="class">.flushBuffer</span>(BufferedOutputStream<span class="class">.java</span>:<span class="number">82</span>)
  at java<span class="class">.io</span><span class="class">.BufferedOutputStream</span><span class="class">.flush</span>(BufferedOutputStream<span class="class">.java</span>:<span class="number">140</span>)
  - locked &lt;<span class="number">0</span>x000000079764cc50&gt; (<span class="tag">a</span> java<span class="class">.io</span><span class="class">.BufferedOutputStream</span>)
  at java<span class="class">.io</span><span class="class">.PrintStream</span><span class="class">.write</span>(PrintStream<span class="class">.java</span>:<span class="number">482</span>)
  - locked &lt;<span class="number">0</span>x0000000797604dc0&gt; (<span class="tag">a</span> java<span class="class">.io</span><span class="class">.PrintStream</span>)
  at sun<span class="class">.nio</span><span class="class">.cs</span><span class="class">.StreamEncoder</span><span class="class">.writeBytes</span>(StreamEncoder<span class="class">.java</span>:<span class="number">221</span>)
  at sun<span class="class">.nio</span><span class="class">.cs</span><span class="class">.StreamEncoder</span><span class="class">.implFlushBuffer</span>(StreamEncoder<span class="class">.java</span>:<span class="number">291</span>)
  at sun<span class="class">.nio</span><span class="class">.cs</span><span class="class">.StreamEncoder</span><span class="class">.flushBuffer</span>(StreamEncoder<span class="class">.java</span>:<span class="number">104</span>)
  - locked &lt;<span class="number">0</span>x0000000797604d78&gt; (<span class="tag">a</span> java<span class="class">.io</span><span class="class">.OutputStreamWriter</span>)
  at java<span class="class">.io</span><span class="class">.OutputStreamWriter</span><span class="class">.flushBuffer</span>(OutputStreamWriter<span class="class">.java</span>:<span class="number">185</span>)
  at java<span class="class">.io</span><span class="class">.PrintStream</span><span class="class">.write</span>(PrintStream<span class="class">.java</span>:<span class="number">527</span>)
  - eliminated &lt;<span class="number">0</span>x0000000797604dc0&gt; (<span class="tag">a</span> java<span class="class">.io</span><span class="class">.PrintStream</span>)
  at java<span class="class">.io</span><span class="class">.PrintStream</span><span class="class">.print</span>(PrintStream<span class="class">.java</span>:<span class="number">597</span>)
  at java<span class="class">.io</span><span class="class">.PrintStream</span><span class="class">.println</span>(PrintStream<span class="class">.java</span>:<span class="number">736</span>)
  - locked &lt;<span class="number">0</span>x0000000797604dc0&gt; (<span class="tag">a</span> java<span class="class">.io</span><span class="class">.PrintStream</span>)
  at study<span class="class">.thread</span><span class="class">.ThreadStateTest</span>$<span class="number">1</span>.<span class="function"><span class="title">run</span><span class="params">(ThreadStateTest.java:<span class="number">23</span>)</span></span>
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)
</code></pre><h2 id="BLOCKED状态">BLOCKED状态</h2><p>线程A和线程B都需要持有lock对象的锁才能调用方法。如果线程A持有锁，那么线程B处于BLOCKED状态；如果线程B持有锁，那么线程A处于BLOCKED状态。例子中使用Thread.sleep方法主要是用于调试方便：</p>
<pre><code><span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();
Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">synchronized</span> (lock) {
            System.out.println(Thread.currentThread().getName() + <span class="string">" invoke"</span>);
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">20000</span>l);
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}, <span class="string">"BLOCKED-Thread-A"</span>);
Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">synchronized</span> (lock) {
            System.out.println(Thread.currentThread().getName() + <span class="string">" invoke"</span>);
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">20000</span>l);
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}, <span class="string">"BLOCKED-Thread-B"</span>);
threadA.start();
threadB.start();
</code></pre><p>使用jstack查看线程状态。由于线程A先执行，线程B后执行，而且线程A执行后调用了Thread.sleep方法，所以线程A会处于TIMED_WAITING状态，线程B处于BLOCKED状态：</p>
<pre><code><span class="string">"BLOCKED-Thread-B"</span> #<span class="number">11</span> prio=<span class="number">5</span> os_prio=<span class="number">31</span> tid=<span class="number">0</span>x00007fa7db8ff000 nid=<span class="number">0</span>x5103 waiting <span class="keyword">for</span> monitor entry [<span class="number">0</span>x000070000134f000]
   java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.State</span>: BLOCKED (on <span class="tag">object</span> monitor)
  at study<span class="class">.thread</span><span class="class">.ThreadStateTest</span>$<span class="number">3</span>.<span class="function"><span class="title">run</span><span class="params">(ThreadStateTest.java:<span class="number">50</span>)</span></span>
  - waiting to lock &lt;<span class="number">0</span>x0000000795a03bf8&gt; (<span class="tag">a</span> java<span class="class">.lang</span><span class="class">.Object</span>)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)

<span class="string">"BLOCKED-Thread-A"</span> #<span class="number">10</span> prio=<span class="number">5</span> os_prio=<span class="number">31</span> tid=<span class="number">0</span>x00007fa7db15a000 nid=<span class="number">0</span>x4f03 waiting on condition [<span class="number">0</span>x000070000124c000]
   java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.State</span>: TIMED_WAITING (sleeping)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.sleep</span>(Native Method)
  at study<span class="class">.thread</span><span class="class">.ThreadStateTest</span>$<span class="number">2</span>.<span class="function"><span class="title">run</span><span class="params">(ThreadStateTest.java:<span class="number">39</span>)</span></span>
  - locked &lt;<span class="number">0</span>x0000000795a03bf8&gt; (<span class="tag">a</span> java<span class="class">.lang</span><span class="class">.Object</span>)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)
</code></pre><h2 id="WAITING状态">WAITING状态</h2><p>Object的wait方法、Thread的join方法以及Conditon的await方法都会产生WAITING状态。</p>
<p>1.没有时间参数的Object的wait方法</p>
<pre><code>final Object <span class="keyword">lock</span> = <span class="keyword">new</span> Object();
Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
    @<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
        synchronized (<span class="keyword">lock</span>) {
            <span class="keyword">try</span> {
                <span class="keyword">lock</span>.wait();
                System.<span class="keyword">out</span>.println(<span class="string">"wait over"</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}, <span class="string">"WAITING-Thread-A"</span>);
Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
    @<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
        synchronized (<span class="keyword">lock</span>) {
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">20000</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
            <span class="keyword">lock</span>.notifyAll();
        }
    }
}, <span class="string">"WAITING-Thread-B"</span>);
threadA.start();
threadB.start();
</code></pre><p>WAITING-Thread-A调用了lock的wait，处于WAITING状态：</p>
<pre><code><span class="string">"WAITING-Thread-B"</span> #<span class="number">11</span> prio=<span class="number">5</span> os_prio=<span class="number">31</span> tid=<span class="number">0</span>x00007f8de992d800 nid=<span class="number">0</span>x5103 waiting on condition [<span class="number">0</span>x000070000134f000]
   java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.State</span>: TIMED_WAITING (sleeping)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.sleep</span>(Native Method)
  at study<span class="class">.thread</span><span class="class">.ThreadStateTest</span>$<span class="number">5</span>.<span class="function"><span class="title">run</span><span class="params">(ThreadStateTest.java:<span class="number">84</span>)</span></span>
  - locked &lt;<span class="number">0</span>x0000000795a03e40&gt; (<span class="tag">a</span> java<span class="class">.lang</span><span class="class">.Object</span>)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)

<span class="string">"WAITING-Thread-A"</span> #<span class="number">10</span> prio=<span class="number">5</span> os_prio=<span class="number">31</span> tid=<span class="number">0</span>x00007f8dea193000 nid=<span class="number">0</span>x4f03 <span class="keyword">in</span> Object.<span class="function"><span class="title">wait</span><span class="params">()</span></span> [<span class="number">0</span>x000070000124c000]
   java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.State</span>: WAITING (on <span class="tag">object</span> monitor)
  at java<span class="class">.lang</span><span class="class">.Object</span><span class="class">.wait</span>(Native Method)
  - waiting on &lt;<span class="number">0</span>x0000000795a03e40&gt; (<span class="tag">a</span> java<span class="class">.lang</span><span class="class">.Object</span>)
  at java<span class="class">.lang</span><span class="class">.Object</span><span class="class">.wait</span>(Object<span class="class">.java</span>:<span class="number">502</span>)
  at study<span class="class">.thread</span><span class="class">.ThreadStateTest</span>$<span class="number">4</span>.<span class="function"><span class="title">run</span><span class="params">(ThreadStateTest.java:<span class="number">71</span>)</span></span>
  - locked &lt;<span class="number">0</span>x0000000795a03e40&gt; (<span class="tag">a</span> java<span class="class">.lang</span><span class="class">.Object</span>)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)
</code></pre><p>2.Thread的join方法</p>
<pre><code>Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
    @<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
        <span class="keyword">try</span> {
            Thread.sleep(<span class="number">20000</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
        System.<span class="keyword">out</span>.println(<span class="string">"Thread-A over"</span>);
    }
}, <span class="string">"WAITING-Thread-A"</span>);
threadA.start();
<span class="keyword">try</span> {
    threadA.<span class="keyword">join</span>();
} <span class="keyword">catch</span> (InterruptedException e) {
    e.printStackTrace();
}
</code></pre><p>主线程main处于WAITING状态：</p>
<pre><code><span class="string">"WAITING-Thread-A"</span> #<span class="number">10</span> prio=<span class="number">5</span> os_prio=<span class="number">31</span> tid=<span class="number">0</span>x00007fd2d5100000 nid=<span class="number">0</span>x4e03 waiting on condition [<span class="number">0</span>x000070000124c000]
   java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.State</span>: TIMED_WAITING (sleeping)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.sleep</span>(Native Method)
  at study<span class="class">.thread</span><span class="class">.ThreadStateTest</span>$<span class="number">6</span>.<span class="function"><span class="title">run</span><span class="params">(ThreadStateTest.java:<span class="number">103</span>)</span></span>
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)
<span class="string">"main"</span> #<span class="number">1</span> prio=<span class="number">5</span> os_prio=<span class="number">31</span> tid=<span class="number">0</span>x00007fd2d3815000 nid=<span class="number">0</span>x1003 <span class="keyword">in</span> Object.<span class="function"><span class="title">wait</span><span class="params">()</span></span> [<span class="number">0</span>x0000700000182000]
   java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.State</span>: WAITING (on <span class="tag">object</span> monitor)
  at java<span class="class">.lang</span><span class="class">.Object</span><span class="class">.wait</span>(Native Method)
  - waiting on &lt;<span class="number">0</span>x0000000795a03ec0&gt; (<span class="tag">a</span> java<span class="class">.lang</span><span class="class">.Thread</span>)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.join</span>(Thread<span class="class">.java</span>:<span class="number">1245</span>)
  - locked &lt;<span class="number">0</span>x0000000795a03ec0&gt; (<span class="tag">a</span> java<span class="class">.lang</span><span class="class">.Thread</span>)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.join</span>(Thread<span class="class">.java</span>:<span class="number">1319</span>)
  at study<span class="class">.thread</span><span class="class">.ThreadStateTest</span><span class="class">.WAITING_join</span>(ThreadStateTest<span class="class">.java</span>:<span class="number">118</span>)
  at study<span class="class">.thread</span><span class="class">.ThreadStateTest</span><span class="class">.main</span>(ThreadStateTest<span class="class">.java</span>:<span class="number">13</span>)
  at sun<span class="class">.reflect</span><span class="class">.NativeMethodAccessorImpl</span><span class="class">.invoke0</span>(Native Method)
  at sun<span class="class">.reflect</span><span class="class">.NativeMethodAccessorImpl</span><span class="class">.invoke</span>(NativeMethodAccessorImpl<span class="class">.java</span>:<span class="number">62</span>)
  at sun<span class="class">.reflect</span><span class="class">.DelegatingMethodAccessorImpl</span><span class="class">.invoke</span>(DelegatingMethodAccessorImpl<span class="class">.java</span>:<span class="number">43</span>)
  at java<span class="class">.lang</span><span class="class">.reflect</span><span class="class">.Method</span><span class="class">.invoke</span>(Method<span class="class">.java</span>:<span class="number">483</span>)
  at com<span class="class">.intellij</span><span class="class">.rt</span><span class="class">.execution</span><span class="class">.application</span><span class="class">.AppMain</span><span class="class">.main</span>(AppMain<span class="class">.java</span>:<span class="number">140</span>)
</code></pre><p>3.没有时间参数的Condition的await方法</p>
<p>Condition的await方法跟Obejct的wait方法原理是一样的，故也是WAITING状态</p>
<h2 id="TIMED_WAITING状态">TIMED_WAITING状态</h2><p>TIMED_WAITING状态跟TIMEING状态类似，是一个有等待时间的等待状态，不会一直等待下去。</p>
<p>最简单的TIMED_WAITING状态例子就是Thread的sleep方法：</p>
<pre><code>Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
    @<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            Thread.sleep(<span class="number">20000</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(<span class="string">"Thread-A over"</span>);
    }
}, <span class="string">"WAITING-Thread-A"</span>);
threadA.start();
<span class="keyword">try</span> {
    Thread.sleep(<span class="number">5000</span>);
} <span class="keyword">catch</span> (InterruptedException e) {
    e.printStackTrace();
}
System.out.println(threadA.getState()); <span class="comment">// TIMED_WAITING</span>
</code></pre><p>或者是Object的wait方法带有时间参数、Thread的join方法带有时间参数也会让线程的状态处于TIMED_WAITING状态。</p>
<h2 id="TERMINATED">TERMINATED</h2><p>线程终止的状态，线程执行完成，结束生命周期。</p>
<pre><code>Thread threadA = <span class="keyword">new</span> Thread();
threadA.start();
<span class="keyword">try</span> {
    Thread.sleep(<span class="number">5000</span>l);
} <span class="keyword">catch</span> (InterruptedException e) {
    e.printStackTrace();
}
System.<span class="keyword">out</span>.println(threadA.getState()); <span class="comment">// TERMINATED</span>
</code></pre><h2 id="总结">总结</h2><p>了解线程的状态可以分析一些问题。</p>
<p>比如线程处于BLOCKED状态，这个时候可以分析一下是不是lock加锁的时候忘记释放了，或者释放的时机不对。导致另外的线程一直处于BLOCKED状态。</p>
<p>比如线程处于WAITING状态，这个时候可以分析一下notifyAll或者signalAll方法的调用时机是否不对。</p>
<p>java自带的jstack工具可以分析查看线程的状态、优先级、描述等具体信息。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java线程的生命周期中，存在几种状态。在Thread类里有一个枚举类型State，定义了线程的几种状态，分别有：</p>
<ol>
<li>NEW: 线程创建之后，但是还没有启动(not yet started)。这时候它的状态就是NEW</li>
<li>RUNNABLE: 正在Java虚拟机下跑任务的线程的状态。在RUNNABLE状态下的线程可能会处于等待状态， 因为它正在等待一些系统资源的释放，比如IO</li>
<li>BLOCKED: 阻塞状态，等待锁的释放，比如线程A进入了一个synchronized方法，线程B也想进入这个方法，但是这个方法的锁已经被线程A获取了，这个时候线程B就处于BLOCKED状态</li>
<li>WAITING: 等待状态，处于等待状态的线程是由于执行了3个方法中的任意方法。 1. Object的wait方法，并且没有使用timeout参数; 2. Thread的join方法，没有使用timeout参数 3. LockSupport的park方法。  处于waiting状态的线程会等待另外一个线程处理特殊的行为。 再举个例子，如果一个线程调用了一个对象的wait方法，那么这个线程就会处于waiting状态直到另外一个线程调用这个对象的notify或者notifyAll方法后才会解除这个状态</li>
<li>TIMED_WAITING: 有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。 1. Thread.sleep方法 2. Object的wait方法，带有时间 3. Thread.join方法，带有时间 4. LockSupport的parkNanos方法，带有时间 5. LockSupport的parkUntil方法，带有时间</li>
<li>TERMINATED: 线程中止的状态，这个线程已经完整地执行了它的任务</li>
</ol>]]>
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java阻塞队列ArrayBlockingQueue和LinkedBlockingQueue实现原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/05/10/java-arrayblockingqueue-linkedblockingqueue-analysis/"/>
    <id>http://fangjian0423.github.io/2016/05/10/java-arrayblockingqueue-linkedblockingqueue-analysis/</id>
    <published>2016-05-10T12:30:57.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>Java中的阻塞队列接口BlockingQueue继承自Queue接口。</p>
<p>BlockingQueue接口提供了3个添加元素方法。</p>
<ol>
<li>add：添加元素到队列里，添加成功返回true，由于容量满了添加失败会抛出IllegalStateException异常</li>
<li>offer：添加元素到队列里，添加成功返回true，添加失败返回false</li>
<li>put：添加元素到队列里，如果容量满了会阻塞直到容量不满</li>
</ol>
<p>3个删除方法。</p>
<ol>
<li>poll：删除队列头部元素，如果队列为空，返回null。否则返回元素。</li>
<li>remove：基于对象找到对应的元素，并删除。删除成功返回true，否则返回false</li>
<li>take：删除队列头部元素，如果队列为空，一直阻塞到队列有元素并删除</li>
</ol>
<p>常用的阻塞队列具体类有ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、LinkedBlockingDeque等。</p>
<p>本文以ArrayBlockingQueue和LinkedBlockingQueue为例，分析它们的实现原理。</p>
<a id="more"></a>
<h2 id="ArrayBlockingQueue">ArrayBlockingQueue</h2><p>ArrayBlockingQueue的原理就是使用一个可重入锁和这个锁生成的两个条件对象进行并发控制(classic two-condition algorithm)。</p>
<p>ArrayBlockingQueue是一个带有长度的阻塞队列，初始化的时候必须要指定队列长度，且指定长度之后不允许进行修改。</p>
<p>它带有的属性如下：</p>
<pre><code><span class="comment">// 存储队列元素的数组，是个循环数组</span>
<span class="keyword">final</span> Object[] items;

<span class="comment">// 拿数据的索引，用于take，poll，peek，remove方法</span>
<span class="keyword">int</span> takeIndex;

<span class="comment">// 放数据的索引，用于put，offer，add方法</span>
<span class="keyword">int</span> putIndex;

<span class="comment">// 元素个数</span>
<span class="keyword">int</span> <span class="keyword">count</span>;

<span class="comment">// 可重入锁</span>
<span class="keyword">final</span> ReentrantLock lock;
<span class="comment">// notEmpty条件对象，由lock创建</span>
<span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;
<span class="comment">// notFull条件对象，由lock创建</span>
<span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;
</code></pre><h3 id="数据的添加">数据的添加</h3><p>ArrayBlockingQueue有不同的几个数据添加方法，add、offer、put方法。</p>
<p>add方法：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{
    <span class="keyword">if</span> (offer(e))
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">else</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);
}
</code></pre><p>add方法内部调用offer方法如下：</p>
<pre><code><span class="function"><span class="keyword">public</span> boolean <span class="title">offer</span>(<span class="params">E e</span>) </span>{
    checkNotNull(e); <span class="comment">// 不允许元素为空</span>
    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;
    <span class="keyword">lock</span>.<span class="keyword">lock</span>(); <span class="comment">// 加锁，保证调用offer方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">if</span> (count == items.length) <span class="comment">// 如果队列已满</span>
            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 直接返回false，添加失败</span>
        <span class="keyword">else</span> {
            insert(e); <span class="comment">// 数组没满的话调用insert方法</span>
            <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 返回true，添加成功</span>
        }
    } <span class="keyword">finally</span> {
        <span class="keyword">lock</span>.unlock(); <span class="comment">// 释放锁，让其他线程可以调用offer方法</span>
    }
}
</code></pre><p>insert方法如下：</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>{
    items[putIndex] = x; <span class="comment">// 元素添加到数组里</span>
    putIndex = inc(putIndex); <span class="comment">// 放数据索引+1，当索引满了变成0</span>
    ++count; <span class="comment">// 元素个数+1</span>
    notEmpty.signal(); <span class="comment">// 使用条件对象notEmpty通知，比如使用take方法的时候队列里没有数据，被阻塞。这个时候队列insert了一条数据，需要调用signal进行通知</span>
}
</code></pre><p>put方法：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(<span class="params">E e</span>) throws InterruptedException </span>{
    checkNotNull(e); <span class="comment">// 不允许元素为空</span>
    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;
    <span class="keyword">lock</span>.lockInterruptibly(); <span class="comment">// 加锁，保证调用put方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">while</span> (count == items.length) <span class="comment">// 如果队列满了，阻塞当前线程，并加入到条件对象notFull的等待队列里</span>
            notFull.await(); <span class="comment">// 线程阻塞并被挂起，同时释放锁</span>
        insert(e); <span class="comment">// 调用insert方法</span>
    } <span class="keyword">finally</span> {
        <span class="keyword">lock</span>.unlock(); <span class="comment">// 释放锁，让其他线程可以调用put方法</span>
    }
}
</code></pre><p>ArrayBlockingQueue的添加数据方法有add，put，offer这3个方法，总结如下：</p>
<p>add方法内部调用offer方法，如果队列满了，抛出IllegalStateException异常，否则返回true</p>
<p>offer方法如果队列满了，返回false，否则返回true</p>
<p>add方法和offer方法不会阻塞线程，put方法如果队列满了会阻塞线程，直到有线程消费了队列里的数据才有可能被唤醒。</p>
<p>这3个方法内部都会使用可重入锁保证原子性。</p>
<h3 id="数据的删除">数据的删除</h3><p>ArrayBlockingQueue有不同的几个数据删除方法，poll、take、remove方法。</p>
<p>poll方法：</p>
<pre><code><span class="function"><span class="keyword">public</span> E <span class="title">poll</span>(<span class="params"></span>) </span>{
    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;
    <span class="keyword">lock</span>.<span class="keyword">lock</span>(); <span class="comment">// 加锁，保证调用poll方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : extract(); <span class="comment">// 如果队列里没元素了，返回null，否则调用extract方法</span>
    } <span class="keyword">finally</span> {
        <span class="keyword">lock</span>.unlock(); <span class="comment">// 释放锁，让其他线程可以调用poll方法</span>
    }
}
</code></pre><p>poll方法内部调用extract方法：</p>
<pre><code><span class="keyword">private</span> <span class="function">E <span class="title">extract</span><span class="params">()</span> </span>{
    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;
    E x = <span class="keyword">this</span>.&lt;E&gt;cast(items[takeIndex]); <span class="comment">// 得到取索引位置上的元素</span>
    items[takeIndex] = <span class="keyword">null</span>; <span class="comment">// 对应取索引上的数据清空</span>
    takeIndex = inc(takeIndex); <span class="comment">// 取数据索引+1，当索引满了变成0</span>
    --count; <span class="comment">// 元素个数-1</span>
    notFull.signal(); <span class="comment">// 使用条件对象notFull通知，比如使用put方法放数据的时候队列已满，被阻塞。这个时候消费了一条数据，队列没满了，就需要调用signal进行通知</span>
    <span class="keyword">return</span> x; <span class="comment">// 返回元素</span>
}
</code></pre><p>take方法：</p>
<pre><code><span class="function"><span class="keyword">public</span> E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException </span>{
    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;
    <span class="keyword">lock</span>.lockInterruptibly(); <span class="comment">// 加锁，保证调用take方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// 如果队列空，阻塞当前线程，并加入到条件对象notEmpty的等待队列里</span>
            notEmpty.await(); <span class="comment">// 线程阻塞并被挂起，同时释放锁</span>
        <span class="keyword">return</span> extract(); <span class="comment">// 调用extract方法</span>
    } <span class="keyword">finally</span> {
        <span class="keyword">lock</span>.unlock(); <span class="comment">// 释放锁，让其他线程可以调用take方法</span>
    }
}
</code></pre><p>remove方法：</p>
<pre><code><span class="function"><span class="keyword">public</span> boolean <span class="title">remove</span>(<span class="params">Object o</span>) </span>{
    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
    final Object[] items = <span class="keyword">this</span>.items;
    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;
    <span class="keyword">lock</span>.<span class="keyword">lock</span>(); <span class="comment">// 加锁，保证调用remove方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">for</span> (<span class="keyword">int</span> i = takeIndex, k = count; k &gt; <span class="number">0</span>; i = inc(i), k--) { <span class="comment">// 遍历元素</span>
            <span class="keyword">if</span> (o.equals(items[i])) { <span class="comment">// 两个对象相等的话</span>
                removeAt(i); <span class="comment">// 调用removeAt方法</span>
                <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 删除成功，返回true</span>
            }
        }
        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 删除成功，返回false</span>
    } <span class="keyword">finally</span> {
        <span class="keyword">lock</span>.unlock(); <span class="comment">// 释放锁，让其他线程可以调用remove方法</span>
    }
}
</code></pre><p>removeAt方法：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{
    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;
    <span class="keyword">if</span> (i == takeIndex) { <span class="comment">// 如果要删除数据的索引是取索引位置，直接删除取索引位置上的数据，然后取索引+1即可</span>
        items[takeIndex] = <span class="keyword">null</span>;
        takeIndex = inc(takeIndex);
    } <span class="keyword">else</span> { <span class="comment">// 如果要删除数据的索引不是取索引位置，移动元素元素，更新取索引和放索引的值</span>
        <span class="keyword">for</span> (;;) {
            <span class="keyword">int</span> nexti = inc(i);
            <span class="keyword">if</span> (nexti != putIndex) {
                items[i] = items[nexti];
                i = nexti;
            } <span class="keyword">else</span> {
                items[i] = <span class="keyword">null</span>;
                putIndex = i;
                <span class="keyword">break</span>;
            }
        }
    }
    --count; <span class="comment">// 元素个数-1</span>
    notFull.signal(); <span class="comment">// 使用条件对象notFull通知，比如使用put方法放数据的时候队列已满，被阻塞。这个时候消费了一条数据，队列没满了，就需要调用signal进行通知 </span>
}
</code></pre><p>ArrayBlockingQueue的删除数据方法有poll，take，remove这3个方法，总结如下：</p>
<p>poll方法对于队列为空的情况，返回null，否则返回队列头部元素。</p>
<p>remove方法取的元素是基于对象的下标值，删除成功返回true，否则返回false。</p>
<p>poll方法和remove方法不会阻塞线程。</p>
<p>take方法对于队列为空的情况，会阻塞并挂起当前线程，直到有数据加入到队列中。</p>
<p>这3个方法内部都会调用notFull.signal方法通知正在等待队列满情况下的阻塞线程。</p>
<h2 id="LinkedBlockingQueue">LinkedBlockingQueue</h2><p>LinkedBlockingQueue是一个使用链表完成队列操作的阻塞队列。链表是单向链表，而不是双向链表。</p>
<p>内部使用放锁和拿锁，这两个锁实现阻塞(“two lock queue” algorithm)。</p>
<p>它带有的属性如下：</p>
<pre><code><span class="comment">// 容量大小</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;

<span class="comment">// 元素个数，因为有2个锁，存在竞态条件，使用AtomicInteger</span>
<span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);

<span class="comment">// 头结点</span>
<span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; head;

<span class="comment">// 尾节点</span>
<span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;

<span class="comment">// 拿锁</span>
<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();

<span class="comment">// 拿锁的条件对象</span>
<span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();

<span class="comment">// 放锁</span>
<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();

<span class="comment">// 放锁的条件对象</span>
<span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();
</code></pre><p>ArrayBlockingQueue只有1个锁，添加数据和删除数据的时候只能有1个被执行，不允许并行执行。</p>
<p>而LinkedBlockingQueue有2个锁，放锁和拿锁，添加数据和删除数据是可以并行进行的，当然添加数据和删除数据的时候只能有1个线程各自执行。</p>
<h3 id="数据的添加-1">数据的添加</h3><p>LinkedBlockingQueue有不同的几个数据添加方法，add、offer、put方法。</p>
<p>add方法内部调用offer方法：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">boolean</span> offer(E e) {
    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// 不允许空元素</span>
    <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span>;
    <span class="keyword">if</span> (<span class="keyword">count</span>.get() == capacity) <span class="comment">// 如果容量满了，返回false</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="keyword">int</span> c = -<span class="number">1</span>;
    Node&lt;E&gt; node = <span class="keyword">new</span> Node(e); <span class="comment">// 容量没满，以新元素构造节点</span>
    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;
    putLock.lock(); <span class="comment">// 放锁加锁，保证调用offer方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">if</span> (<span class="keyword">count</span>.get() &lt; capacity) { <span class="comment">// 再次判断容量是否已满，因为可能拿锁在进行消费数据，没满的话继续执行</span>
            enqueue(node); <span class="comment">// 节点添加到链表尾部</span>
            c = <span class="keyword">count</span>.getAndIncrement(); <span class="comment">// 元素个数+1</span>
            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity) <span class="comment">// 如果容量还没满</span>
                notFull.signal(); <span class="comment">// 在放锁的条件对象notFull上唤醒正在等待的线程，表示可以再次往队列里面加数据了，队列还没满</span>
        }
    } <span class="keyword">finally</span> {
        putLock.unlock(); <span class="comment">// 释放放锁，让其他线程可以调用offer方法</span>
    }
    <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="comment">// 由于存在放锁和拿锁，这里可能拿锁一直在消费数据，count会变化。这里的if条件表示如果队列中还有1条数据</span>
        signalNotEmpty(); <span class="comment">// 在拿锁的条件对象notEmpty上唤醒正在等待的1个线程，表示队列里还有1条数据，可以进行消费</span>
    <span class="keyword">return</span> c &gt;= <span class="number">0</span>; <span class="comment">// 添加成功返回true，否则返回false</span>
}
</code></pre><p>put方法：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">void</span> put(E e) <span class="keyword">throws</span> InterruptedException {
    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// 不允许空元素</span>
    <span class="keyword">int</span> c = -<span class="number">1</span>;
    Node&lt;E&gt; node = <span class="keyword">new</span> Node(e); <span class="comment">// 以新元素构造节点</span>
    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;
    <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span>;
    putLock.lockInterruptibly(); <span class="comment">// 放锁加锁，保证调用put方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">while</span> (<span class="keyword">count</span>.get() == capacity) { <span class="comment">// 如果容量满了</span>
            notFull.await(); <span class="comment">// 阻塞并挂起当前线程</span>
        }
        enqueue(node); <span class="comment">// 节点添加到链表尾部</span>
        c = <span class="keyword">count</span>.getAndIncrement(); <span class="comment">// 元素个数+1</span>
        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity) <span class="comment">// 如果容量还没满</span>
            notFull.signal(); <span class="comment">// 在放锁的条件对象notFull上唤醒正在等待的线程，表示可以再次往队列里面加数据了，队列还没满</span>
    } <span class="keyword">finally</span> {
        putLock.unlock(); <span class="comment">// 释放放锁，让其他线程可以调用put方法</span>
    }
    <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="comment">// 由于存在放锁和拿锁，这里可能拿锁一直在消费数据，count会变化。这里的if条件表示如果队列中还有1条数据</span>
        signalNotEmpty(); <span class="comment">// 在拿锁的条件对象notEmpty上唤醒正在等待的1个线程，表示队列里还有1条数据，可以进行消费</span>
}
</code></pre><p>LinkedBlockingQueue的添加数据方法add，put，offer跟ArrayBlockingQueue一样，不同的是它们的底层实现不一样。</p>
<p>ArrayBlockingQueue中放入数据阻塞的时候，需要消费数据才能唤醒。</p>
<p>而LinkedBlockingQueue中放入数据阻塞的时候，因为它内部有2个锁，可以并行执行放入数据和消费数据，不仅在消费数据的时候进行唤醒插入阻塞的线程，同时在插入的时候如果容量还没满，也会唤醒插入阻塞的线程。</p>
<h3 id="数据的删除-1">数据的删除</h3><p>LinkedBlockingQueue有不同的几个数据删除方法，poll、take、remove方法。</p>
<p>poll方法：</p>
<pre><code><span class="keyword">public</span> E poll() {
    <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span>;
    <span class="keyword">if</span> (<span class="keyword">count</span>.get() == <span class="number">0</span>) <span class="comment">// 如果元素个数为0</span>
        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回null</span>
    E x = <span class="keyword">null</span>;
    <span class="keyword">int</span> c = -<span class="number">1</span>;
    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;
    takeLock.lock(); <span class="comment">// 拿锁加锁，保证调用poll方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">if</span> (<span class="keyword">count</span>.get() &gt; <span class="number">0</span>) { <span class="comment">// 判断队列里是否还有数据</span>
            x = dequeue(); <span class="comment">// 删除头结点</span>
            c = <span class="keyword">count</span>.getAndDecrement(); <span class="comment">// 元素个数-1</span>
            <span class="keyword">if</span> (c &gt; <span class="number">1</span>) <span class="comment">// 如果队列里还有元素</span>
                notEmpty.signal(); <span class="comment">// 在拿锁的条件对象notEmpty上唤醒正在等待的线程，表示队列里还有数据，可以再次消费</span>
        }
    } <span class="keyword">finally</span> {
        takeLock.unlock(); <span class="comment">// 释放拿锁，让其他线程可以调用poll方法</span>
    }
    <span class="keyword">if</span> (c == capacity) <span class="comment">// 由于存在放锁和拿锁，这里可能放锁一直在添加数据，count会变化。这里的if条件表示如果队列中还可以再插入数据</span>
        signalNotFull(); <span class="comment">// 在放锁的条件对象notFull上唤醒正在等待的1个线程，表示队列里还能再次添加数据</span>
                <span class="keyword">return</span> x;
}
</code></pre><p>take方法：</p>
<pre><code><span class="keyword">public</span> <span class="type">E</span> take() <span class="keyword">throws</span> <span class="type">InterruptedException</span> {
    <span class="type">E</span> x;
    int <span class="built_in">c</span> = -<span class="number">1</span>;
    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="built_in">count</span> = this.<span class="built_in">count</span>;
    <span class="keyword">final</span> <span class="type">ReentrantLock</span> takeLock = this.takeLock;
    takeLock.lockInterruptibly(); <span class="comment">// 拿锁加锁，保证调用take方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">while</span> (<span class="built_in">count</span>.<span class="keyword">get</span>() == <span class="number">0</span>) { <span class="comment">// 如果队列里已经没有元素了</span>
            notEmpty.await(); <span class="comment">// 阻塞并挂起当前线程</span>
        }
        x = dequeue(); <span class="comment">// 删除头结点</span>
        <span class="built_in">c</span> = <span class="built_in">count</span>.getAndDecrement(); <span class="comment">// 元素个数-1</span>
        <span class="keyword">if</span> (<span class="built_in">c</span> &gt; <span class="number">1</span>) <span class="comment">// 如果队列里还有元素</span>
            notEmpty.signal(); <span class="comment">// 在拿锁的条件对象notEmpty上唤醒正在等待的线程，表示队列里还有数据，可以再次消费</span>
    } finally {
        takeLock.unlock(); <span class="comment">// 释放拿锁，让其他线程可以调用take方法</span>
    }
    <span class="keyword">if</span> (<span class="built_in">c</span> == capacity) <span class="comment">// 由于存在放锁和拿锁，这里可能放锁一直在添加数据，count会变化。这里的if条件表示如果队列中还可以再插入数据</span>
        signalNotFull(); <span class="comment">// 在放锁的条件对象notFull上唤醒正在等待的1个线程，表示队列里还能再次添加数据</span>
    <span class="keyword">return</span> x;
}
</code></pre><p>remove方法：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">boolean</span> remove(Object o) {
    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
    fullyLock(); <span class="comment">// remove操作要移动的位置不固定，2个锁都需要加锁</span>
    <span class="keyword">try</span> {
        <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.<span class="keyword">next</span>; <span class="comment">// 从链表头结点开始遍历</span>
             p != <span class="keyword">null</span>;
             trail = p, p = p.<span class="keyword">next</span>) {
            <span class="keyword">if</span> (o.equals(p.item)) { <span class="comment">// 判断是否找到对象</span>
                unlink(p, trail); <span class="comment">// 修改节点的链接信息，同时调用notFull的signal方法</span>
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    } <span class="keyword">finally</span> {
        fullyUnlock(); <span class="comment">// 2个锁解锁</span>
    }
}
</code></pre><p>LinkedBlockingQueue的take方法对于没数据的情况下会阻塞，poll方法删除链表头结点，remove方法删除指定的对象。</p>
<p>需要注意的是remove方法由于要删除的数据的位置不确定，需要2个锁同时加锁。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java中的阻塞队列接口BlockingQueue继承自Queue接口。</p>
<p>BlockingQueue接口提供了3个添加元素方法。</p>
<ol>
<li>add：添加元素到队列里，添加成功返回true，由于容量满了添加失败会抛出IllegalStateException异常</li>
<li>offer：添加元素到队列里，添加成功返回true，添加失败返回false</li>
<li>put：添加元素到队列里，如果容量满了会阻塞直到容量不满</li>
</ol>
<p>3个删除方法。</p>
<ol>
<li>poll：删除队列头部元素，如果队列为空，返回null。否则返回元素。</li>
<li>remove：基于对象找到对应的元素，并删除。删除成功返回true，否则返回false</li>
<li>take：删除队列头部元素，如果队列为空，一直阻塞到队列有元素并删除</li>
</ol>
<p>常用的阻塞队列具体类有ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、LinkedBlockingDeque等。</p>
<p>本文以ArrayBlockingQueue和LinkedBlockingQueue为例，分析它们的实现原理。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CountDownLatch和CyclicBarrier的区别]]></title>
    <link href="http://fangjian0423.github.io/2016/05/01/countdownlatch-cyclicbarrier-difference/"/>
    <id>http://fangjian0423.github.io/2016/05/01/countdownlatch-cyclicbarrier-difference/</id>
    <published>2016-04-30T17:59:39.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>CountDownLatch和CyclicBarrier都是java并发包下的工具类。</p>
<p>CountDownLatch用于处理一个或多个线程等待其他所有线程完毕之后再继续进行操作。</p>
<p>比如要处理一个非常耗时的任务，处理完之后需要更新这个任务的状态，需要开多线程去分批次处理任务中的各个子任务，当所有的子任务全部执行完毕之后，就可以更新任务状态了。这个时候就需要使用CountDownLatch。</p>
<p>CyclicBarrier用于N个线程相互等待，当到达条件之后所有线程继续执行。</p>
<p>比如一个抽奖活动，每个线程进行抽奖，当奖品全部抽完之后对各个线程中的用户进行后续操作。</p>
<p>个人理解的两者之间的区别有3点：</p>
<ol>
<li>CountDownLatch可以阻塞1个或N个线程，CyclicBarrier必须要阻塞N个线程</li>
<li>CountDownLatch用完之后就不能再次使用了，CyclicBarrier用完之后可以再次使用，CyclicBarrier还可以做reset操作</li>
<li>CountDownLatch底层使用的是共享锁，CyclicBarrier底层使用的是ReentrantLock和这个lock的条件对象Condition</li>
</ol>
<a id="more"></a>
<h2 id="例子">例子</h2><p>1个CountDownLatch例子，这个例子阻塞3个线程，分别是主线程，Thread1和Thread2。这3个线程会在调用await方法之后阻塞，直到计数器变成0：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> CountDownLatchTest {

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        System.out.println(<span class="string">"主任务开始，一共需要进行7个子任务。第1和第2个子任务需要进行后续操作 "</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i ++) {
            final <span class="keyword">int</span> index = i;
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    System.out.println(<span class="string">"子任务在线程 "</span> + Thread.currentThread().getName() + <span class="string">" 中运行 "</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
                    <span class="keyword">if</span>(index == <span class="number">1</span> || index == <span class="number">2</span>) {
                        <span class="keyword">try</span> {
                            countDownLatch.await();
                        } <span class="keyword">catch</span> (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(<span class="string">"子任务在线程 "</span> + Thread.currentThread().getName() + <span class="string">" 中进行后续操作 "</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
                    }
                    <span class="keyword">if</span>(index != <span class="number">1</span> &amp;&amp; index != <span class="number">2</span>) {
                        <span class="keyword">try</span> {
                            Thread.sleep(<span class="number">5000l</span>);
                        } <span class="keyword">catch</span> (InterruptedException e) {
                            e.printStackTrace();
                        }
                        countDownLatch.countDown();
                    }
                }
            }, <span class="string">"Thread-"</span> + i).start();
        }
        <span class="keyword">try</span> {
            countDownLatch.await();
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(<span class="string">"主任务结束 "</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
    }

}
</code></pre><p>输出：</p>
<pre><code>主任务开始，一共需要进行<span class="number">7</span>个子任务。第<span class="number">1</span>和第<span class="number">2</span>个子任务需要进行后续操作 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">57</span>
子任务在线程 Thread-<span class="number">1</span> 中运行 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">57</span>
子任务在线程 Thread-<span class="number">2</span> 中运行 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">57</span>
子任务在线程 Thread-<span class="number">0</span> 中运行 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">57</span>
子任务在线程 Thread-<span class="number">3</span> 中运行 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">57</span>
子任务在线程 Thread-<span class="number">4</span> 中运行 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">57</span>
子任务在线程 Thread-<span class="number">5</span> 中运行 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">57</span>
子任务在线程 Thread-<span class="number">6</span> 中运行 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">57</span>
子任务在线程 Thread-<span class="number">2</span> 中进行后续操作 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">42</span>:<span class="number">02</span>
主任务结束 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">42</span>:<span class="number">02</span>
子任务在线程 Thread-<span class="number">1</span> 中进行后续操作 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">42</span>:<span class="number">02</span>
</code></pre><p>1个CyclicBarrier例子，模拟抽奖，每个用户都可以抽奖，当所有的用户抽完奖之后才能开始颁发奖项：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> CyclicBarrierTest {

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws InterruptedException </span>{
        System.out.println(<span class="string">"5个用户开始抽奖"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) {
            final <span class="keyword">int</span> index = i;
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    System.out.println(Thread.currentThread().getName() + <span class="string">" 用户开始抽奖，持续"</span>+(index+<span class="number">1</span>)+<span class="string">"秒"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
                    <span class="keyword">try</span> {
                        Thread.sleep((index + <span class="number">1</span>) * <span class="number">1000</span>);
                        cyclicBarrier.await();
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    } <span class="keyword">catch</span> (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                    System.out.println(<span class="string">"所有用户抽奖完毕，颁发奖项。为用户"</span> + Thread.currentThread().getName() + <span class="string">"颁奖。"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
                }
            }, <span class="string">"Thread-"</span> + i).start();
        }
    }

}
</code></pre><p>输出：</p>
<pre><code><span class="number">5</span>个用户开始抽奖<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">16</span>
Thread-<span class="number">1</span> 用户开始抽奖，持续<span class="number">2</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">16</span>
Thread-<span class="number">2</span> 用户开始抽奖，持续<span class="number">3</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">16</span>
Thread-<span class="number">3</span> 用户开始抽奖，持续<span class="number">4</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">16</span>
Thread-<span class="number">4</span> 用户开始抽奖，持续<span class="number">5</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">16</span>
Thread-<span class="number">0</span> 用户开始抽奖，持续<span class="number">1</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">16</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">0</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">21</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">2</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">21</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">1</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">21</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">4</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">21</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">3</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">21</span>
</code></pre><p>CyclicBarrier中的计数器到0之后，可以重用：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> CyclicBarrierTest2 {

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws InterruptedException </span>{
        System.out.println(<span class="string">"5个用户开始抽奖"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) {
            final <span class="keyword">int</span> index = i;
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    System.out.println(Thread.currentThread().getName() + <span class="string">" 用户开始抽奖，持续"</span>+(index+<span class="number">1</span>)+<span class="string">"秒"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
                    <span class="keyword">try</span> {
                        Thread.sleep((index + <span class="number">1</span>) * <span class="number">1000</span>);
                        cyclicBarrier.await();
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    } <span class="keyword">catch</span> (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                    System.out.println(<span class="string">"所有用户抽奖完毕，颁发奖项。为用户"</span> + Thread.currentThread().getName() + <span class="string">"颁奖。"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
                }
            }, <span class="string">"Thread-"</span> + i).start();
        }
        Thread.sleep(<span class="number">5000l</span>);
        System.out.println(<span class="string">"下一轮抽奖开始"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) {
            final <span class="keyword">int</span> index = i;
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    System.out.println(Thread.currentThread().getName() + <span class="string">" 用户开始抽奖，持续"</span>+(index+<span class="number">1</span>)+<span class="string">"秒"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
                    <span class="keyword">try</span> {
                        Thread.sleep((index + <span class="number">1</span>) * <span class="number">1000</span>);
                        cyclicBarrier.await();
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    } <span class="keyword">catch</span> (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                    System.out.println(<span class="string">"所有用户抽奖完毕，颁发奖项。为用户"</span> + Thread.currentThread().getName() + <span class="string">"颁奖。"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
                }
            }, <span class="string">"Thread-"</span> + i).start();
        }
    }

}
</code></pre><p>输出：</p>
<pre><code><span class="number">5</span>个用户开始抽奖<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">40</span>
Thread-<span class="number">1</span> 用户开始抽奖，持续<span class="number">2</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">40</span>
Thread-<span class="number">2</span> 用户开始抽奖，持续<span class="number">3</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">40</span>
Thread-<span class="number">3</span> 用户开始抽奖，持续<span class="number">4</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">40</span>
Thread-<span class="number">4</span> 用户开始抽奖，持续<span class="number">5</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">40</span>
Thread-<span class="number">0</span> 用户开始抽奖，持续<span class="number">1</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">40</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">4</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">0</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">1</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
下一轮抽奖开始<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">3</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">2</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
Thread-<span class="number">1</span> 用户开始抽奖，持续<span class="number">2</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
Thread-<span class="number">0</span> 用户开始抽奖，持续<span class="number">1</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
Thread-<span class="number">2</span> 用户开始抽奖，持续<span class="number">3</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
Thread-<span class="number">3</span> 用户开始抽奖，持续<span class="number">4</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
Thread-<span class="number">4</span> 用户开始抽奖，持续<span class="number">5</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">1</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">50</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">2</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">50</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">0</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">50</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">4</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">50</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">3</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">50</span>
</code></pre><h2 id="底层分析">底层分析</h2><h3 id="CountDownLatch">CountDownLatch</h3><p>CountDownLatch底层使用的是共享锁，它有个内部类Sync，这个Sync继承AQS，实现了共享锁。</p>
<p>简单画了一下共享锁的实现。</p>
<p>比如有4个线程在等待队列里，并且节点类型都是共享锁。 会唤醒head节点的下一节点中的线程Thread1。head节点就变成了之前head节点的下个节点，然后再做重复操作。 这个过程是一个传播过程，会依次唤醒各个共享节点中的线程。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/lockqueue01.jpg" alt=""></p>
<p>并发包下的另外一个工具类Semaphore底层也是使用共享锁实现的。但是它跟CountDownLatch唯一的区别就是它不会唤醒所有的共享节点中的线程，而是唤醒它能唤醒的最大线程数(由信号量可用大小决定)。</p>
<h3 id="CyclicBarrier">CyclicBarrier</h3><p>CyclicBarrier底层使用的是ReentrantLock和这个lock的条件对象Condition。</p>
<p>它拥有的属性如下：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>{
    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;
}

<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 可重入锁</span>
<span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition(); <span class="comment">// 可重入锁的条件对象</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties; <span class="comment">// 计数器原始值，永远不会变</span>
<span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand; <span class="comment">// 计数器到了之后需要执行的Runnable，可为空</span>
<span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation(); <span class="comment">// 一个Generation对象的实例，当计数器为0的时候这个实例将会重新被构造</span>
<span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">count</span>; <span class="comment">// 计数器当前的值</span>
</code></pre><p>await方法：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">int</span> dowait(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)
    throws InterruptedException, BrokenBarrierException,
           TimeoutException {
    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;
    lock.lock(); <span class="comment">// 加锁，确保每次只有1个线程调用</span>
    <span class="keyword">try</span> {
        <span class="keyword">final</span> Generation g = generation;

        <span class="keyword">if</span> (g.broken) <span class="comment">// 查看generation是否已经损坏</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();

        <span class="keyword">if</span> (Thread.interrupted()) {
            breakBarrier();
            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();
        }

        <span class="keyword">int</span> <span class="keyword">index</span> = --<span class="keyword">count</span>; <span class="comment">// 计数器减一</span>
        <span class="keyword">if</span> (<span class="keyword">index</span> == <span class="number">0</span>) {  <span class="comment">// 如果计数器为0</span>
            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;
            <span class="keyword">try</span> {
                <span class="keyword">final</span> Runnable command = barrierCommand;
                <span class="keyword">if</span> (command != <span class="keyword">null</span>) <span class="comment">// 如果Runnable不为空，执行run方法。注意，这里是直接调用run方法，而不是启动1个新的线程</span>
                    command.run();
                ranAction = <span class="keyword">true</span>;
                nextGeneration(); <span class="comment">// 一个过程结束，重新开始</span>
                <span class="keyword">return</span> <span class="number">0</span>;
            } <span class="keyword">finally</span> {
                <span class="keyword">if</span> (!ranAction)
                    breakBarrier();
            }
        }


        <span class="keyword">for</span> (;;) {
            <span class="keyword">try</span> {
                <span class="keyword">if</span> (!timed)
                    trip.await(); <span class="comment">// 放到Conditon的等待队列里，同时释放锁，让其他线程执行await方法</span>
                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>L)
                    nanos = trip.awaitNanos(nanos);
            } <span class="keyword">catch</span> (InterruptedException ie) {
                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) {
                    breakBarrier();
                    <span class="keyword">throw</span> ie;
                } <span class="keyword">else</span> {
                    <span class="comment">// We're about to finish waiting even if we had not</span>
                    <span class="comment">// been interrupted, so this interrupt is deemed to</span>
                    <span class="comment">// "belong" to subsequent execution.</span>
                    Thread.currentThread().interrupt();
                }
            }

            <span class="keyword">if</span> (g.broken)
                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();

            <span class="keyword">if</span> (g != generation) <span class="comment">// 说明执行了nextGeneration方法，计数器到了0</span>
                <span class="keyword">return</span> <span class="keyword">index</span>;

            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>L) {
                breakBarrier();
                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();
            }
        }
    } <span class="keyword">finally</span> {
        lock.unlock(); <span class="comment">// 解锁</span>
    }
}

<span class="keyword">private</span> <span class="keyword">void</span> nextGeneration() {
    <span class="comment">// 唤醒Conditon等待队列上的所有线程</span>
    trip.signalAll();
    <span class="comment">// 计数器值变成原始值，重新开始</span>
    <span class="keyword">count</span> = parties;
    <span class="comment">// generation被重新构造</span>
    generation = <span class="keyword">new</span> Generation();
}
</code></pre><p>执行过程解释：</p>
<p>比如Thread1执行了await方法，这个时候await方法加锁，确保其他线程不能再次调用await方法。</p>
<p>然后在await方法中把计数器数字减一。</p>
<p>如果计数器还没到0：将Thread1加入到Condition的条件队列，同时释放锁。这个时候其他线程就可以获得await方法的锁并执行。</p>
<p>如果计数器到了0：调用Conditon的signalAll方法，把Condition等待队列上的所有线程移除，移到AQS的等待队列里，然后返回index，释放锁，之后AQS等待队列上的节点中的线程就可以被唤醒了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>CountDownLatch和CyclicBarrier都是java并发包下的工具类。</p>
<p>CountDownLatch用于处理一个或多个线程等待其他所有线程完毕之后再继续进行操作。</p>
<p>比如要处理一个非常耗时的任务，处理完之后需要更新这个任务的状态，需要开多线程去分批次处理任务中的各个子任务，当所有的子任务全部执行完毕之后，就可以更新任务状态了。这个时候就需要使用CountDownLatch。</p>
<p>CyclicBarrier用于N个线程相互等待，当到达条件之后所有线程继续执行。</p>
<p>比如一个抽奖活动，每个线程进行抽奖，当奖品全部抽完之后对各个线程中的用户进行后续操作。</p>
<p>个人理解的两者之间的区别有3点：</p>
<ol>
<li>CountDownLatch可以阻塞1个或N个线程，CyclicBarrier必须要阻塞N个线程</li>
<li>CountDownLatch用完之后就不能再次使用了，CyclicBarrier用完之后可以再次使用，CyclicBarrier还可以做reset操作</li>
<li>CountDownLatch底层使用的是共享锁，CyclicBarrier底层使用的是ReentrantLock和这个lock的条件对象Condition</li>
</ol>]]>
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java实现同步的几种方式]]></title>
    <link href="http://fangjian0423.github.io/2016/04/18/java-synchronize-way/"/>
    <id>http://fangjian0423.github.io/2016/04/18/java-synchronize-way/</id>
    <published>2016-04-18T12:57:57.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>Java提供了很多同步操作，比如synchronized关键字、wait/notifyAll、ReentrantLock、Condition、一些并发包下的工具类、Semaphore，ThreadLocal、AbstractQueuedSynchronizer等。</p>
<p>本文简单说明一下这几种方式的使用。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/synchronize-way.jpeg" alt=""></p>
<a id="more"></a>
<h2 id="ReentrantLock可重入锁">ReentrantLock可重入锁</h2><p>ReentrantLock可重入锁是jdk内置的一个锁对象，可以用来实现同步，基本使用方法如下：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReentrantLockTest</span> {

    <span class="keyword">private</span> ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params"></span>) </span>{
        <span class="keyword">lock</span>.<span class="keyword">lock</span>();
        <span class="keyword">try</span> {
            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" do something synchronize"</span>);
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">5000</span>l);
            } <span class="keyword">catch</span> (InterruptedException e) {
                System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
                Thread.currentThread().interrupt();
            }
        } <span class="keyword">finally</span> {
            <span class="keyword">lock</span>.unlock();
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
        ReentrantLockTest reentrantLockTest = <span class="keyword">new</span> ReentrantLockTest();
        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
                reentrantLockTest.execute();
            }
        });
        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
                reentrantLockTest.execute();
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><p>输出：</p>
<pre><code>Thread-<span class="number">0</span> <span class="keyword">do</span> something synchronize
<span class="comment">// 隔了5秒钟 输入下面</span>
Thread-<span class="number">1</span> <span class="keyword">do</span> something synchronize
</code></pre><p>这个例子表示同一时间段只能有1个线程执行execute方法。</p>
<p>可重入锁中可重入表示的意义在于<strong>对于同一个线程，可以继续调用加锁的方法，而不会被挂起</strong>。可重入锁内部维护一个计数器，对于同一个线程调用lock方法，计数器+1，调用unlock方法，计数器-1。</p>
<p>举个例子再次说明一下可重入的意思，在一个加锁方法execute中调用另外一个加锁方法anotherLock并不会被挂起，可以直接调用(调用execute方法时计数器+1，然后内部又调用了anotherLock方法，计数器+1，变成了2)：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params"></span>) </span>{
    <span class="keyword">lock</span>.<span class="keyword">lock</span>();
    <span class="keyword">try</span> {
        System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" do something synchronize"</span>);
        <span class="keyword">try</span> {
            anotherLock();
            Thread.sleep(<span class="number">5000</span>l);
        } <span class="keyword">catch</span> (InterruptedException e) {
            System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
            Thread.currentThread().interrupt();
        }
    } <span class="keyword">finally</span> {
        <span class="keyword">lock</span>.unlock();
    }
}

<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anotherLock</span>(<span class="params"></span>) </span>{
    <span class="keyword">lock</span>.<span class="keyword">lock</span>();
    <span class="keyword">try</span> {
        System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" invoke anotherLock"</span>);
    } <span class="keyword">finally</span> {
        <span class="keyword">lock</span>.unlock();
    }
}
</code></pre><p>输出：</p>
<pre><code>Thread-0 do something synchronize
Thread-0<span class="instruction"> invoke </span>anotherLock
// 隔了5秒钟 输入下面
Thread-1 do something synchronize
Thread-1<span class="instruction"> invoke </span>anotherLock
</code></pre><h2 id="synchronized关键字">synchronized关键字</h2><p>synchronized关键跟ReentrantLock一样，也支持可重入锁。但是它是一个关键字，是一种语法级别的同步方式，称为内置锁：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedKeyWordTest</span> </span>{

    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>{
            System.out.println(Thread.currentThread().getName() + <span class="string">" do something synchronize"</span>);
        <span class="keyword">try</span> {
            anotherLock();
            Thread.sleep(<span class="number">5000l</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
            Thread.currentThread().interrupt();
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">anotherLock</span><span class="params">()</span> </span>{
        System.out.println(Thread.currentThread().getName() + <span class="string">" invoke anotherLock"</span>);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        SynchronizedKeyWordTest reentrantLockTest = <span class="keyword">new</span> SynchronizedKeyWordTest();
        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                reentrantLockTest.execute();
            }
        });
        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                reentrantLockTest.execute();
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><p>输出结果跟ReentrantLock一样，这个例子说明内置锁可以作用在方法上。它还可以作用到变量，静态方法上。</p>
<p>synchronized跟ReentrantLock相比，有几点局限性：</p>
<ol>
<li>加锁的时候不能设置超时。ReentrantLock有提供tryLock方法，可以设置超时时间，如果超过了这个时间并且没有获取到锁，就会放弃，而synchronized却没有这种功能</li>
<li>ReentrantLock可以使用多个Condition，而synchronized却只能有1个</li>
<li>不能中断一个试图获得锁的线程</li>
<li>ReentrantLock可以选择公平锁和非公平锁</li>
<li>ReentrantLock可以获得正在等待线程的个数，计数器等</li>
</ol>
<h2 id="Condition条件对象">Condition条件对象</h2><p>条件对象的意义在于对于一个已经获取锁的线程，如果还需要等待其他条件才能继续执行的情况下，才会使用Condition条件对象。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConditionTest</span> {

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
        ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();
        Condition condition = <span class="keyword">lock</span>.newCondition();
        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
                <span class="keyword">lock</span>.<span class="keyword">lock</span>();
                <span class="keyword">try</span> {
                    System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" run"</span>);
                    System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" wait for condition"</span>);
                    <span class="keyword">try</span> {
                        condition.await();
                        System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" continue"</span>);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
                        Thread.currentThread().interrupt();
                    }
                } <span class="keyword">finally</span> {
                    <span class="keyword">lock</span>.unlock();
                }
            }
        });
        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
                <span class="keyword">lock</span>.<span class="keyword">lock</span>();
                <span class="keyword">try</span> {
                    System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" run"</span>);
                    System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" sleep 5 secs"</span>);
                    <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">5000</span>l);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
                        Thread.currentThread().interrupt();
                    }
                    condition.signalAll();
                } <span class="keyword">finally</span> {
                    <span class="keyword">lock</span>.unlock();
                }
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><p>这个例子中thread1执行到condition.await()时，当前线程会被挂起，直到thread2调用了condition.signalAll()方法之后，thread1才会重新被激活执行。</p>
<p>这里需要注意的是thread1调用Condition的await方法之后，thread1线程释放锁，然后马上加入到Condition的等待队列，由于thread1释放了锁，thread2获得锁并执行，thread2执行signalAll方法之后，Condition中的等待队列thread1被取出并加入到AQS中，接下来thread2执行完毕之后释放锁，由于thread1已经在AQS的等待队列中，所以thread1被唤醒，继续执行。</p>
<h2 id="wait/notifyAll_方式">wait/notifyAll 方式</h2><p>wait/notifyAll方式跟ReentrantLock/Condition方式的原理是一样的。</p>
<p>Java中每个对象都拥有一个内置锁，在内置锁中调用wait，notify方法相当于调用锁的Condition条件对象的await和signalAll方法。</p>
<p>使用wait/notifyAll实现上面的那个Condition例子：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WaitNotifyAllTest</span> {

    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">doWait</span>(<span class="params"></span>) </span>{
        System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" run"</span>);
        System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" wait for condition"</span>);
        <span class="keyword">try</span> {
            <span class="keyword">this</span>.wait();
            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" continue"</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
            Thread.currentThread().interrupt();
        }
    }

    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">doNotify</span>(<span class="params"></span>) </span>{
        <span class="keyword">try</span> {
            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" run"</span>);
            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" sleep 5 secs"</span>);
            Thread.sleep(<span class="number">5000</span>l);
            <span class="keyword">this</span>.notifyAll();
        } <span class="keyword">catch</span> (InterruptedException e) {
            System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
            Thread.currentThread().interrupt();
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
        WaitNotifyAllTest waitNotifyAllTest = <span class="keyword">new</span> WaitNotifyAllTest();
        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
                waitNotifyAllTest.doWait();
            }
        });
        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
                waitNotifyAllTest.doNotify();
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><p>这里需要注意的是由于Condition是由锁创建的，所以调用wait/notifyAll方法的时候需要获得当前线程的锁，否则会发生IllegalMonitorStateException异常。</p>
<h2 id="ThreadLocal">ThreadLocal</h2><p>ThreadLocal是一种把变量放到线程本地的方式来实现线程同步的。</p>
<p>比如SimpleDateFormat不是一个线程安全的类，可以使用ThreadLocal实现同步。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ThreadLocalTest</span> {

    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;() {
        @<span class="function">Override
        <span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span>(<span class="params"></span>) </span>{
            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);
        }
    };

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
                Date date = <span class="keyword">new</span> Date();
                System.<span class="keyword">out</span>.println(dateFormatThreadLocal.<span class="keyword">get</span>().format(date));
            }
        });
        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
                Date date = <span class="keyword">new</span> Date();
                System.<span class="keyword">out</span>.println(dateFormatThreadLocal.<span class="keyword">get</span>().format(date));
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><h2 id="Semaphore信号量">Semaphore信号量</h2><p>Semaphore信号量被用于控制特定资源在同一个时间被访问的个数。类似连接池的概念，保证资源可以被合理的使用。可以使用构造器初始化资源个数：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> SemaphoreTest {

    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) {
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    <span class="keyword">try</span> {
                        semaphore.acquire();
                        System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + <span class="keyword">new</span> Date());
                        Thread.sleep(<span class="number">5000l</span>);
                        semaphore.release();
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
                    }
                }
            }).start();
        }
    }

}
</code></pre><p>输出：</p>
<pre><code>Thread-<span class="number">1</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">03</span>:<span class="number">46</span> CST <span class="number">2016</span>
Thread-<span class="number">0</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">03</span>:<span class="number">46</span> CST <span class="number">2016</span>
Thread-<span class="number">3</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">03</span>:<span class="number">51</span> CST <span class="number">2016</span>
Thread-<span class="number">2</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">03</span>:<span class="number">51</span> CST <span class="number">2016</span>
Thread-<span class="number">4</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">03</span>:<span class="number">56</span> CST <span class="number">2016</span>
</code></pre><h2 id="并发包下的工具类">并发包下的工具类</h2><p>一般情况下，我们不会使用wait/notifyAll或者ReentrantLock这种比较底层的类，而是使用并发包下提供的一些工具类。</p>
<h3 id="CountDownLatch">CountDownLatch</h3><p>CountDownLatch是一个计数器，它的构造方法中需要设置一个数值，用来设定计数的次数。每次调用countDown()方法之后，这个计数器都会减去1，CountDownLatch会一直阻塞着调用await()方法的线程，直到计数器的值变为0。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> CountDownLatchTest {

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) {
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + <span class="keyword">new</span> Date() + <span class="string">" run"</span>);
                    <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">5000l</span>);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                    countDownLatch.countDown();
                }
            }).start();
        }
        <span class="keyword">try</span> {
            countDownLatch.await();
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(<span class="string">"all thread over"</span>);
    }

}
</code></pre><p>输出：</p>
<pre><code>Thread-<span class="number">2</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">18</span>:<span class="number">30</span> CST <span class="number">2016</span> run
Thread-<span class="number">3</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">18</span>:<span class="number">30</span> CST <span class="number">2016</span> run
Thread-<span class="number">4</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">18</span>:<span class="number">30</span> CST <span class="number">2016</span> run
Thread-<span class="number">0</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">18</span>:<span class="number">30</span> CST <span class="number">2016</span> run
Thread-<span class="number">1</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">18</span>:<span class="number">30</span> CST <span class="number">2016</span> run
all thread over
</code></pre><h3 id="CyclicBarrier">CyclicBarrier</h3><p>CyclicBarrier阻塞调用的线程，直到条件满足时，阻塞的线程同时被打开。</p>
<p>调用await()方法的时候，这个线程就会被阻塞，当调用await()的线程数量到达屏障数的时候，主线程就会取消所有被阻塞线程的状态。</p>
<p>在CyclicBarrier的构造方法中，还可以设置一个barrierAction。</p>
<p>在所有的屏障都到达之后，会启动一个线程来运行这里面的代码。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> CyclicBarrierTest {

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        Random random = <span class="keyword">new</span> Random();
        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) {
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    <span class="keyword">int</span> secs = random.nextInt(<span class="number">5</span>);
                    System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + <span class="keyword">new</span> Date() + <span class="string">" run, sleep "</span> + secs + <span class="string">" secs"</span>);
                    <span class="keyword">try</span> {
                        Thread.sleep(secs * <span class="number">1000</span>);
                        cyclicBarrier.await();
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    } <span class="keyword">catch</span> (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + <span class="keyword">new</span> Date() + <span class="string">" runs over"</span>);
                }
            }).start();
        }
    }

}
</code></pre><p>相比CountDownLatch，CyclicBarrier是可以被循环使用的，而且遇到线程中断等情况时，还可以利用reset()方法，重置计数器，从这些方面来说，CyclicBarrier会比CountDownLatch更加灵活一些。        </p>
<h2 id="AbstractQueuedSynchronizer">AbstractQueuedSynchronizer</h2><p>AQS是很多同步工具类的基础，比如ReentrentLock里的公平锁和非公平锁，Semaphore里的公平锁和非公平锁，CountDownLatch里的锁等他们的底层都是使用AbstractQueuedSynchronizer完成的。</p>
<p>基于AbstractQueuedSynchronizer自定义实现一个独占锁：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>{

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{
        <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {
            setExclusiveOwnerThread(Thread.currentThread());
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{
        setState(<span class="number">0</span>);
        setExclusiveOwnerThread(<span class="keyword">null</span>);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{
        acquire(<span class="number">1</span>);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{
        release(<span class="number">1</span>);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        MySynchronizer mySynchronizer = <span class="keyword">new</span> MySynchronizer();
        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                mySynchronizer.lock();
                <span class="keyword">try</span> {
                    System.out.println(Thread.currentThread().getName() + <span class="string">" run"</span>);
                    System.out.println(Thread.currentThread().getName() + <span class="string">" will sleep 5 secs"</span>);
                    <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">5000l</span>);
                        System.out.println(Thread.currentThread().getName() + <span class="string">" continue"</span>);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
                        Thread.currentThread().interrupt();
                    }
                } <span class="keyword">finally</span> {
                    mySynchronizer.unlock();
                }
            }
        });
        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                mySynchronizer.lock();
                <span class="keyword">try</span> {
                    System.out.println(Thread.currentThread().getName() + <span class="string">" run"</span>);
                } <span class="keyword">finally</span> {
                    mySynchronizer.unlock();
                }
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><p>MySynchronizer并没有实现可重入功能，只是简单的一个独占锁。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java提供了很多同步操作，比如synchronized关键字、wait/notifyAll、ReentrantLock、Condition、一些并发包下的工具类、Semaphore，ThreadLocal、AbstractQueuedSynchronizer等。</p>
<p>本文简单说明一下这几种方式的使用。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/synchronize-way.jpeg" alt=""></p>]]>
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk ConcurrentSkipListMap工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/04/12/jdk-concurrentskiplistmap/"/>
    <id>http://fangjian0423.github.io/2016/04/12/jdk-concurrentskiplistmap/</id>
    <published>2016-04-12T11:49:11.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>ConcurrentSkipListMap是一个内部使用跳表，并且支持排序和并发的一个Map。</p>
<p>跳表的介绍：</p>
<p>跳表是一种允许在一个有顺序的序列中进行快速查询的数据结构。</p>
<p>如果在普通的顺序链表中查询一个元素，需要从链表头部开始一个一个节点进行遍历，然后找到节点，如下图所示，要查找234元素的话需要从5元素节点开始一个一个节点进行遍历，这样的效率是非常低的。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist01.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>跳表可以解决这种查询时间过长的问题：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist02.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>从上图可以看到，跳表具有以下几种特性：</p>
<ol>
<li>由很多层组成，level越高的层节点越少，最后一层level用有所有的节点数据</li>
<li>每一层的节点数据也都是有顺序的</li>
<li>上面层的节点肯定会在下面层中出现</li>
<li>每个节点都有两个指针，分别是同一层的下一个节点指针和下一层节点的指针</li>
</ol>
<p>使用跳表查询元素的时间复杂度是O(log n)，跟红黑树一样。查询效率还是不错的，</p>
<p>但是跳表的存储容量变大了，本来一共只有7个节点的数据，使用跳表之后变成了14个节点。</p>
<p>所以跳表是一种使用”空间换时间”的概念用来提高查询效率的链表，开源软件Redis、LevelDB都使用到了跳表。跳表相比B树，红黑树，AVL树时间复杂度一样，但是耗费更多存储空间，但是跳表的优势就是它相比树，实现简单，不需要考虑树的一些rebalance问题。</p>
<a id="more"></a>
<p>下图是一个级别更高的跳表：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist03.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<h2 id="跳表的查询">跳表的查询</h2><p>比如要在下面这个跳表中查找93元素，过程如下：</p>
<ol>
<li>从head节点(最上层的第一个节点)开始找，发现5比93小，继续同一层(Level3)的下一个节点150进行比较</li>
<li>发现105比93大，往下一层(Level2)走，然后找Level2的5元素的下一个节点67，发现67比93小，继续同一层(Level2)的下一个节点150进行比较</li>
<li>发现105比93大，往下一层(Level1)走，然后找Level1的67元素的下一个节点93，找到，返回</li>
</ol>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist04.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<h2 id="跳表新增元素">跳表新增元素</h2><p>跳表中新增元素的话首先会确定Level层，在这个Level以及这个Level以下的层中都加入新的元素，具体的Level层数是通过一个通过一种随机算法获取的，比如之前这个跳表在Level2和Level1中插入666元素：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist05.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>如果Level大于目前跳表的层数，那么会添加新的一层。</p>
<h2 id="跳表删除元素">跳表删除元素</h2><p>在各个层中找到对应的元素并删除即可。</p>
<h2 id="ConcurrentSkipListMap分析">ConcurrentSkipListMap分析</h2><p>ConcurrentSkipListMap对跳表中的几个概念做了一层封装，如下：</p>
<pre><code><span class="comment">// 每个节点的封装，跟层数没有关系</span>
static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> {</span>
    <span class="keyword">final</span> <span class="type">K</span> key; <span class="comment">// 节点的关键字</span>
    volatile <span class="type">Object</span> value; <span class="comment">// 节点的值</span>
    volatile <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next; <span class="comment">// 节点的next节点引用</span>
    ...
}

<span class="comment">// 每一层节点的封装，叫做索引</span>
static <span class="class"><span class="keyword">class</span> <span class="title">Index&lt;K</span>,<span class="title">V&gt;</span> {</span>
    <span class="keyword">final</span> <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; node; <span class="comment">// 对应的节点</span>
    <span class="keyword">final</span> <span class="type">Index</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; down; <span class="comment">// 下一层索引</span>
    volatile <span class="type">Index</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right; <span class="comment">// 同一层的下一个索引</span>
    ...
}

<span class="comment">// 每一层的头索引</span>
static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadIndex&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Index&lt;K</span>,<span class="title">V&gt;</span> {</span>
    <span class="keyword">final</span> int level; <span class="comment">// Level 级别</span>
    <span class="type">HeadIndex</span>(<span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; node, <span class="type">Index</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; down, <span class="type">Index</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right, int level) {
        <span class="keyword">super</span>(node, down, right);
        <span class="keyword">this</span>.level = level;
    }
    ...
}
</code></pre><p>简单分析下ConcurrentSkipListMap的get方法：</p>
<pre><code><span class="keyword">private</span> V doGet(<span class="keyword">Object</span> <span class="variable">key</span>) {
    <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;
    outer: <span class="keyword">for</span> (;;) {
        <span class="comment">// findPredecessor方法表示找到最接近要查找节点的节点，并且这个节点在最下面那一层，这样就保证会遍历所有节点</span>
        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(<span class="variable">key</span>, cmp), n = b.next;;) {
            <span class="keyword">Object</span> v; <span class="built_in">int</span> c;
            <span class="keyword">if</span> (n == <span class="keyword">null</span>) <span class="comment">// 已经遍历节点到最后还是没有找到，break，返回null</span>
                <span class="keyword">break</span> outer;
            Node&lt;K,V&gt; f = n.next;
            <span class="keyword">if</span> (n != b.next) <span class="comment">// 判断比较下一个节点是否发生了变化，如果发生变化break重新开始死循环</span>
                <span class="keyword">break</span>;
            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) {    <span class="comment">// 如果下一个节点已经被删除了</span>
                n.helpDelete(b, f);
                <span class="keyword">break</span>;
            }
            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span>
                <span class="keyword">break</span>;
            <span class="keyword">if</span> ((c = cpr(cmp, <span class="variable">key</span>, n.<span class="variable">key</span>)) == <span class="number">0</span>) {  <span class="comment">// 比较并且找到了，直接返回</span>
                @SuppressWarnings(<span class="string">"unchecked"</span>) V vv = (V)v;
                <span class="keyword">return</span> vv;
            }
            <span class="keyword">if</span> (c &lt; <span class="number">0</span>) <span class="comment">// 找过头了，说明没有对应节点了，跳出循环，返回null</span>
                <span class="keyword">break</span> outer;
            b = n; <span class="comment">// 继续遍历</span>
            n = f; <span class="comment">// 继续遍历</span>
        }
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;
}

<span class="keyword">private</span> Node&lt;K,V&gt; findPredecessor(<span class="keyword">Object</span> <span class="variable">key</span>, Comparator&lt;? <span class="keyword">super</span> K&gt; cmp) {
    <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don't postpone errors</span>
    <span class="keyword">for</span> (;;) { <span class="comment">// 一个死循环内部套着另外一个循环</span>
        <span class="keyword">for</span> (Index&lt;K,V&gt; q = head, r = q.right, d;;) { <span class="comment">// head表示最顶层的第一个索引，从这个索引开始找</span>
            <span class="keyword">if</span> (r != <span class="keyword">null</span>) { <span class="comment">// 如果索引的同一层下一个索引不为null</span>
                Node&lt;K,V&gt; n = r.node;
                K k = n.<span class="variable">key</span>;
                <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) { <span class="comment">// 如果是个已删除节点</span>
                    <span class="keyword">if</span> (!q.unlink(r)) <span class="comment">// 使用cas把已删除节点从跳表上删除掉</span>
                        <span class="keyword">break</span>;           <span class="comment">// 已删除节点从跳表上删除失败，跳出重新循环</span>
                    r = q.right;         <span class="comment">// 继续遍历</span>
                    <span class="keyword">continue</span>;
                }
                <span class="keyword">if</span> (cpr(cmp, <span class="variable">key</span>, k) &gt; <span class="number">0</span>) { <span class="comment">// 使用cas比较要找的关键字和索引内节点的关键字，如果满足比较条件</span>
                    q = r; <span class="comment">// 当前所在索引变成同一层下一个索引</span>
                    r = r.right;  <span class="comment">// 当前所在索引的下一个索引变成下下个索引，继续遍历</span>
                    <span class="keyword">continue</span>;
                }
            }
            <span class="comment">// 直到找出上一层满足不了条件的那个索引</span>
            <span class="keyword">if</span> ((d = q.down) == <span class="keyword">null</span>) <span class="comment">// 找到下一层的索引</span>
                <span class="keyword">return</span> q.node; <span class="comment">// 如果下一层没有索引了，返回找到的最接近的节点</span>
            q = d; <span class="comment">// 下一层开始做相同的操作</span>
            r = d.right; <span class="comment">// 下一层开始做相同的操作</span>
        }
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>ConcurrentSkipListMap是一个内部使用跳表，并且支持排序和并发的一个Map。</p>
<p>跳表的介绍：</p>
<p>跳表是一种允许在一个有顺序的序列中进行快速查询的数据结构。</p>
<p>如果在普通的顺序链表中查询一个元素，需要从链表头部开始一个一个节点进行遍历，然后找到节点，如下图所示，要查找234元素的话需要从5元素节点开始一个一个节点进行遍历，这样的效率是非常低的。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist01.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>跳表可以解决这种查询时间过长的问题：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist02.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>从上图可以看到，跳表具有以下几种特性：</p>
<ol>
<li>由很多层组成，level越高的层节点越少，最后一层level用有所有的节点数据</li>
<li>每一层的节点数据也都是有顺序的</li>
<li>上面层的节点肯定会在下面层中出现</li>
<li>每个节点都有两个指针，分别是同一层的下一个节点指针和下一层节点的指针</li>
</ol>
<p>使用跳表查询元素的时间复杂度是O(log n)，跟红黑树一样。查询效率还是不错的，</p>
<p>但是跳表的存储容量变大了，本来一共只有7个节点的数据，使用跳表之后变成了14个节点。</p>
<p>所以跳表是一种使用”空间换时间”的概念用来提高查询效率的链表，开源软件Redis、LevelDB都使用到了跳表。跳表相比B树，红黑树，AVL树时间复杂度一样，但是耗费更多存储空间，但是跳表的优势就是它相比树，实现简单，不需要考虑树的一些rebalance问题。</p>]]>
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="map" scheme="http://fangjian0423.github.io/tags/map/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk PriorityQueue优先队列工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/04/10/jdk_priorityqueue/"/>
    <id>http://fangjian0423.github.io/2016/04/10/jdk_priorityqueue/</id>
    <published>2016-04-10T13:36:08.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>优先队列跟普通的队列不一样，普通队列是一种遵循FIFO规则的队列，拿数据的时候按照加入队列的顺序拿取。   而优先队列每次拿数据的时候都会拿出优先级最高的数据。</p>
<p>优先队列内部维护着一个堆，每次取数据的时候都从堆顶拿数据，这就是优先队列的原理。</p>
<p>jdk的优先队列使用PriorityQueue这个类，使用者可以自己定义优先级规则。</p>
<a id="more"></a>
<h2 id="一个PriorityQueue例子">一个PriorityQueue例子</h2><p>定义一个Task类，有2个属性name和level。这个类放到PriorityQueue里，level越大优先级越高：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> Task {
    String name;
    <span class="keyword">int</span> level;

    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name, <span class="keyword">int</span> level)</span> </span>{
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.level = level;
    }

    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> name;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{
        <span class="keyword">this</span>.name = name;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLevel</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> level;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLevel</span><span class="params">(<span class="keyword">int</span> level)</span> </span>{
        <span class="keyword">this</span>.level = level;
    }

    @<span class="function">Override
    <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="string">"Task{"</span> +
                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +
                <span class="string">", level="</span> + level +
                <span class="string">'}'</span>;
    }
}

<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
    PriorityQueue&lt;Task&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> PriorityQueue&lt;Task&gt;(<span class="number">6</span>, <span class="keyword">new</span> Comparator&lt;Task&gt;() {
        @<span class="function">Override
        <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Task t1, Task t2)</span> </span>{
            <span class="keyword">return</span> t2.getLevel() - t1.getLevel();
        }
    });
    <span class="built_in">queue</span>.add(<span class="keyword">new</span> Task(<span class="string">"游戏"</span>, <span class="number">20</span>));
    <span class="built_in">queue</span>.add(<span class="keyword">new</span> Task(<span class="string">"吃饭"</span>, <span class="number">100</span>));
    <span class="built_in">queue</span>.add(<span class="keyword">new</span> Task(<span class="string">"睡觉"</span>, <span class="number">90</span>));
    <span class="built_in">queue</span>.add(<span class="keyword">new</span> Task(<span class="string">"看书"</span>, <span class="number">70</span>));
    <span class="built_in">queue</span>.add(<span class="keyword">new</span> Task(<span class="string">"工作"</span>, <span class="number">80</span>));
    <span class="built_in">queue</span>.add(<span class="keyword">new</span> Task(<span class="string">"撩妹"</span>, <span class="number">10</span>));
    <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) {
        System.out.println(<span class="built_in">queue</span>.poll());
    }
}
</code></pre><p>输出结果：</p>
<pre><code><span class="keyword">Task</span>{name=<span class="string">'吃饭'</span>, level=<span class="number">100</span>}
<span class="keyword">Task</span>{name=<span class="string">'睡觉'</span>, level=<span class="number">90</span>}
<span class="keyword">Task</span>{name=<span class="string">'工作'</span>, level=<span class="number">80</span>}
<span class="keyword">Task</span>{name=<span class="string">'看书'</span>, level=<span class="number">70</span>}
<span class="keyword">Task</span>{name=<span class="string">'游戏'</span>, level=<span class="number">20</span>}
<span class="keyword">Task</span>{name=<span class="string">'撩妹'</span>, level=<span class="number">10</span>}
</code></pre><p>add过程其实就是在最大堆里添加新的元素，添加之后再进行调整：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/priorityqueue01.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>出队相当于每次都是堆顶出堆，堆顶出堆之后然后重新调整：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/priorityqueue02.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<h2 id="PriorityQueue原理分析">PriorityQueue原理分析</h2><p>首先看下PriorityQueue的属性：</p>
<pre><code><span class="keyword">transient</span> <span class="keyword">Object</span>[] queue; <span class="comment">// 堆</span>
<span class="keyword">private</span> <span class="built_in">int</span> <span class="built_in">size</span> = <span class="number">0</span>; <span class="comment">// 元素个数</span>
<span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator; <span class="comment">// 比较器，如果是null，使用元素自身的比较器</span>
</code></pre><p>接下来是PriorityQueue的几个方法介绍。</p>
<p>add，添加元素：</p>
<pre><code><span class="function"><span class="keyword">public</span> boolean <span class="title">add</span><span class="params">(E e)</span> </span>{
    <span class="keyword">return</span> offer(e); <span class="comment">// add方法内部调用offer方法</span>
}

<span class="function"><span class="keyword">public</span> boolean <span class="title">offer</span><span class="params">(E e)</span> </span>{
    <span class="keyword">if</span> (e == null) <span class="comment">// 元素为空的话，抛出NullPointerException异常</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    modCount++;
    <span class="keyword">int</span> i = size;
    <span class="keyword">if</span> (i &gt;= <span class="built_in">queue</span>.length) <span class="comment">// 如果当前用堆表示的数组已经满了，调用grow方法扩容</span>
        grow(i + <span class="number">1</span>); <span class="comment">// 扩容</span>
    size = i + <span class="number">1</span>; <span class="comment">// 元素个数+1</span>
    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="comment">// 堆还没有元素的情况</span>
        <span class="built_in">queue</span>[<span class="number">0</span>] = e; <span class="comment">// 直接给堆顶赋值元素</span>
    <span class="keyword">else</span> <span class="comment">// 堆中已有元素的情况</span>
        siftUp(i, e); <span class="comment">// 重新调整堆，从下往上调整，因为新增元素是加到最后一个叶子节点</span>
    <span class="keyword">return</span> <span class="literal">true</span>;
}

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{
    <span class="keyword">if</span> (comparator != null)  <span class="comment">// 比较器存在的情况下</span>
        siftUpUsingComparator(k, x); <span class="comment">// 使用比较器调整</span>
    <span class="keyword">else</span> <span class="comment">// 比较器不存在的情况下</span>
        siftUpComparable(k, x); <span class="comment">// 使用元素自身的比较器调整</span>
}

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{
    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) { <span class="comment">// 一直循环直到父节点还存在</span>
        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 找到父节点索引</span>
        Object e = <span class="built_in">queue</span>[parent]; <span class="comment">// 赋值父节点元素</span>
        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>) <span class="comment">// 新元素与父元素进行比较，如果满足比较器结果，直接跳出，否则进行调整</span>
            <span class="keyword">break</span>;
        <span class="built_in">queue</span>[k] = e; <span class="comment">// 进行调整，新位置的元素变成了父元素</span>
        k = parent; <span class="comment">// 新位置索引变成父元素索引，进行递归操作</span>
    }
    <span class="built_in">queue</span>[k] = x; <span class="comment">// 新添加的元素添加到堆中</span>
}
</code></pre><p>siftUp方法调用过程如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/priorityqueue03.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>poll，出队方法：</p>
<pre><code><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (size == <span class="number">0</span>)
        <span class="keyword">return</span> null;
    <span class="keyword">int</span> s = --size; <span class="comment">// 元素个数-1</span>
    modCount++;
    E result = (E) <span class="built_in">queue</span>[<span class="number">0</span>]; <span class="comment">// 得到堆顶元素</span>
    E x = (E) <span class="built_in">queue</span>[s]; <span class="comment">// 最后一个叶子节点</span>
    <span class="built_in">queue</span>[s] = null; <span class="comment">// 最后1个叶子节点置空</span>
    <span class="keyword">if</span> (s != <span class="number">0</span>)
        siftDown(<span class="number">0</span>, x); <span class="comment">// 从上往下调整，因为删除元素是删除堆顶的元素</span>
    <span class="keyword">return</span> result;
}

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{
    <span class="keyword">if</span> (comparator != null) <span class="comment">// 比较器存在的情况下</span>
        siftDownUsingComparator(k, x); <span class="comment">// 使用比较器调整</span>
    <span class="keyword">else</span> <span class="comment">// 比较器不存在的情况下</span>
        siftDownComparable(k, x); <span class="comment">// 使用元素自身的比较器调整</span>
}

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{
    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 只需循环节点个数的一般即可</span>
    <span class="keyword">while</span> (k &lt; half) {
        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 得到父节点的左子节点索引</span>
        Object c = <span class="built_in">queue</span>[child]; <span class="comment">// 得到左子元素</span>
        <span class="keyword">int</span> right = child + <span class="number">1</span>; <span class="comment">// 得到父节点的右子节点索引</span>
        <span class="keyword">if</span> (right &lt; size &amp;&amp;
            comparator.compare((E) c, (E) <span class="built_in">queue</span>[right]) &gt; <span class="number">0</span>) <span class="comment">// 左子节点跟右子节点比较，取更大的值</span>
            c = <span class="built_in">queue</span>[child = right];
        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)  <span class="comment">// 然后这个更大的值跟最后一个叶子节点比较</span>

            <span class="keyword">break</span>;
        <span class="built_in">queue</span>[k] = c; <span class="comment">// 新位置使用更大的值</span>
        k = child; <span class="comment">// 新位置索引变成子元素索引，进行递归操作</span>
    }
    <span class="built_in">queue</span>[k] = x; <span class="comment">// 最后一个叶子节点添加到合适的位置</span>
}
</code></pre><p>siftDown方法调用过程如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/priorityqueue04.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>grow扩容方法：</p>
<pre><code><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{
    <span class="keyword">int</span> oldCapacity = <span class="built_in">queue</span>.length;
    <span class="comment">// 新容量</span>
    <span class="comment">// 如果老容量小于64 新容量 = 老容量 + 老容量 + 2</span>
    <span class="comment">// 如果老容量大于等于64 老容量 = 老容量 + 老容量/2</span>
    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?
                                     (oldCapacity + <span class="number">2</span>) :
                                     (oldCapacity &gt;&gt; <span class="number">1</span>));
    <span class="comment">// 溢出处理</span>
    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)
        newCapacity = hugeCapacity(minCapacity);
    <span class="comment">// 使用新容量</span>
    <span class="built_in">queue</span> = Arrays.copyOf(<span class="built_in">queue</span>, newCapacity);
}
</code></pre><p>remove，删除队列元素操作：</p>
<pre><code><span class="function"><span class="keyword">public</span> boolean <span class="title">remove</span><span class="params">(Object o)</span> </span>{
    <span class="keyword">int</span> i = indexOf(o); <span class="comment">// 找到数据对应的索引</span>
    <span class="keyword">if</span> (i == -<span class="number">1</span>) <span class="comment">// 不存在的话返回false</span>
        <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">else</span> { <span class="comment">// 存在的话调用removeAt方法，返回true</span>
        removeAt(i);
        <span class="keyword">return</span> <span class="literal">true</span>;
    }
}

<span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{
    modCount++;
    <span class="keyword">int</span> s = --size; <span class="comment">// 元素个数-1</span>
    <span class="keyword">if</span> (s == i) <span class="comment">// 如果是删除最后一个叶子节点</span>
        <span class="built_in">queue</span>[i] = null; <span class="comment">// 直接置空，删除即可，堆还是保持特质，不需要调整</span>
    <span class="keyword">else</span> { <span class="comment">// 如果是删除的不是最后一个叶子节点</span>
        E moved = (E) <span class="built_in">queue</span>[s]; <span class="comment">// 获得最后1个叶子节点元素</span>
        <span class="built_in">queue</span>[s] = null; <span class="comment">// 最后1个叶子节点置空</span>
        siftDown(i, moved); <span class="comment">// 从上往下调整</span>
        <span class="keyword">if</span> (<span class="built_in">queue</span>[i] == moved) { <span class="comment">// 如果从上往下调整完毕之后发现元素位置没变，从下往上调整</span>
            siftUp(i, moved); <span class="comment">// 从下往上调整</span>
            <span class="keyword">if</span> (<span class="built_in">queue</span>[i] != moved)
                <span class="keyword">return</span> moved;
        }
    }
    <span class="keyword">return</span> null;
}
</code></pre><p>下图这个堆如果删除红色节点100的时候，siftDown之后元素位置没变，所以还得siftUp：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/priorityqueue05.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<h2 id="总结">总结</h2><ol>
<li>jdk内置的优先队列PriorityQueue内部使用一个堆维护数据，每当有数据add进来或者poll出去的时候会对堆做从下往上的调整和从上往下的调整</li>
<li>PriorityQueue不是一个线程安全的类，如果要在多线程环境下使用，可以使用PriorityBlockingQueue这个优先阻塞队列</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>优先队列跟普通的队列不一样，普通队列是一种遵循FIFO规则的队列，拿数据的时候按照加入队列的顺序拿取。   而优先队列每次拿数据的时候都会拿出优先级最高的数据。</p>
<p>优先队列内部维护着一个堆，每次取数据的时候都从堆顶拿数据，这就是优先队列的原理。</p>
<p>jdk的优先队列使用PriorityQueue这个类，使用者可以自己定义优先级规则。</p>]]>
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="queue" scheme="http://fangjian0423.github.io/tags/queue/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[堆、二叉堆、堆排序]]></title>
    <link href="http://fangjian0423.github.io/2016/04/09/heap-heapsort/"/>
    <id>http://fangjian0423.github.io/2016/04/09/heap-heapsort/</id>
    <published>2016-04-09T09:42:18.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>堆的概念：</p>
<p>n个元素序列 { k1, k2, k3, k4, k5, k6 …. kn } 当且仅当满足以下关系时才会被称为堆：</p>
<pre><code>ki &lt;= k2i,ki &lt;= k2i+<span class="number">1</span> 或者 ki &gt;= k2i,ki &gt;= k2i+<span class="number">1</span> (i = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> .. n/<span class="number">2</span>)
</code></pre><p>如果数组的下表是从0开始，那么需要满足 </p>
<pre><code>ki &lt;= k2i+<span class="number">1</span>,ki &lt;= k2i+<span class="number">2</span> 或者 ki &gt;= k2i+<span class="number">1</span>,ki &gt;= k2i+<span class="number">2</span> (i = <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> .. n/<span class="number">2</span>)
</code></pre><p>比如 { 1,3,5,10,15,9 } 这个序列就满足 [1 &lt;= 3; 1 &lt;= 5],  [3 &lt;= 10; 3 &lt;= 15], [5 &lt;= 9] 这3个条件，这个序列就是一个堆。</p>
<p>所以堆其实是一个序列(数组)，如果这个序列满足上述条件，那么就把这个序列看成堆。</p>
<p>堆的实现通常是通过构造二叉堆，因为二叉堆应用很普遍，当不加限定时，堆通常指的就是二叉堆。</p>
<a id="more"></a>
<p>二叉堆的概念：</p>
<p>二叉堆是一种特殊的堆，是一棵完全二叉树或者是近似完全二叉树，同时二叉堆还满足堆的特性：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。</p>
<p>当父节点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父节点的键值总是小于或等于任何一个子节点的键值时为最小堆。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/heap01.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>上图中的最小堆对应的序列是： [1,3,5,9,10,15]  满足最小堆的特性(父节点的键值小于或等于任何一个子节点的键值，并且也满足堆的性质 [1 &lt;= 3; 1 &lt;= 5], [3 &lt;= 9; 3 &lt;= 10], [5 &lt;= 15])</p>
<p>上图中的最大堆对应的序列是： [15,10,9,7,5,3]  满足最大堆的特性(父节点的键值大于或等于任何一个子节点的键值，并且也满足堆的性质 [15 &gt;= 10; 15 &gt;= 9], [10 &gt;= 7; 10 &gt;= 5], [9 &gt;= 3])</p>
<h2 id="堆的操作">堆的操作</h2><h3 id="堆排序">堆排序</h3><p>堆排序指的是对堆这种数据结构进行排序的一种算法。其基本思想如下，以最大堆为例：</p>
<ol>
<li>将数组序列构建成最大堆[ A1, A2, A3 .. An]，这个堆是一个刚初始化无序区，同时有序区为空</li>
<li>堆顶元素A1与最后一个元素An进行交换，得到新的有序区[An]，无序区变成[A1 … An-1]</li>
<li>交换之后可能导致[A1 … An-1]这个无序区不是一个最大堆，[A1 … An-1]无序区重新调整成最大堆。重复步骤2，A1与An-1进行交换，得到新的有序区[An,An-1]，无序区变成[A1 … An-2].. 不断重复，直到有序区的个数为n-1才结束排序过程</li>
</ol>
<p>构造堆的过程如下(以最大堆为例)：</p>
<p>从最后一个非叶子节点开始调整，遍历节点和2个子节点，选择键值最大的节点的键值代替父节点的键值，如果进行了调整，调整之后的两个子节点可能不符合堆特性，递归调整。一直直到调整完根节点。</p>
<p>以序列[3,5,15,9,10,1]为例进行的堆排序：</p>
<p>首先第1步先把数组转换成完全二叉树：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/heap02.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>接下来是第2、3步构造有序区和无序区：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/heap03.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>构造完之后有序区的元素依次是：1，3，5，9，10，15</p>
<p>简单地使用java写一下堆排序：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> HeapSort {

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size, <span class="keyword">int</span> index)</span> </span>{
        <span class="keyword">int</span> leftSonIndex = <span class="number">2</span> * index + <span class="number">1</span>;
        <span class="keyword">int</span> rightSonIndex = <span class="number">2</span> * index + <span class="number">2</span>;
        <span class="keyword">int</span> temp = index;
        <span class="keyword">if</span>(index &lt;= size / <span class="number">2</span>) {
            <span class="keyword">if</span>(leftSonIndex &lt; size &amp;&amp; arr[temp] &lt; arr[leftSonIndex]) {
                temp = leftSonIndex;
            }
            <span class="keyword">if</span>(rightSonIndex &lt; size &amp;&amp; arr[temp] &lt; arr[rightSonIndex]) {
                temp = rightSonIndex;
            }
            <span class="comment">// 左右子节点的值存在比父节点的值更大</span>
            <span class="keyword">if</span>(temp != index) {
                swap(arr, index, temp); <span class="comment">// 交换值</span>
                maxHeapify(arr, size, temp); <span class="comment">// 递归调整</span>
            }
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size)</span> </span>{
        <span class="comment">// 构造成最大堆</span>
        buildMaxHeap(arr, arr.length);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i --) {
            <span class="comment">// 先交换堆顶元素和无序区最后一个元素</span>
            swap(arr, <span class="number">0</span>, i);
            <span class="comment">// 重新调整无序区</span>
            buildMaxHeap(arr, i - <span class="number">1</span>);
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size)</span> </span>{
        <span class="keyword">for</span>(<span class="keyword">int</span> i = size / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --) { <span class="comment">// 最后一个非叶子节点开始调整</span>
            maxHeapify(arr, size, i);
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{
        <span class="keyword">int</span> temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        <span class="keyword">int</span>[] arr = { <span class="number">3</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">1</span>};
        System.out.println(<span class="string">"before build: "</span> + Arrays.toString(arr)); <span class="comment">// before build: [3, 5, 15, 9, 10, 1]</span>
        buildMaxHeap(arr, arr.length);
        System.out.println(<span class="string">"after build: "</span> + Arrays.toString(arr)); <span class="comment">// after build: [15, 10, 3, 9, 5, 1]</span>
        heapSort(arr, arr.length);
        System.out.println(<span class="string">"after sort: "</span> + Arrays.toString(arr)); <span class="comment">// after sort: [1, 3, 5, 9, 10, 15]</span>
    }

}
</code></pre><h3 id="添加">添加</h3><p>在最大堆[ 15,10,9,7,5,3 ]上添加一个新的元素 11 ，执行的步骤如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/heap04.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<h3 id="删除">删除</h3><p>在最大堆[ 15,10,9,7,5,3 ]上删除元素 10 ，执行的步骤如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/heap05.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>堆的概念：</p>
<p>n个元素序列 { k1, k2, k3, k4, k5, k6 …. kn } 当且仅当满足以下关系时才会被称为堆：</p>
<pre><code>ki &lt;= k2i,ki &lt;= k2i+<span class="number">1</span> 或者 ki &gt;= k2i,ki &gt;= k2i+<span class="number">1</span> (i = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> .. n/<span class="number">2</span>)
</code></pre><p>如果数组的下表是从0开始，那么需要满足 </p>
<pre><code>ki &lt;= k2i+<span class="number">1</span>,ki &lt;= k2i+<span class="number">2</span> 或者 ki &gt;= k2i+<span class="number">1</span>,ki &gt;= k2i+<span class="number">2</span> (i = <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> .. n/<span class="number">2</span>)
</code></pre><p>比如 { 1,3,5,10,15,9 } 这个序列就满足 [1 &lt;= 3; 1 &lt;= 5],  [3 &lt;= 10; 3 &lt;= 15], [5 &lt;= 9] 这3个条件，这个序列就是一个堆。</p>
<p>所以堆其实是一个序列(数组)，如果这个序列满足上述条件，那么就把这个序列看成堆。</p>
<p>堆的实现通常是通过构造二叉堆，因为二叉堆应用很普遍，当不加限定时，堆通常指的就是二叉堆。</p>]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://fangjian0423.github.io/tags/algorithm/"/>
    
      <category term="algorithm" scheme="http://fangjian0423.github.io/categories/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk TreeSet工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/04/08/jdk_treeset/"/>
    <id>http://fangjian0423.github.io/2016/04/08/jdk_treeset/</id>
    <published>2016-04-07T16:20:23.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>TreeSet跟HashSet，LinkedHashSet一样，都是Set接口的实现类。</p>
<p>HashSet内部使用的HashMap，LinkedHashSet继承HashSet，内部使用的是LinkedHashMap。</p>
<p>TreeSet实现的是NavigableSet接口，而不是HashSet和LinkedHashSet实现的Set接口。</p>
<p>NavigableSet接口继承自SortedSet接口，SortedSet接口继承自Set接口。</p>
<p>NavigableSet接口比Set更方便，可以使用firstKey[最小关键字]，lastKey[最大关键字]，pollFirstEntry[最小键值对]，pollLastEntry[最大键值对]，higherEntry[比参数关键字要大的键值对]，lowerEntry[比参数关键字要小的键值对]等等方便方法，可以使用这些方法方便地获取期望位置上的键值对。</p>
<a id="more"></a>
<h2 id="TreeSet原理分析">TreeSet原理分析</h2><p>TreeSet跟HashSet一样，内部都使用Map，HashSet内部使用的是HashMap，但是TreeSet使用的是NavigableMap。</p>
<p>TreeSet的几个构造方法会构造NavigableMap，如果使用没有参数的构造函数，NavigableMap是TreeMap：</p>
<pre><code>TreeSet(NavigableMap&lt;E,Object&gt; m) {
    <span class="keyword">this</span>.m = m;
}

<span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>{
    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());
}

<span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>{
    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));
}
</code></pre><p>add方法调用Map的put方法：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{
    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;
}
</code></pre><p>remove方法调用Map的remove方法：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>{
    <span class="keyword">return</span> m.remove(o)==PRESENT;
}
</code></pre><p>原理基本跟HashSet一样。</p>
<pre><code><span class="comment">// 最小的关键字</span>
public <span class="keyword">E</span> first() {
    <span class="keyword">return</span> <span class="keyword">m</span>.firstKey();
}

<span class="comment">// 最大的关键字</span>
public <span class="keyword">E</span> last() {
    <span class="keyword">return</span> <span class="keyword">m</span>.lastKey();
}

<span class="comment">// 比参数小的关键字</span>
public <span class="keyword">E</span> <span class="literal">lower</span>(<span class="keyword">E</span> <span class="keyword">e</span>) {
    <span class="keyword">return</span> <span class="keyword">m</span>.lowerKey(<span class="keyword">e</span>);
}
</code></pre><h2 id="一个TreeSet例子">一个TreeSet例子</h2><p>使用没有参数的TreeMap构造函数，内部的Map使用TreeMap红黑树：</p>
<pre><code>TreeSet&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> TreeSet&lt;<span class="keyword">String</span>&gt;();
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"1:语文"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"2:数学"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"3:英语"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"4:政治"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"5:物理"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"6:化学"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"7:生物"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"8:体育"</span>);
</code></pre><p>内部红黑树结构如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treeset01.jpg" alt=""></p>
<p>还可以调用TreeSet的其他方法：</p>
<pre><code><span class="built_in">set</span>.<span class="keyword">first</span>();<span class="comment"> // 1:语文</span>
<span class="built_in">set</span>.<span class="keyword">last</span>();<span class="comment"> // 8:体育</span>
<span class="built_in">set</span>.higher(<span class="string">"5:物理"</span>);<span class="comment"> // 6:化学</span>
<span class="built_in">set</span>.<span class="built_in">lower</span>(<span class="string">"5:物理"</span>);<span class="comment"> // 4:政治</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>TreeSet跟HashSet，LinkedHashSet一样，都是Set接口的实现类。</p>
<p>HashSet内部使用的HashMap，LinkedHashSet继承HashSet，内部使用的是LinkedHashMap。</p>
<p>TreeSet实现的是NavigableSet接口，而不是HashSet和LinkedHashSet实现的Set接口。</p>
<p>NavigableSet接口继承自SortedSet接口，SortedSet接口继承自Set接口。</p>
<p>NavigableSet接口比Set更方便，可以使用firstKey[最小关键字]，lastKey[最大关键字]，pollFirstEntry[最小键值对]，pollLastEntry[最大键值对]，higherEntry[比参数关键字要大的键值对]，lowerEntry[比参数关键字要小的键值对]等等方便方法，可以使用这些方法方便地获取期望位置上的键值对。</p>]]>
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="set" scheme="http://fangjian0423.github.io/tags/set/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk TreeMap工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/04/07/jdk_treemap/"/>
    <id>http://fangjian0423.github.io/2016/04/07/jdk_treemap/</id>
    <published>2016-04-06T16:55:31.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>TreeMap是jdk中基于红黑树的一种map实现。HashMap底层是使用链表法解决冲突的哈希表，LinkedHashMap继承自HashMap，内部同样也是使用链表法解决冲突的哈希表，但是额外添加了一个双向链表用于处理元素的插入顺序或访问访问。</p>
<p>既然TreeMap底层使用的是红黑树，首先先来简单了解一下红黑树的定义。</p>
<p>红黑树是一棵平衡二叉查找树，同时还需要满足以下5个规则：</p>
<ol>
<li>每个节点只能是红色或者黑点</li>
<li>根节点是黑点</li>
<li>叶子节点(Nil节点，空节点)是黑色节点</li>
<li>如果一个节点是红色节点，那么它的两个子节点必须是黑色节点(一条路径上不能出现相邻的两个红色节点)</li>
<li>从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点</li>
</ol>
<p>红黑树的这些特性决定了它的查询、插入、删除操作的时间复杂度均为O(log n)。</p>
<a id="more"></a>
<h2 id="一个TreeMap例子">一个TreeMap例子</h2><p>一段TreeMap代码：</p>
<pre><code>TreeMap&lt;Integer, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();
treeMap.put(<span class="number">1</span>, <span class="string">"语文"</span>);
treeMap.put(<span class="number">2</span>, <span class="string">"数学"</span>);
treeMap.put(<span class="number">3</span>, <span class="string">"英语"</span>);
treeMap.put(<span class="number">4</span>, <span class="string">"政治"</span>);
treeMap.put(<span class="number">5</span>, <span class="string">"物理"</span>);
treeMap.put(<span class="number">6</span>, <span class="string">"化学"</span>);
treeMap.put(<span class="number">7</span>, <span class="string">"生物"</span>);
treeMap.put(<span class="number">8</span>, <span class="string">"体育"</span>);
</code></pre><p>执行过程：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap01.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>从上面这个例子看到，红黑树添加新节点的时候可能会对节点进行旋转，以保证树的局部平衡。</p>
<h2 id="TreeMap原理分析">TreeMap原理分析</h2><p>TreeMap内部类Entry表示红黑树中的节点：</p>
<pre><code><span class="keyword">static</span> <span class="keyword">final</span> class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    K <span class="variable">key</span>; <span class="comment">// 关键字</span>
    V value; <span class="comment">// 值</span>
    Entry&lt;K,V&gt; left; <span class="comment">// 左节点</span>
    Entry&lt;K,V&gt; right; <span class="comment">// 右节点</span>
    Entry&lt;K,V&gt; parent; <span class="comment">// 父节点</span>
    <span class="built_in">boolean</span> <span class="built_in">color</span> = BLACK; <span class="comment">// 颜色，默认为黑色</span>

    Entry(K <span class="variable">key</span>, V value, Entry&lt;K,V&gt; parent) {
        <span class="keyword">this</span>.<span class="variable">key</span> = <span class="variable">key</span>;
        <span class="keyword">this</span>.value = value;
        <span class="keyword">this</span>.parent = parent;
    }

    ...
}
</code></pre><p>TreeMap的属性：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root; <span class="comment">// 根节点</span>

<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> <span class="keyword">size</span> = <span class="number">0</span>; <span class="comment">// 节点个数</span>
</code></pre><h3 id="put操作">put操作</h3><p>红黑树新节点的添加一定是红色节点，添加完新的节点之后会进行旋转操作以保持红黑树的特性。</p>
<p>为什么新添加的节点一定是红色节点，如果添加的是黑色节点，那么就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的；但是如果插入的是红色节点，只需要解决其父节点也为红色节点的这个冲突即可。</p>
<p>以N为新插入节点，P为其父节点，U为其父节点的兄弟节点，R为P和U的父亲节点进行分析。如果N的父节点为黑色节点，那直接添加新节点即可，没有产生冲突。如果出现P节点是红色节点，那便产生冲突，可以分为以下几种冲突：</p>
<p>(1) P为红色节点，且U也为红色节点，P不论是R的左节点还是右节点</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap04.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>将P和U接口变成黑色节点，R节点变成红色节点。修改之后如果R节点的父节点也是红色节点，那么在R节点上执行相同操作，形成了一个递归过程。如果R节点是根节点的话，那么直接把R节点修改成黑色节点。</p>
<p>(2) P为红色节点，U为黑色节点或缺少，且N是P的右节点、P是R的左节点 或者 P为红色节点，U为黑色节点或缺少，且N是P的左节点、P是R的右节点</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap07.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>这两种情况分别对P进行左旋和右旋操作。操作结果就变成了冲突3。 (总结起来就是左右变左左，右左变右右)</p>
<p>(3) P为红色节点，U为黑色节点或缺少，且N是P的左节点、P是R的左节点 或者 P为红色节点，U为黑色节点或缺少，且N是P的右节点、P是R的右节点</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap08.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>这两种情况分别对祖父R进行右旋和左旋操作。完美解决冲突。(总结起来就是左左祖右，右右祖左)</p>
<p>这3个新增节点的冲突处理方法了解之后，我们回过头来看本文一开始的例子中添加最后一个[8:体育]节点是如何处理冲突的：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap09.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>接下来我们看TreeMap是如何实现新增节点并处理冲突的。</p>
<p>TreeMap对应的put方法：</p>
<pre><code><span class="keyword">public</span> V put(K <span class="variable">key</span>, V value) {
    Entry&lt;K,V&gt; t = root;
    <span class="keyword">if</span> (t == <span class="keyword">null</span>) { <span class="comment">// 如果根节点是空的，说明是第一次插入数据</span>
        compare(<span class="variable">key</span>, <span class="variable">key</span>);

        root = <span class="keyword">new</span> Entry&lt;&gt;(<span class="variable">key</span>, value, <span class="keyword">null</span>); <span class="comment">// 构造根节点，并赋值给属性root，默认颜色是黑色</span>
        <span class="built_in">size</span> = <span class="number">1</span>; <span class="comment">// 节点数 = 1</span>
        modCount++;
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
    <span class="built_in">int</span> cmp;
    Entry&lt;K,V&gt; parent;
    <span class="comment">// split comparator and comparable paths</span>
    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;
    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) { <span class="comment">// 比较器存在</span>
        do { <span class="comment">// 遍历寻找节点，关键字比节点小找左节点，比节点大的找右节点，直到找到那个叶子节点，会保存需要新构造节点的父节点到parent变量里</span>
            parent = t;
            cmp = cpr.compare(<span class="variable">key</span>, t.<span class="variable">key</span>);
            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)
                t = t.left;
            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)
                t = t.right;
            <span class="keyword">else</span>
                <span class="keyword">return</span> t.setValue(value); <span class="comment">// 关键字存在的话，直接用值覆盖原节点的关键字的值，并返回</span>
        } <span class="keyword">while</span> (t != <span class="keyword">null</span>);
    }
    <span class="keyword">else</span> { <span class="comment">// 比较器不存在</span>
        <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>)
            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
        @SuppressWarnings(<span class="string">"unchecked"</span>)
            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) <span class="variable">key</span>; <span class="comment">// 比较器不存在直接将关键字转换成比较器，如果关键字不是一个Comparable接口实现类，将会报错</span>
        do { <span class="comment">// 遍历寻找节点，关键字比节点小找左节点，比节点大的找右节点，直到找到那个叶子节点，会保存需要新构造节点的父节点到parent变量里</span>
            parent = t;
            cmp = k.compareTo(t.<span class="variable">key</span>);
            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)
                t = t.left;
            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)
                t = t.right;
            <span class="keyword">else</span>
                <span class="keyword">return</span> t.setValue(value); <span class="comment">// 关键字存在的话，直接用值覆盖原节点的关键字的值，并返回</span>
        } <span class="keyword">while</span> (t != <span class="keyword">null</span>);
    }
    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(<span class="variable">key</span>, value, parent); <span class="comment">// 构造新的关键字节点</span>
    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="comment">// 需要在左节点构造</span>
        parent.left = e;
    <span class="keyword">else</span> <span class="comment">// 需要在右节点构造</span>
        parent.right = e;
    fixAfterInsertion(e); <span class="comment">// 插入节点之后，处理冲突以保持树符合红黑树的特性</span>
    <span class="built_in">size</span>++;
    modCount++;
    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</code></pre><p>fixAfterInsertion方法处理红黑树冲突实现如下：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">void</span> fixAfterInsertion(Entry&lt;K,V&gt; x) {
    x.<span class="built_in">color</span> = RED; <span class="comment">// 新增的节点一定是红色节点</span>

    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.<span class="built_in">color</span> == RED) { <span class="comment">// P节点是红色节点并且N节点不是根节点的话一直循环</span>
        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) { <span class="comment">// P节点是R节点的左节点</span>
            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); <span class="comment">// y就是U节点</span>
            <span class="keyword">if</span> (colorOf(y) == RED) { <span class="comment">// 如果U节点是红色节点，说明P和U这两个节点都是红色节点，满足冲突(1)</span>
                setColor(parentOf(x), BLACK); <span class="comment">// 冲突(1)解决方案 把P设置为黑色</span>
                setColor(y, BLACK); <span class="comment">// 冲突(1)解决方案 把U设置为黑色</span>
                setColor(parentOf(parentOf(x)), RED); <span class="comment">// 冲突(1)解决方案 把R设置为红色</span>
                x = parentOf(parentOf(x)); <span class="comment">// 递归处理R节点</span>
            } <span class="keyword">else</span> { <span class="comment">// 如果U节点是黑色节点，满足冲突(2)或(3)</span>
                <span class="keyword">if</span> (x == rightOf(parentOf(x))) { <span class="comment">// 如果N节点是P节点的右节点，满足冲突(2)的第一种情况</span>
                    x = parentOf(x);
                    rotateLeft(x); <span class="comment">// P节点进行左旋操作</span>
                }
                <span class="comment">// P节点左旋操作之后，满足了冲突(3)的第一种情况或者N一开始就是P节点的左节点，这本来就是冲突(3)的第一种情况</span>
                setColor(parentOf(x), BLACK);  <span class="comment">// P节点和R节点交换颜色，P节点变成黑色</span>
                setColor(parentOf(parentOf(x)), RED); <span class="comment">// P节点和R节点交换颜色，R节点变成红色</span>
                rotateRight(parentOf(parentOf(x))); <span class="comment">// R节点右旋操作</span>
            }
        } <span class="keyword">else</span> { <span class="comment">// P节点是R节点的右节点</span>
            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); <span class="comment">// y就是U节点</span>
            <span class="keyword">if</span> (colorOf(y) == RED) { <span class="comment">// 如果U节点是红色节点，说明P和U这两个节点都是红色节点，满足冲突(1)</span>
                setColor(parentOf(x), BLACK); <span class="comment">// 冲突(1)解决方案 把P设置为黑色</span>
                setColor(y, BLACK); <span class="comment">// 冲突(1)解决方案 把U设置为黑色</span>
                setColor(parentOf(parentOf(x)), RED); <span class="comment">// 冲突(1)解决方案 把R设置为红色</span>
                x = parentOf(parentOf(x)); <span class="comment">// 递归处理R节点</span>
            } <span class="keyword">else</span> { <span class="comment">// 如果U节点是黑色节点，满足冲突(2)或(3)</span>
                <span class="keyword">if</span> (x == leftOf(parentOf(x))) { <span class="comment">// 如果N节点是P节点的左节点，满足冲突(2)的第二种情况</span>
                    x = parentOf(x);
                    rotateRight(x); <span class="comment">// P节点右旋</span>
                }
                <span class="comment">// P节点右旋操作之后，满足了冲突(3)的第二种情况或者N一开始就是P节点的右节点，这本来就是冲突(3)的第二种情况</span>
                setColor(parentOf(x), BLACK); <span class="comment">// P节点和R节点交换颜色，P节点变成黑色</span>
                setColor(parentOf(parentOf(x)), RED); <span class="comment">// P节点和R节点交换颜色，R节点变成红色</span>
                rotateLeft(parentOf(parentOf(x))); <span class="comment">// R节点左旋操作</span>
            }
        }
    }
    root.<span class="built_in">color</span> = BLACK; <span class="comment">// 根节点是黑色节点</span>
}
</code></pre><p>fixAfterInsertion方法的代码跟之前分析的冲突解决方案一模一样。</p>
<h3 id="get操作">get操作</h3><p>红黑树的get操作相比add操作简单不少，只需要比较关键字即可，要查找的关键字比节点关键字要小的话找左节点，否则找右节点，一直递归操作，直到找到或找不到。代码如下：</p>
<pre><code><span class="keyword">final</span> Entry&lt;K,V&gt; getEntry(<span class="keyword">Object</span> <span class="variable">key</span>) {
    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)
        <span class="keyword">return</span> getEntryUsingComparator(<span class="variable">key</span>);
    <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    @SuppressWarnings(<span class="string">"unchecked"</span>)
        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) <span class="variable">key</span>;
    Entry&lt;K,V&gt; p = root;
    <span class="keyword">while</span> (p != <span class="keyword">null</span>) {
        <span class="built_in">int</span> cmp = k.compareTo(p.<span class="variable">key</span>); <span class="comment">// 得到比较值</span>
        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="comment">// 小的话找左节点</span>
            p = p.left;
        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="comment">// 大的话找右节点</span>
            p = p.right;
        <span class="keyword">else</span>
            <span class="keyword">return</span> p;
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</code></pre><h3 id="remove操作">remove操作</h3><p>红黑树的删除节点跟添加节点一样，比较复杂，删除节点也会让树不符合红黑树的特性，也需要解决这些冲突。</p>
<p>删除操作分为2个步骤：</p>
<ol>
<li>将红黑树当作一颗二叉查找树，将节点删除</li>
<li>通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树</li>
</ol>
<p>步骤1的删除操作可分为几种情况：</p>
<ol>
<li>删除节点没有儿子：直接删除该节点</li>
<li>删除节点有1个儿子：删除该节点，并用该节点的儿子节点顶替它的位置</li>
<li>删除节点有2个儿子：可以转成成删除节点只有1个儿子的情况，跟二叉查找树一样，找出节点的右子树的最小元素(或者左子树的最大元素，这种节点称为后继节点)，并把它的值转移到删除节点，然后删除这个后继节点。这个后继节点最多只有1个子节点(如果有2个子节点，说明还能找出右子树更小的值)，所以这样删除2个儿子的节点就演变成了删除没有儿子的节点和删除只有1个儿子的节点的情况</li>
</ol>
<p>删除节点之后要考虑的问题就是红黑树失衡的调整问题。</p>
<p>步骤2遇到的调整问题只有2种情况：</p>
<ol>
<li>删除节点没有儿子节点</li>
<li>删除节点只有1个儿子节点</li>
</ol>
<p>删除节点没有儿子节点的话，直接把节点删除即可。如果节点是黑色节点，需要进行平衡性调整，否则，不用调整平衡性。这里的平衡性调整跟删除只有1个儿子节点一样，删除只有1个儿子的调整会先把节点删除，然后儿子节点顶上来，顶上来之后再进行平衡性调整。而删除没有儿子节点的节点的话，先进行调整，调整之后再把这个节点删除。他们的调整策略是一样的，只不过没有儿子节点的情况下先进行调整，然后再删除节点，而有儿子节点的情况下，先把节点删除，删除之后儿子节点顶上来，然后再做平衡性调整。</p>
<p>删除节点只有1个儿子节点还分几种情况：</p>
<ol>
<li>如果被删除的节点是红色节点，那说明它的父节点是黑色节点，儿子节点也是黑色节点，那么删除这个节点就不会影响红黑树的属性，直接使用它的黑色子节点代替它即可</li>
<li>如果被删除的节点是黑色节点，而它的儿子节点是红色节点。删除这个黑色节点之后，它的红色儿子节点顶替之后，会破坏性质5，只需要把儿子节点重绘为黑色节点即可，这样原先通过黑色删除节点的所有路径被现在的重绘后的儿子节点所代替</li>
<li>如果被删除的节点是黑色节点，而它的儿子节点也是黑色节点。这是一种复杂的情况，因为路径路过被删除节点的黑色节点路径少了1个，导致违反了性质5，所以需要对红黑树进行平衡调整。可分为以下几种情况进行调整：</li>
</ol>
<p>以N为删除节点的儿子节点(删除之后，处于新的位置上)，它的兄弟节点为S，它们的父节点为P，Sl和Sr为S节点的左右子节点为例，进行讲解，其中<strong>N是父节点P的左子节点</strong>，如果N是父节点P的右子节点，做对称处理。</p>
<p>3.1：N是新的根节点。这种情况下不用做任何处理，因为原先的节点也是一个根节点，相当于所有的路径都需要经过这个根节点，删除之后没有什么影响，而且新根也是黑色节点，符合所有特性，不需要进行调整</p>
<p>3.2: S节点是红色节点，那么P节点，Sl，Sr节点是黑色节点。在这种情况下，对P节点进行左选操作并且交换P和S的颜色。完成这2个操作之后，所有路径上的黑色节点没有变化，但是N节点有了一个黑色兄弟节点Sl和一个红色的父亲节点P，左子树删除节点后还有存在着少1个黑色节点路径的问题。接下来按照N节点新的位置(兄弟节点S是个黑色节点，父节点P是个红色节点)进行3.4、3.5或3.6情况处理<br><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap10.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>3.3：N的父亲节点P、兄弟节点S，还有S的两个子节点Sl，Sr均为黑色节点。在这种情况下，重绘S为红色。重绘之后路过S节点这边的路径跟N节点一样也少了一个黑色节点，但是出现了另外一个问题：不经过P节点的路径还是少了一个黑色节点。 接下来，要调整以P作为N递归调整树</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap11.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>3.4：S和S的儿子节点Sl、Sr为黑色节点，但是N的父亲节点P为红色节点。在这种情况下，交换N的兄弟S与父亲P的颜色，颜色交换之后左子树多了1个黑色节点路径，刚好填补了左子树删除节点的少一个黑色节点路径的问题，而右子树的黑色路径没有改变，解决平衡问题</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap12.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>3.5：S是黑色节点，S的左儿子节点Sl是红色，S的右儿子节点Sr是黑色节点。在这种情况下，在S上做右旋操作交换S和它新父亲的颜色。操作之后，左子树的黑色节点路径和右子树的黑色节点路径没有改变。但是现在N节点有了一个黑色的兄弟节点，黑色的兄弟节点有个红色的右儿子节点，满足了3.6的情况，按照3.6处理</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap13.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>3.6：S是黑色节点，S的右儿子节点Sr为红色节点，S的左儿子Sl是黑色节点，P是红色或黑色节点。在这种情况下，N的父亲P做左旋操作，交换N父亲P和S的颜色，S的右子节点Sr变成黑色。这样操作以后，左子树的黑色路径+1，补了删除节点的黑色路径，右子树黑色路径不变，解决平衡问题</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap14.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>了解了删除节点之后的平衡性调整之后，我们回过头来看本文一开始的例子进行节点删除的操作过程：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap15.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>TreeMap删除方法如下：</p>
<pre><code><span class="keyword">private</span> <span class="literal">void</span> deleteEntry(Entry&lt;K,V&gt; p) {
    modCount++;
    size--; <span class="comment">// 节点个数 -1</span>

    <span class="keyword">if</span> (p<span class="built_in">.</span>left != <span class="built_in">null</span> <span class="subst">&amp;&amp;</span> p<span class="built_in">.</span>right != <span class="built_in">null</span>) { <span class="comment">// 如果要删除的节点有2个子节点，去找后继节点</span>
        Entry&lt;K,V&gt; s = success<span class="subst">or</span>(p); <span class="comment">// 找出后继节点</span>
        p<span class="built_in">.</span>key = s<span class="built_in">.</span>key; <span class="comment">// 后继节点的关键字赋值给删除节点</span>
        p<span class="built_in">.</span>value = s<span class="built_in">.</span>value; <span class="comment">// 后继节点的值赋值给删除节点</span>
        p = s; <span class="comment">// 改为删除后继节点</span>
    }

    Entry&lt;K,V&gt; replacement = (p<span class="built_in">.</span>left != <span class="built_in">null</span> ? p<span class="built_in">.</span>left : p<span class="built_in">.</span>right); <span class="comment">// 找出替代节点，左子树存在的话使用左子树，否则使用右子树。这个替代节点就是被删除节点的左子节点或右子节点</span>

    <span class="keyword">if</span> (replacement != <span class="built_in">null</span>) { <span class="comment">// 替代节点如果存在的话</span>
        replacement<span class="built_in">.</span><span class="keyword">parent</span> = p<span class="built_in">.</span><span class="keyword">parent</span>; <span class="comment">// 删除要删除的节点</span>
        <span class="comment">// 有子节点的删除节点先删除节点，然后再做平衡性调整</span>
        <span class="keyword">if</span> (p<span class="built_in">.</span><span class="keyword">parent</span> == <span class="built_in">null</span>) <span class="comment">// 如果被删除节点的父节点为空，说明被删除节点是根节点</span>
            root = replacement; <span class="comment">// 用替代节点替代根节点</span>
        <span class="keyword">else</span> <span class="keyword">if</span> (p == p<span class="built_in">.</span><span class="keyword">parent</span><span class="built_in">.</span>left)
            p<span class="built_in">.</span><span class="keyword">parent</span><span class="built_in">.</span>left  = replacement; <span class="comment">// 用替代节点替代原先被删除的节点</span>
        <span class="keyword">else</span>
            p<span class="built_in">.</span><span class="keyword">parent</span><span class="built_in">.</span>right = replacement; <span class="comment">// 用替代节点替代原先被删除的节点</span>

        p<span class="built_in">.</span>left = p<span class="built_in">.</span>right = p<span class="built_in">.</span><span class="keyword">parent</span> = <span class="built_in">null</span>;

        <span class="keyword">if</span> (p<span class="built_in">.</span>col<span class="subst">or</span> == BLACK) <span class="comment">// 被删除节点如果是黑色节点，需要进行平衡性调整</span>
            fixAfterDeletion(replacement);
    } <span class="keyword">else</span> <span class="keyword">if</span> (p<span class="built_in">.</span><span class="keyword">parent</span> == <span class="built_in">null</span>) { <span class="comment">// 如果被删除节点的父节点为空，说明被删除节点是根节点</span>
        root = <span class="built_in">null</span>; <span class="comment">// 根节点的删除直接把根节点置空即可</span>
    } <span class="keyword">else</span> { <span class="comment">//   如果要删除的节点没有子节点</span>
        <span class="keyword">if</span> (p<span class="built_in">.</span>col<span class="subst">or</span> == BLACK) <span class="comment">// 如果要删除的节点是个黑色节点，需要进行平衡性调整</span>
            fixAfterDeletion(p); <span class="comment">// 调整平衡性，没有子节点的删除节点先进行平衡性调整</span>

        <span class="keyword">if</span> (p<span class="built_in">.</span><span class="keyword">parent</span> != <span class="built_in">null</span>) { <span class="comment">// 没有子节点的删除节点平衡性调整完毕之后再进行节点删除</span>
            <span class="keyword">if</span> (p == p<span class="built_in">.</span><span class="keyword">parent</span><span class="built_in">.</span>left)
                p<span class="built_in">.</span><span class="keyword">parent</span><span class="built_in">.</span>left = <span class="built_in">null</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (p == p<span class="built_in">.</span><span class="keyword">parent</span><span class="built_in">.</span>right)
                p<span class="built_in">.</span><span class="keyword">parent</span><span class="built_in">.</span>right = <span class="built_in">null</span>;
            p<span class="built_in">.</span><span class="keyword">parent</span> = <span class="built_in">null</span>;
        }
    }
}

<span class="comment">// 删除节点后的平衡性调整，对应之前分析的节点昵称，N、S、P、Sl、Sr</span>
<span class="keyword">private</span> <span class="literal">void</span> fixAfterDeletion(Entry&lt;K,V&gt; x) {
    <span class="keyword">while</span> (x != root <span class="subst">&amp;&amp;</span> colorOf(x) == BLACK) { <span class="comment">// N节点是黑色节点并且不是根节点就一直循环</span>
        <span class="keyword">if</span> (x == leftOf(parentOf(x))) { <span class="comment">// 如果N是P的左子节点</span>
            Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); <span class="comment">// sib就是N节点的兄弟节点S</span>

            <span class="keyword">if</span> (colorOf(sib) == RED) { <span class="comment">// 如果S节点是红色节点，满足删除冲突3.2，对P节点进行左旋操作并交换P和S的颜色</span>
                <span class="comment">// 交换P和S的颜色，S原先为红色，P原先为黑色(2个红色节点不能相连)</span>
                setCol<span class="subst">or</span>(sib, BLACK); <span class="comment">// S节点从红色变成黑色</span>
                setCol<span class="subst">or</span>(parentOf(x), RED); <span class="comment">// P节点从黑色变成红色</span>
                rotateLeft(parentOf(x)); <span class="comment">// 删除冲突3.2中P节点进行左旋</span>
                sib = rightOf(parentOf(x)); <span class="comment">// 左旋之后N节点有了一个黑色的兄弟节点和红色的父亲节点，S节点重新赋值成N节点现在的兄弟节点。接下来按照删除冲突3.4、3.5、3.6处理</span>
            }

            <span class="comment">// 执行到这里S节点一定是黑色节点，如果是红色节点，会按照冲突3.2交换成黑色节点</span>
            <span class="comment">// 如果S节点的左右子节点Sl、Sr均为黑色节点并且S节点也为黑色节点</span>
            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK <span class="subst">&amp;&amp;</span>
                colorOf(rightOf(sib)) == BLACK) {
                <span class="comment">// 按照删除冲突3.3和3.4进行处理</span>
                <span class="comment">// 如果是冲突3.3，说明P节点也是黑色节点</span>
                <span class="comment">// 如果是冲突3.4，说明P节点是红色节点，P节点和S节点需要交换颜色</span>
                <span class="comment">// 3.3和3.4冲突的处理结果S节点都为红色节点，但是3.4冲突处理完毕之后直接结束，而3.3冲突处理完毕之后继续调整</span>
                setCol<span class="subst">or</span>(sib, RED); <span class="comment">// S节点变成红色节点，如果是3.4冲突需要交换颜色，N节点的颜色交换在跳出循环进行</span>
                x = parentOf(x); <span class="comment">// N节点重新赋值成N节点的父节点P之后继续递归处理</span>
            } <span class="keyword">else</span> { <span class="comment">// S节点的2个子节点Sl，Sr中存在红色节点</span>
                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) { <span class="comment">// 如果S节点的右子节点Sr为黑色节点，Sl为红色节点[Sl如果为黑色节点的话就在上一个if逻辑里处理了]，满足删除冲突3.5</span>
                    <span class="comment">// 删除冲突3.5，对S节点做右旋操作，交换S和Sl的颜色，S变成红色节点，Sl变成黑色节点</span>
                    setCol<span class="subst">or</span>(leftOf(sib), BLACK); <span class="comment">// Sl节点变成黑色节点</span>
                    setCol<span class="subst">or</span>(sib, RED); <span class="comment">// S节点变成红色节点</span>
                    rotateRight(sib); <span class="comment">// S节点进行右旋操作</span>
                    sib = rightOf(parentOf(x)); <span class="comment">// S节点赋值现在N节点的兄弟节点</span>
                }
                <span class="comment">// 删除冲突3.5处理之后变成了删除冲突3.6或者一开始就是删除冲突3.6</span>
                <span class="comment">// 删除冲突3.6，P节点做左旋操作，P节点和S接口交换颜色，Sr节点变成黑色</span>
                setCol<span class="subst">or</span>(sib, colorOf(parentOf(x))); <span class="comment">// S节点颜色变成P节点颜色，红色</span>
                setCol<span class="subst">or</span>(parentOf(x), BLACK); <span class="comment">// P节点变成S节点颜色，也就是黑色</span>
                setCol<span class="subst">or</span>(rightOf(sib), BLACK); <span class="comment">// Sr节点变成黑色</span>
                rotateLeft(parentOf(x)); <span class="comment">// P节点做左旋操作</span>
                x = root; <span class="comment">// 准备跳出循环</span>
            }
        } <span class="keyword">else</span> { <span class="comment">// 如果N是P的右子节点，处理过程跟N是P的左子节点一样，左右对换即可</span>
            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));

            <span class="keyword">if</span> (colorOf(sib) == RED) {
                setCol<span class="subst">or</span>(sib, BLACK);
                setCol<span class="subst">or</span>(parentOf(x), RED);
                rotateRight(parentOf(x));
                sib = leftOf(parentOf(x));
            }

            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK <span class="subst">&amp;&amp;</span>
                colorOf(leftOf(sib)) == BLACK) {
                setCol<span class="subst">or</span>(sib, RED);
                x = parentOf(x);
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) {
                    setCol<span class="subst">or</span>(rightOf(sib), BLACK);
                    setCol<span class="subst">or</span>(sib, RED);
                    rotateLeft(sib);
                    sib = leftOf(parentOf(x));
                }
                setCol<span class="subst">or</span>(sib, colorOf(parentOf(x)));
                setCol<span class="subst">or</span>(parentOf(x), BLACK);
                setCol<span class="subst">or</span>(leftOf(sib), BLACK);
                rotateRight(parentOf(x));
                x = root;
            }
        }
    }

    setCol<span class="subst">or</span>(x, BLACK); <span class="comment">// 删除冲突3.4循环调出来之后N节点颜色设置为黑色 或者 删除节点只有1个红色子节点的时候，将顶上来的红色节点设置为黑色</span>
}
</code></pre><h2 id="参考资料">参考资料</h2><p><a href="http://dongxicheng.org/structure/red-black-tree/" target="_blank" rel="external">http://dongxicheng.org/structure/red-black-tree/</a></p>
<p><a href="http://blog.csdn.net/chenssy/article/details/26668941" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/26668941</a></p>
<p><a href="http://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91</a></p>
<p><a href="http://www.cnblogs.com/fanzhidongyzby/p/3187912.html" target="_blank" rel="external">http://www.cnblogs.com/fanzhidongyzby/p/3187912.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>TreeMap是jdk中基于红黑树的一种map实现。HashMap底层是使用链表法解决冲突的哈希表，LinkedHashMap继承自HashMap，内部同样也是使用链表法解决冲突的哈希表，但是额外添加了一个双向链表用于处理元素的插入顺序或访问访问。</p>
<p>既然TreeMap底层使用的是红黑树，首先先来简单了解一下红黑树的定义。</p>
<p>红黑树是一棵平衡二叉查找树，同时还需要满足以下5个规则：</p>
<ol>
<li>每个节点只能是红色或者黑点</li>
<li>根节点是黑点</li>
<li>叶子节点(Nil节点，空节点)是黑色节点</li>
<li>如果一个节点是红色节点，那么它的两个子节点必须是黑色节点(一条路径上不能出现相邻的两个红色节点)</li>
<li>从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点</li>
</ol>
<p>红黑树的这些特性决定了它的查询、插入、删除操作的时间复杂度均为O(log n)。</p>]]>
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="map" scheme="http://fangjian0423.github.io/tags/map/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk ArrayDeque工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/04/03/jdk_arraydeque/"/>
    <id>http://fangjian0423.github.io/2016/04/03/jdk_arraydeque/</id>
    <published>2016-04-02T16:43:59.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>ArrayDeque双向队列是jdk中列表的一种实现，支持元素在头和尾这两端进行插入和删除操作。</p>
<p>Deque接口(双向队列)的两个主要实现类是ArrayDeque和LinkedList。</p>
<p>其中ArrayDeque底层使用循环数组实现双向队列，而LinkedList是使用链接实现，之前在<a href="http://fangjian0423.github.io/2016/03/27/jdk_linkedlist/">jdk LinkedList工作原理分析</a>这篇文章中，已经分析过了LinkedList的实现原理，本文分析ArrayDeque的实现原理。</p>
<a id="more"></a>
<h2 id="一个ArrayDeque例子">一个ArrayDeque例子</h2><p>一段ArrayDeque代码：</p>
<pre><code>ArrayDeque&lt;<span class="keyword">String</span>&gt; arrayDeque = <span class="keyword">new</span> ArrayDeque&lt;<span class="keyword">String</span>&gt;(<span class="number">4</span>);
arrayDeque.<span class="built_in">add</span>(<span class="string">"1"</span>);
arrayDeque.<span class="built_in">add</span>(<span class="string">"2"</span>);
arrayDeque.<span class="built_in">add</span>(<span class="string">"3"</span>);
arrayDeque.addFirst(<span class="string">"0.5"</span>);
arrayDeque.<span class="built_in">add</span>(<span class="string">"4"</span>);
</code></pre><p>ArrayDeque内部使用的循环数组的容量，当首次进行初始化的时候，最小容量为8，如果超过8，扩大成2的幂。</p>
<pre><code><span class="comment">// 调用带有容量参数的构造函数后，数组初始化过程</span>
<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>{
    <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY; <span class="comment">// 最小容量为8</span>
    <span class="keyword">if</span> (numElements &gt;= initialCapacity) { <span class="comment">// 如果要分配的容量大于等于8，扩大成2的幂；否则使用最小容量8</span>
        initialCapacity = numElements;
        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);
        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);
        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);
        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);
        initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);
        initialCapacity++;

        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)
            initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;
    }
    elements = <span class="keyword">new</span> Object[initialCapacity]; <span class="comment">// 构造数组</span>
}
</code></pre><p>上面例子构造容量为4的数组，但是由于最小容量为8，所以构造的数组的容量是8。</p>
<p>执行过程如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/arraydeque01.jpg" alt=""></p>
<h2 id="ArrayDeque原理分析">ArrayDeque原理分析</h2><p>ArrayDeque使用的是循环数组，内部有3个属性，分别是：</p>
<pre><code><span class="built_in">Object</span>[] elements; <span class="comment">// 数组</span>
<span class="built_in">int</span> head; <span class="comment">// 头索引</span>
<span class="built_in">int</span> tail; <span class="comment">// 尾索引</span>
</code></pre><h3 id="add操作">add操作</h3><p>上面例子使用的add方法，其实内部使用了addLast方法，addLast也就添加数据到双向队列尾端：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>{
    <span class="keyword">if</span> (e == null)
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    elements[tail] = e; <span class="comment">// 根据尾索引，添加到尾端</span>
    <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head) <span class="comment">// 尾索引+1，如果尾索引和头索引重复了，说明数组满了，进行扩容</span>
        doubleCapacity();
}
</code></pre><p>addFirst方法跟addLast方法相反，添加数据到双向队列头端：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>{
    <span class="keyword">if</span> (e == null)
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e; <span class="comment">// 根据头索引，添加到头端，头索引-1</span>
    <span class="keyword">if</span> (head == tail) <span class="comment">// 如果头索引和尾索引重复了，说明数组满了，进行扩容</span>
        doubleCapacity();            
}
</code></pre><h3 id="remove操作">remove操作</h3><p>remove操作分别removeFirst和removeLast，removeLast代码如下：</p>
<pre><code>public E removeLast() {
    E x = pollLast(); // 调用pollLast方法
    <span class="keyword">if</span> (x == null)
        throw new <span class="type">NoSuchElementException</span>();
    <span class="keyword">return</span> x;
}

public E pollLast() {
    <span class="type">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>); // 尾索引 -<span class="number">1</span>
    @<span class="type">SuppressWarnings</span>(<span class="string">"unchecked"</span>)
    E <span class="literal">result</span> = (E) elements[t]; // 根据尾索引，得到尾元素
    <span class="keyword">if</span> (<span class="literal">result</span> == null)
        <span class="keyword">return</span> null;
    elements[t] = null; // 尾元素置空
    tail = t;
    <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre><p>removeFirst方法原理一样，remove头元素。 头索引 +1</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/arraydeque02.jpg" alt=""></p>
<h3 id="扩容">扩容</h3><p>ArrayDeque的扩容会把数组容量扩大2倍，同时还会重置头索引和尾索引，头索引置为0，尾索引置为原容量的值。</p>
<p>比如容量为8，扩容为16，头索引变成0，尾索引变成8。</p>
<p>扩容代码如下：</p>
<pre><code><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>{
    assert head == tail;
    <span class="keyword">int</span> p = head;
    <span class="keyword">int</span> n = elements.length;
    <span class="keyword">int</span> r = n - p;
    <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;
    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Sorry, deque too big"</span>);
    Object[] a = <span class="keyword">new</span> Object[newCapacity];
    System.arraycopy(elements, p, a, <span class="number">0</span>, r);
    System.arraycopy(elements, <span class="number">0</span>, a, r, p);
    elements = a;
    head = <span class="number">0</span>;  <span class="comment">// 头索引重置</span>
    tail = n;  <span class="comment">// 尾索引重置</span>
}
</code></pre><p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/arraydeque03.jpg" alt=""></p>
<h2 id="其他">其他</h2><p>Deque接口同时还附带了Stack的功能。</p>
<pre><code>ArrayDeque&lt;<span class="built_in">String</span>&gt; <span class="built_in">stack</span> = <span class="literal">new</span> ArrayDeque&lt;<span class="built_in">String</span>&gt;(<span class="number">4</span>);
<span class="built_in">stack</span><span class="built_in">.</span>push(<span class="string">"1"</span>);
<span class="built_in">stack</span><span class="built_in">.</span>push(<span class="string">"2"</span>);
<span class="built_in">stack</span><span class="built_in">.</span>push(<span class="string">"3"</span>);
<span class="built_in">String</span> pop = <span class="built_in">stack</span><span class="built_in">.</span>pop(); <span class="comment">// 3</span>
</code></pre><p>push方法内部调用addFirst方法，pop方法内部调用removeFirst方法。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/arraydeque04.jpg" alt=""></p>
<h2 id="注意点">注意点</h2><ol>
<li>ArrayDeque是一个使用循环数组实现的双向队列，LinkedList也是一个双向队列，不过它的底层实现是使用链表</li>
<li>ArrayDeque的扩容会把数组容量扩大2倍，同时还会重置头索引和尾索引</li>
<li>Deque双向队列接口同时也实现了Stack接口，可以把Deque当成Stack使用，它的速度比java.util.Stack要快，因为Stack底层操作数据会加锁，而Deque不会加锁</li>
<li>ArrayDeque不是一个线程安全的类</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>ArrayDeque双向队列是jdk中列表的一种实现，支持元素在头和尾这两端进行插入和删除操作。</p>
<p>Deque接口(双向队列)的两个主要实现类是ArrayDeque和LinkedList。</p>
<p>其中ArrayDeque底层使用循环数组实现双向队列，而LinkedList是使用链接实现，之前在<a href="http://fangjian0423.github.io/2016/03/27/jdk_linkedlist/">jdk LinkedList工作原理分析</a>这篇文章中，已经分析过了LinkedList的实现原理，本文分析ArrayDeque的实现原理。</p>]]>
    
    </summary>
    
      <category term="collection" scheme="http://fangjian0423.github.io/tags/collection/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk HashSet, LinkedHashSet工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/03/30/jdk_hashset_linkedhashset/"/>
    <id>http://fangjian0423.github.io/2016/03/30/jdk_hashset_linkedhashset/</id>
    <published>2016-03-29T16:46:33.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>Set是一个没有包括重复数据的集合，跟List一样，他们都继承自Collection。</p>
<p>Java中的Set接口最主要的实现类就是HashSet和LinkedHashSet。</p>
<a id="more"></a>
<h2 id="HashSet原理分析">HashSet原理分析</h2><p>首先看下HashSet的属性。</p>
<p>HashSet内部有个HashMap属性和一个对象属性：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">HashMap</span>&lt;E,<span class="keyword">Object</span>&gt; <span class="built_in">map</span>;

<span class="comment">// HashSet内部使用HashMap进行处理，由于Set只需要键值对中的键，而不需要值，所有的值都用这个对象</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span> PRESENT = <span class="keyword">new</span> <span class="keyword">Object</span>();
</code></pre><p>HashSet的构造函数中也提供了HashMap的capacity，loadFactor这些参数。</p>
<h3 id="add方法">add方法</h3><p>调用HashMap的put操作完成Set的add操作。</p>
<pre><code><span class="keyword">public</span> <span class="built_in">boolean</span> <span class="built_in">add</span>(E e) {
    <span class="keyword">return</span> <span class="built_in">map</span>.put(e, PRESENT)==<span class="keyword">null</span>;  <span class="comment">// HashMap put成功返回true，否则false</span>
}
</code></pre><p>HashMap相关的put操作在之前的博客中已经介绍过了，这里就不分析了。</p>
<h3 id="boolean_remove(Object_o)">boolean remove(Object o)</h3><p>调用HashMap的remove操作完成。</p>
<pre><code><span class="keyword">public</span> <span class="built_in">boolean</span> remove(<span class="keyword">Object</span> o) {
    <span class="keyword">return</span> <span class="built_in">map</span>.remove(o)==PRESENT; <span class="comment">// 对应的节点移除成功返回true，否则false</span>
}
</code></pre><h3 id="一个HashSet例子">一个HashSet例子</h3><pre><code>Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;<span class="keyword">String</span>&gt;(<span class="number">5</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"java"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"golang"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"python"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"ruby"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"scala"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"c"</span>);

<span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">str</span> : <span class="built_in">set</span>) {
    System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);
}
</code></pre><p>这个例子中set中的HashMap内部结构如下图所示：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/hashmap03.jpg" alt=""></p>
<h3 id="HashSet总结">HashSet总结</h3><ol>
<li>HashSet内部使用HashMap，HashSet集合内部所有的操作基本上都是基于HashMap完成的</li>
<li>HashSet中的元素是无序的，这是因为它内部使用HashMap进行存储，而HashMap添加键值对的时候是根据hash函数得到数组的下标的</li>
</ol>
<h2 id="LinkedHashSet原理分析">LinkedHashSet原理分析</h2><p>LinkedHashSet继承自HashSet，它的构造函数会调用父类HashSet的构造函数：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>{
    <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);
}

HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) {
    <span class="comment">// map使用LinkedHashMap构造，LinkedHashMap是HashMap的子类，accessOrder为false，即使用插入顺序</span>
    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);
}
</code></pre><h3 id="一个LinkedHashSet例子">一个LinkedHashSet例子</h3><pre><code>Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> LinkedHashSet&lt;<span class="keyword">String</span>&gt;(<span class="number">5</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"java"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"golang"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"python"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"ruby"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"scala"</span>);
<span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">str</span> : <span class="built_in">set</span>) {
    System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);
}
</code></pre><p>这个例子中set中的LinkedHashMap内部结构如下图所示：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/linkedhashmap02.jpg" alt=""></p>
<h3 id="LinkedHashSet总结">LinkedHashSet总结</h3><ol>
<li>LinkedHashSet继自HashSet，但是内部的map是使用LinkedHashMap构造的，并且accessOrder为false，使用查询顺序。所以LinkedHashSet遍历的顺序就是插入顺序。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Set是一个没有包括重复数据的集合，跟List一样，他们都继承自Collection。</p>
<p>Java中的Set接口最主要的实现类就是HashSet和LinkedHashSet。</p>]]>
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="set" scheme="http://fangjian0423.github.io/tags/set/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk LinkedHashMap工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/03/29/jdk_linkedhashmap/"/>
    <id>http://fangjian0423.github.io/2016/03/29/jdk_linkedhashmap/</id>
    <published>2016-03-29T11:23:23.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>LinkedHashMap是一种会记录插入顺序的Map，内部维护着一个accessOrder属性，用于表示map数据的迭代顺序是基于访问顺序还是插入顺序。</p>
<a id="more"></a>
<h2 id="LinkedHashMap原理分析">LinkedHashMap原理分析</h2><p>首先是LinkedHashMap的定义：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;
    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;
        <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>
</code></pre><p>LinkedHashMap继承HashMap，实现Map接口，所以它的结构跟HashMap是一样的，使用链表法解决哈希冲突的哈希表，基本操作跟HashMap也是一样的，就是多了一点额外的步骤用于处理链表。</p>
<p>LinkedHashMap有个内部类Entry，这个Entry就是链表中的节点，继承自HashMap.Node，多出了2个属性before和after，所以LinkedHashMap内部链表的节点是双向的，代码如下：</p>
<pre><code>static <span class="class"><span class="keyword">class</span> <span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">HashMap</span>.<span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> {</span>
    <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; before, after;
    <span class="type">Entry</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> value, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next) {
        <span class="keyword">super</span>(hash, key, value, next);
    }
}
</code></pre><p>另外LinkedHashMap还有两个重要的属性head，tail，这2个属性用于存储插入的节点，形成一个双向链表：</p>
<pre><code><span class="comment">// 首节点</span>
<span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;

<span class="comment">// 尾节点</span>
<span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;
</code></pre><p>跟HashMap一样，下面这个例子对应的LinkedHashMap结构图示如下所示，accessOrder为false，使用插入顺序：</p>
<pre><code>Map&lt;String, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> LinkedHashMap&lt;String, Integer&gt;(<span class="number">5</span>);
<span class="built_in">map</span>.put(<span class="string">"java"</span>, <span class="number">1</span>);
<span class="built_in">map</span>.put(<span class="string">"golang"</span>, <span class="number">2</span>);
<span class="built_in">map</span>.put(<span class="string">"python"</span>, <span class="number">3</span>);
<span class="built_in">map</span>.put(<span class="string">"ruby"</span>, <span class="number">4</span>);
<span class="built_in">map</span>.put(<span class="string">"scala"</span>, <span class="number">5</span>);
</code></pre><p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/linkedhashmap02.jpg" alt=""></p>
<h3 id="put操作">put操作</h3><p>LinkedHashMap没有覆盖HashMap的put方法，所以put操作跟HashMap是一样的。但是它覆盖了newNode方法，也就是说构造新节点的时候，LinkedHashMap跟HashMap是不一样的：</p>
<pre><code><span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; newNode(int hash, K key, V value, <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; e) {
    // 使用Entry双向链表构造节点，而不是HashMap的<span class="keyword">Node</span><span class="identifier"></span><span class="title">单向链表
    LinkedHashMap</span>.Entry<span class="tag">&lt;K,V&gt;</span> p =
        new LinkedHashMap.Entry<span class="tag">&lt;K,V&gt;</span>(hash, key, value, e);
    linkNodeLast(p); // 更新双向链表，这一操作在HashMap里面是没有的
    return p;
}
</code></pre><p>另外，LinkedHashMap重写了afterNodeInsertion这个钩子方法，在put一个关键字不存在的节点之后会调用这个方法：</p>
<pre><code><span class="keyword">void</span> afterNodeInsertion(<span class="built_in">boolean</span> evict) { <span class="comment">// possibly remove eldest</span>
    LinkedHashMap.Entry&lt;K,V&gt; first;
    <span class="comment">// removeEldestEntry方法LinkedHashMap永远返回false，一些使用缓存策略的Map会覆盖这个方法，比如jackson的LRUMap，会移除最老的节点，也就是首节点</span>
    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) {
        K <span class="variable">key</span> = first.<span class="variable">key</span>;
        removeNode(hash(<span class="variable">key</span>), <span class="variable">key</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);
    }
}
</code></pre><p>put操作如果关键字已经存在，会调用afterNodeAccess这个钩子方法：</p>
<pre><code><span class="label">void</span> afterNodeAccess(Node&lt;K,V&gt; e) { // <span class="keyword">move </span>node to last
    LinkedHashMap.Entry&lt;K,V&gt; last<span class="comment">;</span>
    <span class="preprocessor">if</span> (accessOrder &amp;&amp; (last = tail) != e) { // 如果使用访问顺序并且访问的不是尾节点
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, <span class="keyword">b </span>= p.<span class="keyword">before, </span>a = p.after<span class="comment">;</span>
        p.after = null<span class="comment">;</span>
        <span class="preprocessor">if</span> (<span class="keyword">b </span>== null)
            head = a<span class="comment">;</span>
        <span class="preprocessor">else</span>
            <span class="keyword">b.after </span>= a<span class="comment">;</span>
        <span class="preprocessor">if</span> (a != null)
            a.<span class="keyword">before </span>= <span class="keyword">b;
</span>        <span class="preprocessor">else</span>
            last = <span class="keyword">b;
</span>        <span class="preprocessor">if</span> (last == null)
            head = p<span class="comment">;</span>
        <span class="preprocessor">else</span> {
            p.<span class="keyword">before </span>= last<span class="comment">;</span>
            last.after = p<span class="comment">;</span>
        }
        tail = p<span class="comment">;</span>
        ++modCount<span class="comment">;</span>
    }
}
</code></pre><h3 id="get操作">get操作</h3><p>LinkedHashMap复写了get方法：</p>
<pre><code><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="variable">key</span>) {
    Node&lt;K,V&gt; e;
    <span class="keyword">if</span> ((e = getNode(hash(<span class="variable">key</span>), <span class="variable">key</span>)) == <span class="keyword">null</span>)
        <span class="keyword">return</span> <span class="keyword">null</span>;
    <span class="keyword">if</span> (accessOrder) <span class="comment">// 使用访问顺序的话，调用afterNodeAccess方法</span>
        afterNodeAccess(e);
    <span class="keyword">return</span> e.value;
}
</code></pre><h3 id="remove操作">remove操作</h3><p>LinkedHashMap的remove方法没有复写HashMap的remove方法，但是同样实现了afterNodeRemoval这个钩子方法：</p>
<pre><code>// 更新双向链表
<span class="label">void</span> afterNodeRemoval(Node&lt;K,V&gt; e) { // unlink
    LinkedHashMap.Entry&lt;K,V&gt; p =
        (LinkedHashMap.Entry&lt;K,V&gt;)e, <span class="keyword">b </span>= p.<span class="keyword">before, </span>a = p.after<span class="comment">;</span>
    p.<span class="keyword">before </span>= p.after = null<span class="comment">;</span>
    <span class="preprocessor">if</span> (<span class="keyword">b </span>== null)
        head = a<span class="comment">;</span>
    <span class="preprocessor">else</span>
        <span class="keyword">b.after </span>= a<span class="comment">;</span>
    <span class="preprocessor">if</span> (a == null)
        tail = <span class="keyword">b;
</span>    <span class="preprocessor">else</span>
        a.<span class="keyword">before </span>= <span class="keyword">b;
</span>}
</code></pre><h3 id="accessOrder属性分析">accessOrder属性分析</h3><p>LinkedHashMap默认情况下，accessOrder属性为false，也就是使用插入顺序，这个插入顺序是根据LinkedHashMap内部的一个双向链表实现的。如果accessOrder为true，也就是使用访问顺序，那么afterNodeAccess这个钩子方法内部的逻辑会被执行，将会修改双向链表的结构，再来看一下这个方法的具体逻辑：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>{ <span class="comment">// move node to last</span>
    LinkedHashMap.Entry&lt;K,V&gt; last;
    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) { <span class="comment">// 使用访问顺序，把节点移动到双向链表的最后面，如果已经在最后面了，不需要进行移动</span>
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        p.after = <span class="keyword">null</span>;
        <span class="keyword">if</span> (b == <span class="keyword">null</span>)
            head = a; <span class="comment">// 特殊情况，处理头节点</span>
        <span class="keyword">else</span>
            b.after = a; <span class="comment">// 节点处理</span>
        <span class="keyword">if</span> (a != <span class="keyword">null</span>)
            a.before = b; <span class="comment">// 节点处理</span>
        <span class="keyword">else</span>
            last = b; <span class="comment">// 特殊情况，处理尾节点</span>
        <span class="keyword">if</span> (last == <span class="keyword">null</span>)
            head = p;
        <span class="keyword">else</span> {
            p.before = last; <span class="comment">// 尾节点处理</span>
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}
</code></pre><p>afterNodeAccess在使用get方法或者put方法遇到关键字已经存在的情况下，会被触发，一个例子如下：</p>
<pre><code>Map&lt;String, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> LinkedHashMap&lt;String, Integer&gt;(<span class="number">5</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);
<span class="built_in">map</span>.put(<span class="string">"java"</span>, <span class="number">1</span>);
<span class="built_in">map</span>.put(<span class="string">"golang"</span>, <span class="number">2</span>);
<span class="built_in">map</span>.put(<span class="string">"python"</span>, <span class="number">3</span>);
<span class="built_in">map</span>.put(<span class="string">"ruby"</span>, <span class="number">4</span>);
<span class="built_in">map</span>.put(<span class="string">"scala"</span>, <span class="number">5</span>);
System.out.println(<span class="built_in">map</span>.get(<span class="string">"ruby"</span>));
</code></pre><p>上面这段代码，LinkedHashMap的accessOrder属性为true，使用访问顺序，最后调用了get方法，触发afterNodeAccess方法，修改双向链表，效果如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/linkedhashmap03.jpg" alt=""></p>
<h2 id="注意点">注意点</h2><p>LinkedHashMap使用访问顺序并且进行遍历的时候，如果使用如下代码，会发生ConcurrentModificationException异常：</p>
<pre><code><span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">str</span> : <span class="built_in">map</span>.keySet()) {
    System.out.<span class="built_in">println</span>(<span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">str</span>));
}
</code></pre><p>不应该这么使用，而是应该直接读取value：</p>
<pre><code><span class="function">for</span>(Integer it <span class="value">: map.<span class="function">values</span>()) {
    System.out.<span class="function">println</span>(it);</span>
}
</code></pre><p>具体可以参考<a href="http://stackoverflow.com/questions/16180568/concurrentmodificationexception-with-linkedhashmap" target="_blank" rel="external">stackoverflow上的这篇帖子</a>。</p>
<h2 id="总结">总结</h2><ol>
<li><p>LinkedHashMap也是一种使用拉链式哈希表的数据结构，除了哈希表，它内部还维护着一个双向链表，用于处理访问顺序和插入顺序的问题</p>
</li>
<li><p>LinkedHashMap继承自HashMap，大多数的方法都是跟HashMap一样的，不过覆盖了一些方法</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>LinkedHashMap是一种会记录插入顺序的Map，内部维护着一个accessOrder属性，用于表示map数据的迭代顺序是基于访问顺序还是插入顺序。</p>]]>
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="map" scheme="http://fangjian0423.github.io/tags/map/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk HashMap工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/03/29/jdk_hashmap/"/>
    <id>http://fangjian0423.github.io/2016/03/29/jdk_hashmap/</id>
    <published>2016-03-28T17:49:58.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>Map是一个映射键和值的对象。类似于Python中的字典。</p>
<p>HashMap为什么会出现呢?</p>
<p>因为数组这种数据结构，虽然遍历简单，但是插入和删除操作复杂，需要移动数组内部的元素；链表这种数据结构，插入和删除操作简单，但是查找复杂，只能一个一个地遍历。</p>
<p>有没有一种新的数据结构，插入数据简单，同时查找也简单？ 这个时候就出现了哈希表这种数据结构。 这是一种折中的方式，插入没链表快，查询没数组快。</p>
<p>wiki上就是这么定义哈希表的：</p>
<p>散列表（Hash table，也叫哈希表），是根据关键字（Key value）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p>
<a id="more"></a>
<p>有几个概念要解释一下：</p>
<ol>
<li>如果有1个关键字为k，它是通过一种函数f(k)得到散列表的地址，然后把值放到这个地址上。这个函数f就称为散列函数，也叫哈希函数。</li>
<li>对于不同的关键字，得到了同一地址，即k1 != k2，但是f(k1) = f(k2)。这种现象称为冲突，</li>
<li>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数</li>
</ol>
<p>散列函数有好几种实现，分别有直接定址法、随机数法、除留余数法等，在<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="external">wiki散列表</a>上都有介绍。</p>
<p>散列表的冲突解决方法，也有好几种，有开放定址法、单独链表法、再散列等。</p>
<p>Java中的HashMap采用的冲突解决方法是使用单独链表法，如下图所示：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/hashmap01.png" alt=""></p>
<h2 id="HashMap原理分析">HashMap原理分析</h2><p>HashMap是jdk中Map接口的实现类之一，是一个散列表的实现。</p>
<p>HashMap中的key和value都可以为null，且它的方法都没有synchronized。 其他方法的实现大部分跟HashTable一致。HashTable的相关源码不在这里介绍，基本上跟HashTable一致。</p>
<p>HashMap有个内部静态类Node，这个Node就是为了解决冲突而设计的链表中的节点的概念。它有4个属性，hash表示哈希地址，key表示关键字，value表示值, next表示这个节点的下一个节点，是一个单项链表：</p>
<pre><code>static class <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; implements Map.Entry<span class="tag">&lt;K,V&gt;</span> {
    final int hash;
    final K key;
    V value;
    <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; next;

    <span class="keyword">Node</span><span class="identifier"></span><span class="title">(int</span> hash, K key, V value, <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }

    ...
}
</code></pre><h3 id="在分析HashMap源码之前，先看一个HashMap使用例子">在分析HashMap源码之前，先看一个HashMap使用例子</h3><pre><code>Map&lt;String, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;(<span class="number">5</span>);
<span class="built_in">map</span>.put(<span class="string">"java"</span>, <span class="number">1</span>);
<span class="built_in">map</span>.put(<span class="string">"golang"</span>, <span class="number">2</span>);
<span class="built_in">map</span>.put(<span class="string">"python"</span>, <span class="number">3</span>);
<span class="built_in">map</span>.put(<span class="string">"ruby"</span>, <span class="number">4</span>);
<span class="built_in">map</span>.put(<span class="string">"scala"</span>, <span class="number">5</span>);
</code></pre><p>上面这段代码执行之后会生成下面这张哈希表。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/hashmap05.jpg" alt=""></p>
<p>至于为什么会生成这样的哈希表，会在后面分析源码中讲解。</p>
<h3 id="HashMap的属性">HashMap的属性</h3><p>HashMap的几个重要的属性:</p>
<pre><code><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">// 哈希表数组</span>

<span class="keyword">transient</span> <span class="keyword">int</span> <span class="keyword">size</span>; <span class="comment">// 键值对个数</span>

<span class="keyword">int</span> threshold; <span class="comment">// 阀值。 值 = 容量 * 加载因子。默认值为12(16(默认容量) * 0.75(默认加载因子))。当哈希表中的键值对个数超过该值时，会进行扩容</span>

<span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">// 加载因子，默认是0.75</span>
</code></pre><p>有2个重要的特性影响着HashMap的性能，分别是capacity(容量)和load factor(加载因子)。</p>
<p>其中capacity表示哈希表bucket的数量，HashMap的默认值是16。load factor加载因子表示当一个map填满了达到这个比例之后的bucket时候，和ArrayList一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程也叫做重哈希。默认的load factor为0.75 。</p>
<h3 id="HashMap的操作">HashMap的操作</h3><p>分析一下HashMapput键值对的过程，是如何找到bucket的，遇到哈希冲突的时候是如何使用链表法的。</p>
<h4 id="put操作">put操作</h4><pre><code><span class="keyword">public</span> V put(K <span class="variable">key</span>, V value) {
    <span class="comment">// 第一个参数就是关键字key的哈希值</span>
    <span class="keyword">return</span> putVal(hash(<span class="variable">key</span>), <span class="variable">key</span>, value, <span class="keyword">false</span>, <span class="keyword">true</span>);
}

<span class="keyword">final</span> V putVal(<span class="built_in">int</span> hash, K <span class="variable">key</span>, V value, <span class="built_in">boolean</span> onlyIfAbsent,
               <span class="built_in">boolean</span> evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="built_in">int</span> n, i;
    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)
        n = (tab = resize()).length; <span class="comment">// 哈希表是空的话，重新构建，进行扩容</span>
    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)
        tab[i] = newNode(hash, <span class="variable">key</span>, value, <span class="keyword">null</span>); <span class="comment">// 没有hash冲突的话，直接在对应位置上构造一个新的节点即可</span>
    <span class="keyword">else</span> { <span class="comment">// 如果哈希表当前位置上已经有节点的话，说明有hash冲突</span>
        Node&lt;K,V&gt; e; K k;
        <span class="comment">// 关键字跟哈希表上的首个节点济宁比较</span>
        <span class="keyword">if</span> (p.hash == hash &amp;&amp;
            ((k = p.<span class="variable">key</span>) == <span class="variable">key</span> || (<span class="variable">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="variable">key</span>.equals(k))))
            e = p;
        <span class="comment">// 如果使用的是红黑树，用红黑树的方式进行处理</span>
        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, <span class="variable">key</span>, value);
        <span class="keyword">else</span> { <span class="comment">// 跟链表进行比较</span>
            <span class="keyword">for</span> (<span class="built_in">int</span> binCount = <span class="number">0</span>; ; ++binCount) {
                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) { <span class="comment">// 一直遍历链表，直到找到最后一个</span>
                    p.next = newNode(hash, <span class="variable">key</span>, value, <span class="keyword">null</span>); <span class="comment">// 构造链表上的新节点</span>
                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span>
                        treeifyBin(tab, hash);
                    <span class="keyword">break</span>;
                }
                <span class="keyword">if</span> (e.hash == hash &amp;&amp;
                    ((k = e.<span class="variable">key</span>) == <span class="variable">key</span> || (<span class="variable">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="variable">key</span>.equals(k))))
                    <span class="keyword">break</span>;
                p = e;
            }
        }
        <span class="keyword">if</span> (e != <span class="keyword">null</span>) { <span class="comment">// 如果找到了节点，说明关键字相同，进行覆盖操作，直接返回旧的关键字的值</span>
            V oldValue = e.value;
            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)
                e.value = value;
            afterNodeAccess(e);
            <span class="keyword">return</span> oldValue;
        }
    }
    ++modCount;
    <span class="keyword">if</span> (++<span class="built_in">size</span> &gt; threshold) <span class="comment">// 如果目前键值对个数已经超过阀值，重新构建</span>
        resize();
    afterNodeInsertion(evict); <span class="comment">// 节点插入以后的钩子方法</span>
    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</code></pre><h4 id="get操作">get操作</h4><p>get操作关键点就是怎么在哈希表上取数据，理解了put操作之后，get方法很容易理解了：</p>
<pre><code><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="variable">key</span>) {
    Node&lt;K,V&gt; e;
    <span class="keyword">return</span> (e = getNode(hash(<span class="variable">key</span>), <span class="variable">key</span>)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;
}
</code></pre><p>getNode方法就说明了如何取数据：</p>
<pre><code><span class="keyword">final</span> Node&lt;K,V&gt; getNode(<span class="built_in">int</span> hash, <span class="keyword">Object</span> <span class="variable">key</span>) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="built_in">int</span> n; K k;
    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;
        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) { <span class="comment">// 如果哈希表容量为0或者关键字没有命中，直接返回null</span>
        <span class="keyword">if</span> (first.hash == hash &amp;&amp;  <span class="comment">// 关键字命中的话比较第一个节点</span>
            ((k = first.<span class="variable">key</span>) == <span class="variable">key</span> || (<span class="variable">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="variable">key</span>.equals(k)))) 
            <span class="keyword">return</span> first;
        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) {
            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 以红黑树的方式查找</span>
                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, <span class="variable">key</span>);
            do { <span class="comment">// 遍历链表查找</span>
                <span class="keyword">if</span> (e.hash == hash &amp;&amp;
                    ((k = e.<span class="variable">key</span>) == <span class="variable">key</span> || (<span class="variable">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="variable">key</span>.equals(k))))
                    <span class="keyword">return</span> e;
            } <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);
        }
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</code></pre><h4 id="hash过程和resize过程分析">hash过程和resize过程分析</h4><p>hash过程在HashMap里就是一个hash方法：</p>
<pre><code><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> hash(<span class="keyword">Object</span> <span class="variable">key</span>) {
    <span class="built_in">int</span> h;
    <span class="comment">// 使用hashCode的值和hashCode的值无符号右移16位做异或操作</span>
    <span class="keyword">return</span> (<span class="variable">key</span> == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = <span class="variable">key</span>.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);
}
</code></pre><p>这段代码是什么意思呢？ 我们以文中的那个demo为例，说明”java”这个关键字是如何找到对应bucket的过程。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/hashmap06.jpg" alt=""></p>
<p>从上图可以看到，hash方法得到的hash值是根据关键字的hashCode的高16位和低16位进行异或操作得到的一个值。</p>
<p>这个值再与哈希表容量-1值进行与操作得到最终的bucket索引值。</p>
<pre><code><span class="list">(<span class="keyword">n</span> - <span class="number">1</span>)</span> &amp; hash
</code></pre><p>hashCode的高16位与低16位进行异或操作主要是设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)来做的。</p>
<p>如果链表的数量大了，HashMap会把哈希表转换成红黑树来进行处理，本文不讨论这部分内容。</p>
<p>现在回过头来看例子，为什么初始化了一个容量为5的HashMap，但是哈希表的容量为8，而且阀值为6？</p>
<p>因为HashMap的构造函数初始化threshold的时候调用了tableSizeFor方法，这个方法会把容量改成2的幂的整数，主要是为了哈希表散列更均匀。</p>
<pre><code><span class="comment">// 定位bucket索引的最后操作。如果n为奇数，n-1就是偶数，偶数的话转成二进制最后一位是0，相反如果是奇数，最后一位是1，这样产生的索引值将更均匀</span>
(n - <span class="number">1</span>) &amp; hash
</code></pre><p>tableSizeFor方法如下：</p>
<pre><code>this.threshold = tableSizeFor(initialCapacity);

<span class="comment">// 保证thresold为2的幂</span>
static final int tableSizeFor(int <span class="keyword">cap</span>) {
    int <span class="keyword">n</span> = <span class="keyword">cap</span> - 1;
    <span class="keyword">n</span> |= <span class="keyword">n</span> &gt;&gt;&gt; 1;
    <span class="keyword">n</span> |= <span class="keyword">n</span> &gt;&gt;&gt; 2;
    <span class="keyword">n</span> |= <span class="keyword">n</span> &gt;&gt;&gt; 4;
    <span class="keyword">n</span> |= <span class="keyword">n</span> &gt;&gt;&gt; 8;
    <span class="keyword">n</span> |= <span class="keyword">n</span> &gt;&gt;&gt; 16;
    <span class="keyword">return</span> (<span class="keyword">n</span> &lt; 0) ? 1 : (<span class="keyword">n</span> &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : <span class="keyword">n</span> + 1;
}
</code></pre><p>阀值为6是因为之后进行resize操作的时候更新了阀值</p>
<pre><code>阀值 = 容量 * 加载因子 = <span class="number">8</span> * <span class="number">0.75</span> = <span class="number">6</span>
</code></pre><p>HashMap的扩容会把原先哈希表的容量扩大两倍。扩大之后，会对节点重新进行处理。</p>
<p>哈希表上的节点的状态有3种，分别是单节点，无节点，链表，扩容对于这3种状态的处理方式如下：</p>
<p>以8节点为原先容量，扩容为16容量讲解。</p>
<ol>
<li>单节点：由于容量扩大两倍，相当于左移1位。扩容前与00000111[7，n - 1 = 8 - 1]进行与操作。扩容后与00001111[15, n - 1 = 16 - 1]进行与操作。所以最终的结果要是还是在原位置，要么在原位置 +8(+old capacity) 位置</li>
<li>无节点：不处理</li>
<li>链表：遍历各个节点，每个节点的处理方式跟单节点一样，结果分成2种，还在原位置和原位置 +8 位置</li>
</ol>
<p>单节点处理示意图如下，这么设计的原因就是不需要再次计算hash值，只需要移动位置(+old capacity)即可：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/hashmap07.jpg" alt="">   </p>
<p>下图是一个HashMap扩容之后的效果图（省去了索引为7橙色链表的虚线，太多线条了）：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/hashmap08.jpg" alt="">   </p>
<p>哈希表扩容是使用resize方法完成：</p>
<pre><code><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() {
    Node&lt;K,V&gt;[] oldTab = table;
    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;
    <span class="keyword">int</span> oldThr = threshold;
    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;
    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) { <span class="comment">// 如果老容量大于0，说明哈希表中已经有数据了，然后进行扩容</span>
        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) { <span class="comment">// 超过最大容量的话，不扩容</span>
            threshold = Integer.MAX_VALUE;
            <span class="keyword">return</span> oldTab;
        }
        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; <span class="comment">// 容量加倍</span>
                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) <span class="comment">// 如果老的容量超过默认容量的话</span>
            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 阀值加倍</span>
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 根据thresold初始化数组</span>
        newCap = oldThr;
    <span class="keyword">else</span> {               <span class="comment">// 使用默认配置</span>
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    <span class="keyword">if</span> (newThr == <span class="number">0</span>) {
        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?
                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>})
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];
    table = newTab;
    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) {
        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) { <span class="comment">// 扩容之后进行rehash操作</span>
            Node&lt;K,V&gt; e;
            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) {
                oldTab[j] = <span class="keyword">null</span>;
                <span class="keyword">if</span> (e.<span class="keyword">next</span> == <span class="keyword">null</span>)
                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">// 单节点扩容</span>
                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap); <span class="comment">// 红黑树方式处理</span>
                <span class="keyword">else</span> { <span class="comment">// 链表扩容</span>
                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;
                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;
                    Node&lt;K,V&gt; <span class="keyword">next</span>;
                    <span class="keyword">do</span> {
                        <span class="keyword">next</span> = e.<span class="keyword">next</span>;
                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) {
                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)
                                loHead = e;
                            <span class="keyword">else</span>
                                loTail.<span class="keyword">next</span> = e;
                            loTail = e;
                        } 
                        <span class="keyword">else</span> {
                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)
                                hiHead = e;
                            <span class="keyword">else</span>
                                hiTail.<span class="keyword">next</span> = e;
                            hiTail = e;
                        }
                    } <span class="keyword">while</span> ((e = <span class="keyword">next</span>) != <span class="keyword">null</span>);
                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) {
                        loTail.<span class="keyword">next</span> = <span class="keyword">null</span>;
                        newTab[j] = loHead;
                    }
                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) {
                        hiTail.<span class="keyword">next</span> = <span class="keyword">null</span>;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    <span class="keyword">return</span> newTab;
}
</code></pre><h2 id="HashMap注意的地方">HashMap注意的地方</h2><ol>
<li>HashMap底层是个哈希表，使用拉链法解决冲突</li>
<li>HashMap内部存储的数据是无序的，这是因为HashMap内部的数组的下表是根据hash值算出来的</li>
<li>HashMap允许key为null</li>
<li>HashMap不是一个线程安全的类</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Map是一个映射键和值的对象。类似于Python中的字典。</p>
<p>HashMap为什么会出现呢?</p>
<p>因为数组这种数据结构，虽然遍历简单，但是插入和删除操作复杂，需要移动数组内部的元素；链表这种数据结构，插入和删除操作简单，但是查找复杂，只能一个一个地遍历。</p>
<p>有没有一种新的数据结构，插入数据简单，同时查找也简单？ 这个时候就出现了哈希表这种数据结构。 这是一种折中的方式，插入没链表快，查询没数组快。</p>
<p>wiki上就是这么定义哈希表的：</p>
<p>散列表（Hash table，也叫哈希表），是根据关键字（Key value）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p>]]>
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="map" scheme="http://fangjian0423.github.io/tags/map/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
</feed>
