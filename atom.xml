<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Format&#39;s Notes</title>
  <subtitle>吃饭睡觉撸代码</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fangjian0423.github.io/"/>
  <updated>2017-05-02T02:21:15.000Z</updated>
  <id>http://fangjian0423.github.io/</id>
  
  <author>
    <name>Format</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot源码分析之SpringBoot的启动过程</title>
    <link href="http://fangjian0423.github.io/2017/04/30/springboot-startup-analysis/"/>
    <id>http://fangjian0423.github.io/2017/04/30/springboot-startup-analysis/</id>
    <published>2017-04-30T12:33:33.000Z</published>
    <updated>2017-05-02T02:21:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot的启动很简单，代码如下：</p>
<pre><code>@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
</code></pre><p>从代码上可以看出，调用了SpringApplication的静态方法run。这个run方法会构造一个SpringApplication的实例，然后再调用这里实例的run方法就表示启动SpringBoot。</p>
<p>因此，想要分析SpringBoot的启动过程，我们需要熟悉SpringApplication的构造过程以及SpringApplication的run方法执行过程即可。</p>
<p>我们以上述这段代码为例，分析SpringBoot的启动过程。</p>
<a id="more"></a>
<h2 id="SpringApplication的构造过程"><a href="#SpringApplication的构造过程" class="headerlink" title="SpringApplication的构造过程"></a>SpringApplication的构造过程</h2><p>SpringApplication构造的时候内部会调用一个private方法initialize：</p>
<pre><code>public SpringApplication(Object... sources) {
  initialize(sources); // sources目前是一个MyApplication的class对象
}

private void initialize(Object[] sources) {
  if (sources != null &amp;&amp; sources.length &gt; 0) {
    this.sources.addAll(Arrays.asList(sources)); // 把sources设置到SpringApplication的sources属性中，目前只是一个MyApplication类对象
  }
  this.webEnvironment = deduceWebEnvironment(); // 判断是否是web程序(javax.servlet.Servlet和org.springframework.web.context.ConfigurableWebApplicationContext都必须在类加载器中存在)，并设置到webEnvironment属性中
  // 从spring.factories文件中找出key为ApplicationContextInitializer的类并实例化后设置到SpringApplication的initializers属性中。这个过程也就是找出所有的应用程序初始化器
  setInitializers((Collection) getSpringFactoriesInstances(
      ApplicationContextInitializer.class));
  // 从spring.factories文件中找出key为ApplicationListener的类并实例化后设置到SpringApplication的listeners属性中。这个过程就是找出所有的应用程序事件监听器
  setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
  // 找出main类，这里是MyApplication类
  this.mainApplicationClass = deduceMainApplicationClass();
}
</code></pre><p>ApplicationContextInitializer，应用程序初始化器，做一些初始化的工作：</p>
<pre><code>public interface ApplicationContextInitializer&lt;C extends ConfigurableApplicationContext&gt; {
    void initialize(C applicationContext);
}
</code></pre><p>ApplicationListener，应用程序事件(ApplicationEvent)监听器：</p>
<pre><code>public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener {
    void onApplicationEvent(E event);
}
</code></pre><p>这里的应用程序事件(ApplicationEvent)有应用程序启动事件(ApplicationStartedEvent)，失败事件(ApplicationFailedEvent)，准备事件(ApplicationPreparedEvent)等。</p>
<p>应用程序事件监听器跟监听事件是绑定的。比如ConfigServerBootstrapApplicationListener只跟ApplicationEnvironmentPreparedEvent事件绑定，LiquibaseServiceLocatorApplicationListener只跟ApplicationStartedEvent事件绑定，LoggingApplicationListener跟所有事件绑定等。</p>
<p>默认情况下，initialize方法从spring.factories文件中找出的key为ApplicationContextInitializer的类有：</p>
<ol>
<li>org.springframework.boot.context.config.DelegatingApplicationContextInitializer</li>
<li>org.springframework.boot.context.ContextIdApplicationContextInitializer</li>
<li>org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer</li>
<li>org.springframework.boot.context.web.ServerPortInfoApplicationContextInitializer</li>
<li>org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer</li>
</ol>
<p>key为ApplicationListener的有：</p>
<ol>
<li>org.springframework.boot.context.config.ConfigFileApplicationListener</li>
<li>org.springframework.boot.context.config.AnsiOutputApplicationListener</li>
<li>org.springframework.boot.logging.LoggingApplicationListener</li>
<li>org.springframework.boot.logging.ClasspathLoggingApplicationListener</li>
<li>org.springframework.boot.autoconfigure.BackgroundPreinitializer</li>
<li>org.springframework.boot.context.config.DelegatingApplicationListener</li>
<li>org.springframework.boot.builder.ParentContextCloserApplicationListener</li>
<li>org.springframework.boot.context.FileEncodingApplicationListener</li>
<li>org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</li>
</ol>
<h2 id="SpringApplication的执行"><a href="#SpringApplication的执行" class="headerlink" title="SpringApplication的执行"></a>SpringApplication的执行</h2><p>分析run方法之前，先看一下SpringApplication中的一些事件和监听器概念。</p>
<p>首先是SpringApplicationRunListeners类和SpringApplicationRunListener类的介绍。</p>
<p>SpringApplicationRunListeners内部持有SpringApplicationRunListener集合和1个Log日志类。用于SpringApplicationRunListener监听器的批量执行。</p>
<p>SpringApplicationRunListener看名字也知道用于监听SpringApplication的run方法的执行。</p>
<p>它定义了5个步骤：</p>
<ol>
<li>started(run方法执行的时候立马执行；对应事件的类型是ApplicationStartedEvent)</li>
<li>environmentPrepared(ApplicationContext创建之前并且环境信息准备好的时候调用；对应事件的类型是ApplicationEnvironmentPreparedEvent)</li>
<li>contextPrepared(ApplicationContext创建好并且在source加载之前调用一次；没有具体的对应事件)</li>
<li>contextLoaded(ApplicationContext创建并加载之后并在refresh之前调用；对应事件的类型是ApplicationPreparedEvent)</li>
<li>finished(run方法结束之前调用；对应事件的类型是ApplicationReadyEvent或ApplicationFailedEvent)</li>
</ol>
<p>SpringApplicationRunListener目前只有一个实现类EventPublishingRunListener，它把监听的过程封装成了SpringApplicationEvent事件并让内部属性(属性名为multicaster)ApplicationEventMulticaster接口的实现类SimpleApplicationEventMulticaster广播出去，广播出去的事件对象会被SpringApplication中的listeners属性进行处理。</p>
<p>所以说SpringApplicationRunListener和ApplicationListener之间的关系是通过ApplicationEventMulticaster广播出去的SpringApplicationEvent所联系起来的。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/startup2.jpg" alt=""></p>
<p>SpringApplication的run方法代码如下：</p>
<pre><code>public ConfigurableApplicationContext run(String... args) {
  StopWatch stopWatch = new StopWatch(); // 构造一个任务执行观察器
  stopWatch.start(); // 开始执行，记录开始时间
  ConfigurableApplicationContext context = null;
  configureHeadlessProperty();
  // 获取SpringApplicationRunListeners，内部只有一个EventPublishingRunListener
  SpringApplicationRunListeners listeners = getRunListeners(args);
  // 上面分析过，会封装成SpringApplicationEvent事件然后广播出去给SpringApplication中的listeners所监听
  // 这里接受ApplicationStartedEvent事件的listener会执行相应的操作
  listeners.started();
  try {
    // 构造一个应用程序参数持有类
    ApplicationArguments applicationArguments = new DefaultApplicationArguments(
        args);
    // 创建Spring容器
    context = createAndRefreshContext(listeners, applicationArguments);
    // 容器创建完成之后执行额外一些操作
    afterRefresh(context, applicationArguments);
    // 广播出ApplicationReadyEvent事件给相应的监听器执行
    listeners.finished(context, null);
    stopWatch.stop(); // 执行结束，记录执行时间
    if (this.logStartupInfo) {
      new StartupInfoLogger(this.mainApplicationClass)
          .logStarted(getApplicationLog(), stopWatch);
    }
    return context; // 返回Spring容器
  }
  catch (Throwable ex) {
    handleRunFailure(context, listeners, ex); // 这个过程报错的话会执行一些异常操作、然后广播出ApplicationFailedEvent事件给相应的监听器执行
    throw new IllegalStateException(ex);
  }
}
</code></pre><p>创建容器的方法createAndRefreshContext如下：</p>
<pre><code>private ConfigurableApplicationContext createAndRefreshContext(
    SpringApplicationRunListeners listeners,
    ApplicationArguments applicationArguments) {
  ConfigurableApplicationContext context; // 定义Spring容器
  // 创建应用程序的环境信息。如果是web程序，创建StandardServletEnvironment；否则，创建StandardEnvironment
  ConfigurableEnvironment environment = getOrCreateEnvironment();
  // 配置一些环境信息。比如profile，命令行参数
  configureEnvironment(environment, applicationArguments.getSourceArgs());
  // 广播出ApplicationEnvironmentPreparedEvent事件给相应的监听器执行
  listeners.environmentPrepared(environment);
  // 环境信息的校对
  if (isWebEnvironment(environment) &amp;&amp; !this.webEnvironment) {
    environment = convertToStandardEnvironment(environment);
  }

  if (this.bannerMode != Banner.Mode.OFF) { // 是否在控制台上打印自定义的banner
    printBanner(environment);
  }

  // Create, load, refresh and run the ApplicationContext
  context = createApplicationContext(); // 创建Spring容器
  context.setEnvironment(environment); // 设置Spring容器的环境信息
  postProcessApplicationContext(context); // 回调方法，Spring容器创建之后做一些额外的事
  applyInitializers(context); // SpringApplication的的初始化器开始工作
  // 遍历调用SpringApplicationRunListener的contextPrepared方法。目前只是将这个事件广播器注册到Spring容器中
  listeners.contextPrepared(context);
  if (this.logStartupInfo) {
    logStartupInfo(context.getParent() == null);
    logStartupProfileInfo(context);
  }

  // 把应用程序参数持有类注册到Spring容器中，并且是一个单例
  context.getBeanFactory().registerSingleton(&quot;springApplicationArguments&quot;,
      applicationArguments);

  Set&lt;Object&gt; sources = getSources();
  Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);
  load(context, sources.toArray(new Object[sources.size()]));
  // 广播出ApplicationPreparedEvent事件给相应的监听器执行
  listeners.contextLoaded(context);

  // Spring容器的刷新
  refresh(context);
  if (this.registerShutdownHook) {
    try {
      context.registerShutdownHook();
    }
    catch (AccessControlException ex) {
      // Not allowed in some environments.
    }
  }
  return context;
}
</code></pre><p>Spring容器的创建createApplicationContext方法如下：</p>
<pre><code>protected ConfigurableApplicationContext createApplicationContext() {
  Class&lt;?&gt; contextClass = this.applicationContextClass;
  if (contextClass == null) {
    try {
      // 如果是web程序，那么构造org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext容器
      // 否则构造org.springframework.context.annotation.AnnotationConfigApplicationContext容器
      contextClass = Class.forName(this.webEnvironment
          ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);
    }
    catch (ClassNotFoundException ex) {
      throw new IllegalStateException(
          &quot;Unable create a default ApplicationContext, &quot;
              + &quot;please specify an ApplicationContextClass&quot;,
          ex);
    }
  }
  return (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass);
}
</code></pre><p>Spring容器创建之后有个回调方法postProcessApplicationContext：</p>
<pre><code>protected void postProcessApplicationContext(ConfigurableApplicationContext context) {
      if (this.webEnvironment) { // 如果是web程序
          if (context instanceof ConfigurableWebApplicationContext) { // 并且也是Spring Web容器
              ConfigurableWebApplicationContext configurableContext = (ConfigurableWebApplicationContext) context;
              if (this.beanNameGenerator != null) { // 如果SpringApplication设置了是实例命名生成器，注册到Spring容器中
                  configurableContext.getBeanFactory().registerSingleton(
                          AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,
                          this.beanNameGenerator);
              }
          }
      }
      if (this.resourceLoader != null) { // 如果SpringApplication设置了资源加载器，设置到Spring容器中
          if (context instanceof GenericApplicationContext) {
              ((GenericApplicationContext) context)
                      .setResourceLoader(this.resourceLoader);
          }
          if (context instanceof DefaultResourceLoader) {
              ((DefaultResourceLoader) context)
                      .setClassLoader(this.resourceLoader.getClassLoader());
          }
      }
  }
</code></pre><p>初始化器做的工作，比如ContextIdApplicationContextInitializer会设置应用程序的id；AutoConfigurationReportLoggingInitializer会给应用程序添加一个条件注解解析器报告等：</p>
<pre><code>protected void applyInitializers(ConfigurableApplicationContext context) {
  // 遍历每个初始化器，对调用对应的initialize方法
  for (ApplicationContextInitializer initializer : getInitializers()) {
    Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(
        initializer.getClass(), ApplicationContextInitializer.class);
    Assert.isInstanceOf(requiredType, context, &quot;Unable to call initializer.&quot;);
    initializer.initialize(context);
  }
}
</code></pre><p>Spring容器的刷新refresh方法内部会做很多很多的事情：比如BeanFactory的设置，BeanFactoryPostProcessor接口的执行、BeanPostProcessor接口的执行、自动化配置类的解析、条件注解的解析、国际化的初始化等等。这部分内容会在之后的文章中进行讲解。</p>
<p>run方法中的Spring容器创建完成之后会调用afterRefresh方法，代码如下：</p>
<pre><code>protected void afterRefresh(ConfigurableApplicationContext context,
    ApplicationArguments args) {
  afterRefresh(context, args.getSourceArgs()); // 目前是个空实现
  callRunners(context, args); // 调用Spring容器中的ApplicationRunner和CommandLineRunner接口的实现类
}

private void callRunners(ApplicationContext context, ApplicationArguments args) {
      List&lt;Object&gt; runners = new ArrayList&lt;Object&gt;();
  // 找出Spring容器中ApplicationRunner接口的实现类
      runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());
  // 找出Spring容器中CommandLineRunner接口的实现类
      runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());
  // 对runners进行排序
      AnnotationAwareOrderComparator.sort(runners);
  // 遍历runners依次执行
      for (Object runner : new LinkedHashSet&lt;Object&gt;(runners)) {
          if (runner instanceof ApplicationRunner) { // 如果是ApplicationRunner，进行ApplicationRunner的run方法调用
              callRunner((ApplicationRunner) runner, args);
          }
          if (runner instanceof CommandLineRunner) { // 如果是CommandLineRunner，进行CommandLineRunner的run方法调用
              callRunner((CommandLineRunner) runner, args);
          }
      }
  }
</code></pre><p>这样run方法执行完成之后。Spring容器也已经初始化完成，各种监听器和初始化器也做了相应的工作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SpringBoot启动的时候，不论调用什么方法，都会构造一个SpringApplication的实例，然后调用这个实例的run方法，这样就表示启动SpringBoot。</p>
<p>在run方法调用之前，也就是构造SpringApplication的时候会进行初始化的工作，初始化的时候会做以下几件事：</p>
<ol>
<li>把参数sources设置到SpringApplication属性中，这个sources可以是任何类型的参数。本文的例子中这个sources就是MyApplication的class对象</li>
<li>判断是否是web程序，并设置到webEnvironment这个boolean属性中</li>
<li>找出所有的初始化器，默认有5个，设置到initializers属性中</li>
<li>找出所有的应用程序监听器，默认有9个，设置到listeners属性中</li>
<li>找出运行的主类(main class)</li>
</ol>
<p>SpringApplication构造完成之后调用run方法，启动SpringApplication，run方法执行的时候会做以下几件事：</p>
<ol>
<li>构造一个StopWatch，观察SpringApplication的执行</li>
<li>找出所有的SpringApplicationRunListener并封装到SpringApplicationRunListeners中，用于监听run方法的执行。监听的过程中会封装成事件并广播出去让初始化过程中产生的应用程序监听器进行监听</li>
<li>构造Spring容器(ApplicationContext)，并返回<br>3.1 创建Spring容器的判断是否是web环境，是的话构造AnnotationConfigEmbeddedWebApplicationContext，否则构造AnnotationConfigApplicationContext<br>3.2 初始化过程中产生的初始化器在这个时候开始工作<br>3.3 Spring容器的刷新(完成bean的解析、各种processor接口的执行、条件注解的解析等等)</li>
<li>从Spring容器中找出ApplicationRunner和CommandLineRunner接口的实现类并排序后依次执行</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>写了一个例子用来验证分析的启动逻辑，包括自定义的初始化器、监听器、ApplicationRunner和CommandLineRunner。</p>
<p>地址在：<a href="https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-startup" target="_blank" rel="external">https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-startup</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot的启动很简单，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从代码上可以看出，调用了SpringApplication的静态方法run。这个run方法会构造一个SpringApplication的实例，然后再调用这里实例的run方法就表示启动SpringBoot。&lt;/p&gt;
&lt;p&gt;因此，想要分析SpringBoot的启动过程，我们需要熟悉SpringApplication的构造过程以及SpringApplication的run方法执行过程即可。&lt;/p&gt;
&lt;p&gt;我们以上述这段代码为例，分析SpringBoot的启动过程。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>记录自己理解的一些设计模式</title>
    <link href="http://fangjian0423.github.io/2017/03/26/design-pattern/"/>
    <id>http://fangjian0423.github.io/2017/03/26/design-pattern/</id>
    <published>2017-03-26T07:33:29.000Z</published>
    <updated>2017-03-26T07:51:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下自己理解的一些设计模式，并尽量使用表达清楚的例子进行讲解。</p>
<a id="more"></a>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式应该是最基础的一个设计模式，它是对行为的一个抽象。jdk中的Comparator比较器就是一个使用策略设计模式的策略。</p>
<p>比如有一个Student学生类，有name和age两个属性。如果有个需求需要打印学生名单，并按照字母顺序排序，可以使用Comparator接口并在内部使用name进行比较即可。 如果哪一天需要按照年龄进行排序，那么只需要修改Comparator即可，也就是使用一个新的策略，其它完全不变。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式的意义在于对象的创建、管理可以使用工厂去管理，而不是创建者自身。最典型的工厂模式使用者就是Spring，Spring内部的容器就是一个工厂，所有的bean都由这个容器管理，包括它们的创建、销毁、注入都被这个容器管理。</p>
<p>工厂模式分简单工厂和抽象工厂。它们的区别在于抽象工厂抽象程度更高，把工厂也抽象成了一个接口，这样可以再每添加一个新的对象的时候而不需要修改工厂的代码。</p>
<p>比如有个Repository接口，用于存储数据，有DatabaseRepository，CacheRepository，FileRepository分别在数据库，缓存，文件中存储数据，定义如下：</p>
<pre><code>public interface Repository {
    void save(Object obj);
}

class DatabaseRepository implements Repository {
    @Override
    public void save(Object obj) {
        System.out.println(&quot;save in database&quot;);
    }
}
class CacheRepository implements Repository {
    @Override
    public void save(Object obj) {
        System.out.println(&quot;save in cache&quot;);
    }
}
class FileRepository implements Repository {
    @Override
    public void save(Object obj) {
        System.out.println(&quot;save in file&quot;);
    }
}
</code></pre><h3 id="简单工厂的使用"><a href="#简单工厂的使用" class="headerlink" title="简单工厂的使用"></a>简单工厂的使用</h3><pre><code>public class RepositoryFactory {

    public Repository create(String type) {
        Repository repository = null;
        switch (type) {
            case &quot;db&quot;:
                repository = new DatabaseRepository();
                break;
            case &quot;cache&quot;:
                repository = new CacheRepository();
                break;
            case &quot;file&quot;:
                repository = new FileRepository();
                break;
        }
        return repository;
    }

    public static void main(String[] args) {
        RepositoryFactory factory = new RepositoryFactory();
        factory.create(&quot;db&quot;).save(new Object());
        factory.create(&quot;cache&quot;).save(new Object());
        factory.create(&quot;file&quot;).save(new Object());
    }
}
</code></pre><p>简单工厂的弊端在于每添加一个新的Repository，都必须修改RepositoryFactory中的代码</p>
<h3 id="抽象工厂的使用"><a href="#抽象工厂的使用" class="headerlink" title="抽象工厂的使用"></a>抽象工厂的使用</h3><pre><code>public interface RepositoryFactoryProvider {
    Repository create();
}

class DatabaseRepositoryFactory implements RepositoryFactoryProvider {
    @Override
    public Repository create() {
        return new DatabaseRepository();
    }
}
class CacheRepositoryFactory implements RepositoryFactoryProvider {
    @Override
    public Repository create() {
        return new CacheRepository();
    }
}
class FileRepositoryFactory implements RepositoryFactoryProvider {
    @Override
    public Repository create() {
        return new FileRepository();
    }
}
</code></pre><p>抽象工厂的测试：</p>
<pre><code>RepositoryFactoryProvider dbProvider = new DatabaseRepositoryFactory();
dbProvider.create().save(new Object());
RepositoryFactoryProvider cacheProvider = new CacheRepositoryFactory();
cacheProvider.create().save(new Object());
RepositoryFactoryProvider fileProvider = new FileRepositoryFactory();
fileProvider.create().save(new Object());
</code></pre><p>抽象工厂把工厂也进行了抽象话，所以添加一个新的Repository的话，只需要新增一个RepositoryFactory即可，原有代码不需要修改。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>装饰者模式的作用就在于它可以在不改变原有类的基础上动态地给类添加新的功能。之前写过一篇<a href="http://www.cnblogs.com/fangjian0423/p/mybatis-cache.html" target="_blank" rel="external">通过源码分析MyBatis的缓存</a>文章，mybatis中的query就是使用了装饰者设计模式。</p>
<p>用一段简单的代码来模拟一下mybatis中query的实现原理：</p>
<pre><code>@Data
@AllArgsConstructor
@ToString
class Result { // 查询结果类，相当于一个domain
  private Object obj;
  private String sql;
}

public interface Query { // 查询接口，有简单查询和缓存查询
  Result query(String sql);
}

public class SimpleQuery implements Query { // 简单查询，相当于直接查询数据库，这里直接返回Result，相当于是数据库查询的结果
  @Override
  public Result query(String sql) {
      return new Result(new Object(), sql);
  }
}

public class CacheQuery implements Query { // 缓存查询，如果查询相同的sql，不直接查询数据库，而是返回map中存在的Result
  private Query query;
  private Map&lt;String, Result&gt; cache = new HashMap&lt;&gt;();
  public CacheQuery(Query query) {
      this.query = query;
  }
  @Override
  public Result query(String sql) {
      if(cache.containsKey(sql)) {
          return cache.get(sql);
      }
      Result result = query.query(sql);
      cache.put(sql, result);
      return result;
  }
}
</code></pre><p>测试：</p>
<pre><code>Query simpleQuery = new SimpleQuery();
System.out.println(simpleQuery.query(&quot;select * from t_student&quot;) == simpleQuery.query(&quot;select * from t_student&quot;)); // false
Query cacheQuery = new CacheQuery(simpleQuery);
System.out.println(cacheQuery.query(&quot;select * from t_student&quot;) == cacheQuery.query(&quot;select * from t_student&quot;)); // true
</code></pre><p>这里CacheQuery就是一个装饰类，SimpleQuery是一个被装饰者。我们通过装饰者设计模式动态地给SimpleQuery添加了缓存功能，而不需要修改SimpleQuery的代码。</p>
<p>当然，装饰者模式也有缺点，就是会存在太多的类。</p>
<p>如果我们需要添加一个过滤的查询(sql中有敏感字的就直接返回null，而不查询数据库)，只需要可以添加一个FilterQuery装饰者即可：</p>
<pre><code>public class FilterQuery implements Query {
    private Query query;
    private List&lt;String&gt; words = new ArrayList&lt;&gt;();
    public FilterQuery(Query query) {
        this.query = query;
        words.add(&quot;fuck&quot;);
        words.add(&quot;sex&quot;);
    }
    @Override
    public Result query(String sql) {
        for(String word : words) {
            if(sql.contains(word)) return null;
        }
        return query.query(sql);
    }
}

Query filterQuery = new FilterQuery(simpleQuery);
System.out.println(filterQuery.query(&quot;select * from t_student where name = &apos;fuck&apos;&quot;));  // null
System.out.println(filterQuery.query(&quot;select * from t_student where name = &apos;format&apos;&quot;)); // Result(obj=java.lang.Object@1b4fb997, sql=select * from t_student where name = &apos;format&apos;)
</code></pre><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式的作用是使用一个代理类来代替原先类进行操作。比较常见的就是aop中就是使用代理模式完成事务的处理。</p>
<p>代理模式分静态代理和动态代理，静态代理的原理就是对目标对象进行封装，最后调用目标对象的方法即可。</p>
<p>动态代理跟静态代理的区别就是动态代理中的代理类是程序运行的时候生成的。Spring中对于接口的代理使用jdk内置的Proxy和InvocationHandler实现，对于类的代理使用cglib完成。</p>
<p>以1个UserService为例，使用jdk自带的代理模式完成计算方法调用时间的需求：</p>
<pre><code>// UserService接口
public interface IUserService {
    void printAll();
}
// UserService实现类
class UserService implements IUserService {
    @Override
    public void printAll() {
        System.out.println(&quot;print all users&quot;);
    }
}
// InvocationHandler策略，这里打印了方法调用前后的时间
@AllArgsConstructor
class UserInvocationHandler implements InvocationHandler {
    private IUserService userService;
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;start : &quot; + System.currentTimeMillis());
        Object result = method.invoke(userService, args);
        System.out.println(&quot;end : &quot; + System.currentTimeMillis());
        return result;
    }
}
</code></pre><p>测试：</p>
<pre><code>IUserService userService = new UserService();
UserInvocationHandler uih = new UserInvocationHandler(userService);
IUserService proxy = (IUserService) Proxy.newProxyInstance(userService.getClass().getClassLoader(), new Class[] {IUserService.class}, uih);
proxy.printAll(); // 打印出start : 1489665566456  print all users  end : 1489665566457
</code></pre><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式经常跟策略模式配合使用，用来组合所有的策略，并遍历这些策略找出满足条件的策略。之前写过一篇<a href="http://www.cnblogs.com/fangjian0423/p/springMVC-xml-json-convert.html" target="_blank" rel="external">SpringMVC关于json、xml自动转换的原理研究</a>文章，里面springmvc把返回的返回值映射给用户的response做了一层抽象，封装到了HandlerMethodReturnValueHandler策略接口中。</p>
<p>在HandlerMethodReturnValueHandlerComposite类中，使用存在的HandlerMethodReturnValueHandler对返回值进行处理，在HandlerMethodReturnValueHandlerComposite内部的代码如下：</p>
<pre><code>// 策略集合
private final List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers = new ArrayList&lt;HandlerMethodReturnValueHandler&gt;();

@Override
public void handleReturnValue(Object returnValue, MethodParameter returnType,
    ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {
    // 调用selectHandler方法
    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);
    if (handler == null) {
      throw new IllegalArgumentException(&quot;Unknown return value type: &quot; + returnType.getParameterType().getName());
    }
    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest); // 使用找到的handler进行处理
}

private HandlerMethodReturnValueHandler selectHandler(Object value, MethodParameter returnType) {
    boolean isAsyncValue = isAsyncReturnValue(value, returnType);
    // 遍历存在的HandlerMethodReturnValueHandler
    for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {
      if (isAsyncValue &amp;&amp; !(handler instanceof AsyncHandlerMethodReturnValueHandler)) {
        continue;
      }
      if (handler.supportsReturnType(returnType)) { // 找到匹配的handler
        return handler;
      }
    }
    return null;
}
</code></pre><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>跟策略模式类似，模板模式会先定义好实现的逻辑步骤，但是具体的实现方式由子类完成，跟策略模式的区别就是模板模式是有逻辑步骤的。比如要给院系里的学生排序，并取出排名第一的学生。这里就有2个步骤，分别是排序和取出第一名学生。</p>
<p>一段伪代码：</p>
<pre><code>public abstract class AbstractStudentGetter {
    public final Student getStudent(List&lt;Student&gt; students) {
        sort(students); // 第一步
        if(!CollectionUtils.isEmpty(students)) {
            return students.get(0);  // 第二步
        }
        return null;
    }
    abstract public void sort(List&lt;Student&gt; students);
}
class AgeStudentGetter extends AbstractStudentGetter { // 取出年纪最大的学生
    @Override
    public void sort(List&lt;Student&gt; students) {
        students.sort(new Comparator&lt;Student&gt;() {
            @Override
            public int compare(Student s1, Student s2) {
                return s2.getAge() - s1.getAge();
            }
        });
    }
}
class NameStudentGetter extends AbstractStudentGetter { // 按照名字字母排序取出第一个学生
    @Override
    public void sort(List&lt;Student&gt; students) {
        students.sort(new Comparator&lt;Student&gt;() {
            @Override
            public int compare(Student s1, Student s2) {
                return s2.getName().compareTo(s1.getName());
            }
        });
    }
}
</code></pre><p>测试：</p>
<pre><code>AbstractStudentGetter ageGetter = new AgeStudentGetter();
AbstractStudentGetter nameGetter = new NameStudentGetter();

List&lt;Student&gt; students = new ArrayList&lt;&gt;();
students.add(new Student(&quot;jim&quot;, 22));
students.add(new Student(&quot;format&quot;, 25));

System.out.println(ageGetter.getStudent(students)); // Student(name=format, age=25)
System.out.println(nameGetter.getStudent(students)); // Student(name=jim, age=22)
</code></pre><h2 id="观察者设计模式"><a href="#观察者设计模式" class="headerlink" title="观察者设计模式"></a>观察者设计模式</h2><p>观察者设计模式主要的使用场景在于一个对象变化之后，依赖该对象的对象会收到通知。典型的例子就是rss的订阅，当订阅了博客的rss之后，当博客更新之后，订阅者就会收到新的订阅信息。</p>
<p>jdk内置提供了Observable和Observer，用来实现观察者模式：</p>
<pre><code>// 定义一个Observable
public class MetricsObserable extends Observable {
    private Map&lt;String, Long&gt; counterMap = new HashMap&lt;&gt;();
    public void updateCounter(String key, Long value) {
        counterMap.put(key, value);
        setChanged();
        notifyObservers(counterMap);
    }
}
// Observer
public class AdminA implements Observer {
    @Override
    public void update(Observable o, Object arg) {
        System.out.println(&quot;adminA: &quot; + arg);
    }
}
public class AdminB implements Observer {
    @Override
    public void update(Observable o, Object arg) {
        System.out.println(&quot;adminB: &quot; + arg);
    }
}
</code></pre><p>测试：</p>
<pre><code>MetricsObserable metricsObserable = new MetricsObserable();
metricsObserable.addObserver(new AdminA());
metricsObserable.addObserver(new AdminB());
metricsObserable.updateCounter(&quot;request-count&quot;, 100l);
</code></pre><p>打印出：</p>
<pre><code>adminB: {request-count=100}
adminA: {request-count=100}
</code></pre><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>线程池中会构造几个核心线程用于处理，这些线程会去取阻塞队列里的任务然后进行执行。这些线程就是会被共享、且被重复使用的。因为线程的创建、销毁、调度都是需要消耗资源的，没有必要每次创建新的线程，而是共用一些线程。这就是享元模式的使用。类似的还有jdbc连接池，对象池等。</p>
<p>之前有一次面试被问到：</p>
<pre><code>Integer.valueOf(&quot;1&quot;) == Integer.valueOf(&quot;1&quot;) // true还是false
</code></pre><p>当时回答的是false，后来翻了下Integer的源码发现Integer里面有个内部类IntegerCache，用于缓存一些共用的Integer。这个缓存的范围可以在jvm启动的时候进行设置。</p>
<p>其实后来想想也应该这么做，我们没有必要每次使用对象的时候都返回新的对象，可以共享这些对象，因为新对象的创建都是需要消耗内存的。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式比较好理解。像生活中插线口的插头有2个口的，也有3个口的。如果电脑的电源插口只有3个口的，但是我们需要一个2个口的插口的话，这个时候就需要使用插座来外接这个3个口的插头，插座上有2个口的插头。</p>
<p>这个例子跟我们编程一样，当用户系统的接口跟我们系统内部的接口不一致时，我们可以使用适配器来完成接口的转换。</p>
<p>使用继承的方式实现类的适配：</p>
<pre><code>public class Source {
    public void method() {
        System.out.println(&quot;source method&quot;);
    }
}
interface Targetable {
    void method();
    void newMethod();
}
class Adapter extends Source implements Targetable {
    @Override
    public void newMethod() {
        System.out.println(&quot;new method&quot;);
    }
}
</code></pre><p>测试：</p>
<pre><code>Targetable targetable = new Adapter();
targetable.method(); // source method
targetable.newMethod(); // new method
</code></pre><p>上述方式是用接口和继承的方式实现适配器模式。当然我们也可以使用组合的方式实现(把Source当成属性放到Adapter中)。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式比较好理解，Spring就是典型的例子。被Spring中的容器管理的对象都有对应的scope，配置成singleton说明这个对象就是单例，也就是在Spring容器的生命周期中，这个类只有1个实例。</p>
<p>java中单例模式的写法也有好多种。比如懒汉式、饿汉式、内部类方式、枚举方式等。</p>
<p>需要注意的如果使用dcl的话需要初始化过程，这篇<a href="http://cmsblogs.com/?p=2161&amp;from=timeline&amp;isappinstalled=0" target="_blank" rel="external">Java内存模型之从JMM角度分析DCL</a>文章中说明了dcl的正确用法。</p>
<p>Effectice java中推荐的单例方式写法是使用枚举类型的方式。</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式用来包装一组接口用于方便使用。 比如系统中分10个模块，有个功能需要组合使用所有的模块，这个时候就需要一个包装类包装这10个接口，然后进行业务逻辑的调用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下自己理解的一些设计模式，并尽量使用表达清楚的例子进行讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="architecture" scheme="http://fangjian0423.github.io/categories/architecture/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="architecture" scheme="http://fangjian0423.github.io/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud网关服务zuul介绍</title>
    <link href="http://fangjian0423.github.io/2017/02/22/springcloud-zuul/"/>
    <id>http://fangjian0423.github.io/2017/02/22/springcloud-zuul/</id>
    <published>2017-02-22T13:33:22.000Z</published>
    <updated>2017-02-23T14:08:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Netflix/zuul" target="_blank" rel="external">Zuul</a>是Netflix开发的一款提供动态路由、监控、弹性、安全的网关服务。</p>
<p>使用Zuul网关服务带来的好处是统一向外系统提供REST API，并额外提供了权限控制、负载均衡等功能，并且这些功能是从原先的服务中抽离出来并单独存在的。</p>
<p>Zuul提供了不同类型的filter用于处理请求，这些filter可以让我们实现以下功能：</p>
<ol>
<li>权限控制和安全性：可以识别认证需要的信息和拒绝不满足条件的请求</li>
<li>监控：监控请求信息</li>
<li>动态路由：根据需要动态地路由请求到后台的不同集群</li>
<li>压力测试</li>
<li>负载均衡</li>
<li>静态资源处理：直接在zuul处理静态资源的响应而不需要转发这些请求到内部集群中</li>
</ol>
<a id="more"></a>
<h2 id="Zuul的执行过程介绍"><a href="#Zuul的执行过程介绍" class="headerlink" title="Zuul的执行过程介绍"></a>Zuul的执行过程介绍</h2><p>Zuul基于Servlet实现，它封装了Servlet提供的相关接口，并提供了一个全新的api。</p>
<p><strong>ZuulFilter</strong>是一个基础的抽象类，定义了一些抽象方法：</p>
<ol>
<li>filterType方法: filter的类型，有”pre”, “route”, “post”, “error”, “static”</li>
<li>filterOrder方法：优先级，级别越高，越快被执行</li>
<li>shouldFilter方法：开关，如果是true，run方法会执行，否则不会执行</li>
<li>run方法：filter执行的逻辑操作</li>
</ol>
<p><strong>ZuulServlet</strong>是一个继承自HttpServlet的子类，使用Zuul所有的请求都会被这个Servlet接收并处理。</p>
<p>ZuulServlet覆盖了HttpServlet的service方法，所以不论是get/post/put/delete等方法都会执行相同的操作：</p>
<pre><code>@Override
public void service(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse) throws ServletException, IOException {
    try {
        init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse); // 初始化ZuulRunner，也就是包装request和response，并设置到RequestContext中，RequestContext使用ThreadLocal获得，每个线程独立保存一份，用于存储各种信息，比如request，response，监控信息，异常信息，成功信息，执行时间等等

        // Marks this request as having passed through the &quot;Zuul engine&quot;, as opposed to servlets
        // explicitly bound in web.xml, for which requests will not have the same data attached
        RequestContext context = RequestContext.getCurrentContext();
        context.setZuulEngineRan();

        try {
            preRoute(); // 执行 pre 类型的filter
        } catch (ZuulException e) {
            error(e); // pre 类型的filter执行报错的话执行 error 类型的filter
            postRoute(); // 执行 post 类型的filter
            return;
        }
        try {
            route(); // pre 类型的filter执行成功后，执行 route 类型的filter
        } catch (ZuulException e) {
            error(e); //route 类型的filter执行报错的话执行 error 类型的filter
            postRoute(); // 执行 post 类型的filter
            return;
        }
        try {
            postRoute(); // route 类型的filter执行成功后，执行 post 类型的filter
        } catch (ZuulException e) {
            error(e); //post 类型的filter执行报错的话执行 error 类型的filter
            return;
        }

    } catch (Throwable e) {
        error(new ZuulException(e, 500, &quot;UNHANDLED_EXCEPTION_&quot; + e.getClass().getName())); // 发生其他没有catch的错误的话，执行 error 类型的filter
    } finally {
        RequestContext.getCurrentContext().unset();
    }
}
</code></pre><p>下图是<a href="https://github.com/Netflix/zuul/wiki/How-it-Works" target="_blank" rel="external">zuul wiki</a>上对filter的执行过程说明。</p>
<p><img src="https://camo.githubusercontent.com/4eb7754152028cdebd5c09d1c6f5acc7683f0094/687474703a2f2f6e6574666c69782e6769746875622e696f2f7a75756c2f696d616765732f7a75756c2d726571756573742d6c6966656379636c652e706e67" alt="filter"></p>
<p>从上面的service方法中我们也可以得出：先执行pre类型的filter；如果pre filter执行失败那么执行error和post类型的filter，pre filter执行成功的话执行route类型的filter；如果route filter执行失败那么执行error和post类型的filter，route filter执行成功的话执行post filter；如果post filter执行失败那么执行error类型的filter，post filter执行成功的话，结束。上述过程中执行失败指的是ZuulException被catch，如果是其他Exception的话，那么执行error类型的filter，然后结束。</p>
<p>ZuulServlet里的preRoute(), route(), postRoute(), error()方法详情：</p>
<pre><code>ZuulRunner.java
public void preRoute() throws ZuulException {
    FilterProcessor.getInstance().preRoute();
}

FilterProcessor.java
public void preRoute() throws ZuulException {
    try {
        runFilters(&quot;pre&quot;);
    } catch (Throwable e) {
        if (e instanceof ZuulException) {
            throw (ZuulException) e;
        }
        throw new ZuulException(e, 500, &quot;UNCAUGHT_EXCEPTION_IN_PRE_FILTER_&quot; + e.getClass().getName());
    }
}

public Object runFilters(String sType) throws Throwable {
    if (RequestContext.getCurrentContext().debugRouting()) {
        Debug.addRoutingDebug(&quot;Invoking {&quot; + sType + &quot;} type filters&quot;);
    }
    boolean bResult = false;
    List&lt;ZuulFilter&gt; list = FilterLoader.getInstance().getFiltersByType(sType); // 获得对应类型的filter集合
    if (list != null) {
        for (int i = 0; i &lt; list.size(); i++) { // 遍历这些类型的filter集合
            ZuulFilter zuulFilter = list.get(i);
            Object result = processZuulFilter(zuulFilter); // 调用processZuulFilter方法
            if (result != null &amp;&amp; result instanceof Boolean) {
                bResult |= ((Boolean) result);
            }
        }
    }
    return bResult;
}

public Object processZuulFilter(ZuulFilter filter) throws ZuulException {

    RequestContext ctx = RequestContext.getCurrentContext();
    boolean bDebug = ctx.debugRouting();
    final String metricPrefix = &quot;zuul.filter-&quot;;
    long execTime = 0; // 执行时间
    String filterName = &quot;&quot;;
    try {
        long ltime = System.currentTimeMillis(); // 执行前的时间
        filterName = filter.getClass().getSimpleName(); // 获取filter名字

        RequestContext copy = null;
        Object o = null;
        Throwable t = null;

        if (bDebug) {
            Debug.addRoutingDebug(&quot;Filter &quot; + filter.filterType() + &quot; &quot; + filter.filterOrder() + &quot; &quot; + filterName);
            copy = ctx.copy();
        }

        ZuulFilterResult result = filter.runFilter(); // 调用ZuulFilter的runFilter方法得到ZuulFilterResult，这个类是对filter执行结果的包装，包括返回值、异常信息、状态
        ExecutionStatus s = result.getStatus(); // 得到ZuulFilterResult的状态信息
        execTime = System.currentTimeMillis() - ltime; // 得到filter的执行时间

        switch (s) { // 针对不同的ZuulFilterResult的状态做不同处理
            case FAILED: // 如果是FAILED状态，说错run方法执行失败了
                t = result.getException(); // 得到失败的异常
                ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime); // 失败信息加到RequestContext中
                break;
            case SUCCESS: // 如果是SUCCESS状态，说明run方法正确执行完毕
                o = result.getResult(); // 得到run方法返回的结果
                ctx.addFilterExecutionSummary(filterName, ExecutionStatus.SUCCESS.name(), execTime); // 成功信息加到RequestContext中
                if (bDebug) {
                    Debug.addRoutingDebug(&quot;Filter {&quot; + filterName + &quot; TYPE:&quot; + filter.filterType() + &quot; ORDER:&quot; + filter.filterOrder() + &quot;} Execution time = &quot; + execTime + &quot;ms&quot;);
                    Debug.compareContextState(filterName, copy);
                }
                break;
            default: // 其他状态的话不做处理
                break;
        }

        if (t != null) throw t; // 如果是FAILED状态，抛出这个Exception

        usageNotifier.notify(filter, s); // 记录监控信息
        return o;

    } catch (Throwable e) { // 如果发生了一些其它没有catch的异常
        if (bDebug) {
            Debug.addRoutingDebug(&quot;Running Filter failed &quot; + filterName + &quot; type:&quot; + filter.filterType() + &quot; order:&quot; + filter.filterOrder() + &quot; &quot; + e.getMessage());
        }
        usageNotifier.notify(filter, ExecutionStatus.FAILED); // 记录监控信息
        if (e instanceof ZuulException) {
            throw (ZuulException) e;
        } else { // 封装成ZuulException并抛出
            ZuulException ex = new ZuulException(e, &quot;Filter threw Exception&quot;, 500, filter.filterType() + &quot;:&quot; + filterName);
            ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime);
            throw ex;
        }
    }
}

ZuulFilter.java
public ZuulFilterResult runFilter() {
    ZuulFilterResult zr = new ZuulFilterResult();
    if (!isFilterDisabled()) { // 如果对应的zuul filter没有被disable
        if (shouldFilter()) { // shouldFilter开关是否开启
            Tracer t = TracerFactory.instance().startMicroTracer(&quot;ZUUL::&quot; + this.getClass().getSimpleName()); // 设置监控信息
            try {
                Object res = run(); // 调用ZuulFilter的run方法
                zr = new ZuulFilterResult(res, ExecutionStatus.SUCCESS); // 把结果封装到ZuulFilterResult中，并设置状态为SUCCESS
            } catch (Throwable e) { // 如果发生了异常
                t.setName(&quot;ZUUL::&quot; + this.getClass().getSimpleName() + &quot; failed&quot;); // 完善监控信息
                zr = new ZuulFilterResult(ExecutionStatus.FAILED); // 把ZuulFilterResult状态设置为FAILED
                zr.setException(e); // 设置异常信息
            } finally {
                t.stopAndLog();
            }
        } else {
            zr = new ZuulFilterResult(ExecutionStatus.SKIPPED); // zuul filter被disable的话，把ZuulFilterResult状态设置为SKIPPED
        }
    }
    return zr;
}
</code></pre><h2 id="在SpringCloud中使用Zuul"><a href="#在SpringCloud中使用Zuul" class="headerlink" title="在SpringCloud中使用Zuul"></a>在SpringCloud中使用Zuul</h2><p>在SpringCloud中使用Zuul，加上@EnableZuulProxy注解，这个注解会import ZuulProxyConfiguration配置类。ZuulProxyConfiguration配置类继承ZuulConfiguration类，ZuulConfiguration配置类使用zuul开头的配置。</p>
<p>在这个例子中，本地端口2222有了compute-service服务。这个zuul的服务地址暴露在7777端口下。</p>
<p>我们定义了一个规则：</p>
<pre><code>zuul.routes.api-a-url.path=/api-a-url/**
zuul.routes.api-a-url.url=http://localhost:2222/
</code></pre><p>这个routes对应的类型是Map<string, zuulroute="">，key为String，value是一个ZuulRoute。ZuulRoute中定义了一些属性，有：</string,></p>
<pre><code>private String id; // 标识一个路由规则
private String path; // 拦截路径，比如 /api-a-url/**
private String serviceId; // Eureka服务发现中的serviceId
private String url; //不使用服务发现中的服务，独立的一个url
private boolean stripPrefix = true;
private Boolean retryable; // 是否会retry
private Set&lt;String&gt; sensitiveHeaders = new LinkedHashSet&lt;&gt;();
</code></pre><p>上面的api-a-url就是对应map中的key，path和url对应ZuulRoute中的path和url属性。</p>
<p>在ZuulProxyConfiguration配置类中，构造了很多bean，比如有ZuulController、ZuulHandlerMapping、DiscoveryClientRouteLocator、各种filter等bean。</p>
<p>其中ZuulController内部使用了ZuulServlet处理http请求，DiscoveryClientRouteLocator使用ZuulProperties中的route解析路由规则，然后封装成org.springframework.cloud.netflix.zuul.filters.Route在getRoutes方法中返回，这个方法会在RoutesEndpoint和ZuulHandlerMapping中被调用。</p>
<p>另外DiscoveryClientRouteLocator会基于服务发现中心中的服务信息，再去寻找对应的路由规则。由于例子中有个本地端口为2222的compute-service服务。所以会被解析并放到路由规则里，这样路由规则里就有2个规则：</p>
<ol>
<li>path为/api-a-url/**，url为<a href="http://localhost:2222/" target="_blank" rel="external">http://localhost:2222/</a></li>
<li>path为/compute-service/**，serviceId为compute-service</li>
</ol>
<p>ZuulHandlerMapping是一个HandlerMapping，用于处理请求的映射关系。在SpringMVC中，默认是使用RequestMappingHandlerMapping处理，而在Zuul中，使用ZuulHandlerMapping处理地址映射关系。它内部有个注册handler方法：</p>
<pre><code>private void registerHandlers() {
  Collection&lt;Route&gt; routes = this.routeLocator.getRoutes(); // 得到路由规则
  if (routes.isEmpty()) {
    this.logger.warn(&quot;No routes found from RouteLocator&quot;);
  }
  else {
    for (Route route : routes) { // 注册路由规则中的地址，对应了handler是zuul属性，这个zuul也就是ZuulController
      registerHandler(route.getFullPath(), this.zuul);
    }
  }
}
</code></pre><p>例子中路由规则里对应的路径有2个，分别是/api-a-url/<strong>和/compute-service/</strong>，它们对应的handler都是ZuulController。</p>
<p>访问地址：</p>
<pre><code>http://localhost:7777/api-a-url/add?a=1&amp;b=2
</code></pre><p>在ZuulHandlerMapping中的规则路径中发现了/api-a-url/**，于是传递给ZuulController处理，ZuulController传递给ZuulServlet处理。</p>
<p>讲到这里，细心的读者可能会发现一个问题：<strong>我们前面讲了这么多关于filter的各种细节，但是真正的服务调用是在哪里执行的?</strong></p>
<p>Zuul把真正的服务调用也放在了filter中处理，并在产生的结果放在了RequestContext中。</p>
<p>其中有route类型的filter中使用HttpClient执行，执行结果的stream放到了RequestContext。</p>
<p>post类型的filter读取这个stream并使用response write出去。</p>
<p>我们来简单看下这个过程中一些filter的各自实现。</p>
<p>SimpleHostRoutingFilter这个route类型的filter的shouldFilter方法：</p>
<pre><code>@Override
public boolean shouldFilter() {
  // 如果对应的地址是使用host方式，才会生效
  return RequestContext.getCurrentContext().getRouteHost() != null
      &amp;&amp; RequestContext.getCurrentContext().sendZuulResponse();
}
</code></pre><p>run方法：</p>
<pre><code>@Override
public Object run() {
  RequestContext context = RequestContext.getCurrentContext();
  HttpServletRequest request = context.getRequest();
  MultiValueMap&lt;String, String&gt; headers = this.helper
      .buildZuulRequestHeaders(request);
  MultiValueMap&lt;String, String&gt; params = this.helper
      .buildZuulRequestQueryParams(request);
  String verb = getVerb(request);
  InputStream requestEntity = getRequestBody(request);
  if (request.getContentLength() &lt; 0) {
    context.setChunkedRequestBody();
  }

  String uri = this.helper.buildZuulRequestURI(request);
  this.helper.addIgnoredHeaders();

  try {
    HttpResponse response = forward(this.httpClient, verb, uri, request, headers,
        params, requestEntity); // 使用HttpClient调用remoteHost
    setResponse(response); // 设置remoteHost调用的结果
  }
  catch (Exception ex) {
    context.set(&quot;error.status_code&quot;,
        HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    context.set(&quot;error.exception&quot;, ex);
  }
  return null;
}

// setResponse方法会把response中的stream放到RequestContext中
context.setResponseDataStream(entity);
</code></pre><p>RibbonRoutingFilter跟SimpleHostRoutingFilter类似，区别就是它的shouldFilter方法里不是判断host方式，而是判断路由规则里是否存在serviceId。它的run方法也是使用HttpClient完成服务的调用，但是它是使用ribbon完成的。</p>
<p>访问地址：</p>
<pre><code>http://localhost:7777/compute-service/add?a=1&amp;b=2
</code></pre><p>由于使用了serviceId的方式，所以会触发RibbonRoutingFilter并完成服务的调用。</p>
<p>当使用Eureka服务发现的时候，建议使用serviceId的方式，而不是直接host的方式。因为基于serviceId的方式会使用ribbon完成服务的调用，ribbon中又使用了hystrix和loadbalance等功能，有更好的健壮性。</p>
<p>SendResponseFilter是一个post类型的，它会写回服务调用产生的结果。</p>
<pre><code>@Override
public boolean shouldFilter() {
  // RibbonRoutingFilter和SimpleHostRoutingFilter都会写入stream数据到RequestContext中的responseDataStream中，所以这个filter会生效
  return !RequestContext.getCurrentContext().getZuulResponseHeaders().isEmpty()
      || RequestContext.getCurrentContext().getResponseDataStream() != null
      || RequestContext.getCurrentContext().getResponseBody() != null;
}

@Override
  public Object run() {
      try {
          addResponseHeaders();
    // 最终在RequestContext中使用response write这个stream
          writeResponse();
      }
      catch (Exception ex) {
          ReflectionUtils.rethrowRuntimeException(ex);
      }
      return null;
  }
</code></pre><p>SpringCloud默认还加了其它的一些拦截器，有兴趣的读者可以自行查看源代码。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Zuul内部的处理使用ZuulServlet完成，ZuulServlet继承HttpServlet，重写了service方法，service方法内部分别是pre、route、post和error类型的filter进行调用。这里的不同类型的filter执行顺序文中已经说明。</p>
<p>要在SpringCloud中使用Zuul，需要加上@EnableZuulProxy注解。加上这个注解之后SpringCloud会构造一些bean，比如ZuulHandlerMapping、DiscoveryClientRouteLocator、各种filter等。其中DiscoveryClientRouteLocator是一个基于服务发现的路由规则生成器，它会基于zuul的配置构造路由规则。ZuulHandlerMapping是一个HandlerMapping的实现，它跟基于路由规则注册handler，其中key为路由规则对应的路径，handler都是ZuulController，ZuulController内部使用ZuulServlet进行请求的处理。</p>
<p>Zuul把真正的服务调用放在了filter中实现。它提供了SimpleHostRoutingFilter和RibbonRoutingFilter这2个route类型的filter用于执行服务。从名字也可以看出来，SimpleHostRoutingFilter用于执行基于host方式的调用url接口，RibbonRoutingFilter基于服务发现的方式调用服务。一般我们都建议使用RibbonRoutingFilter，因为它内部使用ribbon，更加健壮。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>RoutesEndpoint这个endpoint使用RouteLocator中提供的所有路由规则。</p>
<p>访问：</p>
<pre><code>http://localhost:7777/routes
</code></pre><p>得到路由规则：</p>
<pre><code>{
    /api-a-url/**: &quot;http://localhost:2222/&quot;,
    /compute-service/**: &quot;compute-service&quot;
}
</code></pre><p>Zuul声称自己可以使用static类型的filter用于处理静态资源，也提供了一个StaticResponseFilter的一个基类，但是查看ZuulServlet的源码发现没有哪段逻辑是处理静态资源的。 上了github发现专门有个<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1001" target="_blank" rel="external">issue</a>说明目前还不支持自定义的filter。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/Netflix/zuul/" target="_blank" rel="external">https://github.com/Netflix/zuul/</a></p>
<p><a href="https://github.com/Netflix/zuul/wiki" target="_blank" rel="external">https://github.com/Netflix/zuul/wiki</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Netflix/zuul&quot;&gt;Zuul&lt;/a&gt;是Netflix开发的一款提供动态路由、监控、弹性、安全的网关服务。&lt;/p&gt;
&lt;p&gt;使用Zuul网关服务带来的好处是统一向外系统提供REST API，并额外提供了权限控制、负载均衡等功能，并且这些功能是从原先的服务中抽离出来并单独存在的。&lt;/p&gt;
&lt;p&gt;Zuul提供了不同类型的filter用于处理请求，这些filter可以让我们实现以下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;权限控制和安全性：可以识别认证需要的信息和拒绝不满足条件的请求&lt;/li&gt;
&lt;li&gt;监控：监控请求信息&lt;/li&gt;
&lt;li&gt;动态路由：根据需要动态地路由请求到后台的不同集群&lt;/li&gt;
&lt;li&gt;压力测试&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;静态资源处理：直接在zuul处理静态资源的响应而不需要转发这些请求到内部集群中&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="springcloud" scheme="http://fangjian0423.github.io/categories/springcloud/"/>
    
    
      <category term="springcloud" scheme="http://fangjian0423.github.io/tags/springcloud/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud使用Hystrix实现断路器</title>
    <link href="http://fangjian0423.github.io/2017/02/19/springcloud-hystrix/"/>
    <id>http://fangjian0423.github.io/2017/02/19/springcloud-hystrix/</id>
    <published>2017-02-19T04:11:39.000Z</published>
    <updated>2017-02-21T08:09:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="external">Hystrix</a>是一个供分布式系统使用，提供延迟和容错功能，保证复杂的分布系统在面临不可避免的失败时，仍能有其弹性。</p>
<p>比如系统中有很多服务，当某些服务不稳定的时候，使用这些服务的用户线程将会阻塞，如果没有隔离机制，系统随时就有可能会挂掉，从而带来很大的风险。</p>
<p>SpringCloud使用Hystrix组件提供断路器、资源隔离与自我修复功能。下图表示服务B触发了断路器，阻止了级联失败。</p>
<p><img src="http://cloud.spring.io/spring-cloud-static/Brixton.SR7/images/HystrixFallback.png" alt="image"></p>
<a id="more"></a>
<h2 id="Hystrix的简单使用"><a href="#Hystrix的简单使用" class="headerlink" title="Hystrix的简单使用"></a>Hystrix的简单使用</h2><p>Hystrix使用了命令设计模式，只需要编写命令即可：</p>
<pre><code>public class CommandHelloWorld extends HystrixCommand&lt;String&gt; {

    private final String name;

    public CommandHelloWorld(String name) {
        super(HystrixCommandGroupKey.Factory.asKey(&quot;HelloWorld&quot;));
        this.name = name;
    }

    @Override
    protected String run() throws Exception { // 完成业务逻辑
        return &quot;Hello &quot; + name + &quot;!&quot;;
    }

    @Override
    protected String getFallback() { // run方法抛出异常的时候返回备用结果
        return &quot;Hello Failure &quot; + name + &quot;!&quot;;
    }

}
</code></pre><p>测试用例：</p>
<pre><code>@Test
public void test() {
    assertEquals(&quot;Hello World!&quot;, new CommandHelloWorld(&quot;World&quot;).execute());
    assertEquals(&quot;Hello Format!&quot;, new CommandHelloWorld(&quot;Format&quot;).execute());
}
</code></pre><p>可能有的人觉得写Command有点麻烦，Hystrix提供了一个类库<a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica" target="_blank" rel="external">javanica</a>，可以使用@HystrixCommand注解完成命令的编写。</p>
<h2 id="在SpringCloud中使用Hystrix"><a href="#在SpringCloud中使用Hystrix" class="headerlink" title="在SpringCloud中使用Hystrix"></a>在SpringCloud中使用Hystrix</h2><p>要在SpringCloud中使用断路器，需要加上@EnableCircuitBreaker注解：</p>
<pre><code>...
@EnableCircuitBreaker
...
public class RibbonApplication { ... }
</code></pre><p>然后在对应的方法上加入@HystrixCommand注解实现断路器功能，当service方法对应的服务发生异常的时候，会跳转到serviceFallback方法执行：</p>
<pre><code>@HystrixCommand(fallbackMethod = &quot;serviceFallback&quot;) // 加入@HystrixCommand注解实现断路器功能
public String service() { // 原先的方法
    return restTemplate.getForEntity(&quot;...&quot;, String.class).getBody();
}

public String serviceFallback() { // fallback方法
    return &quot;error&quot;;
}
</code></pre><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>加上@EnableCircuitBreaker注解之后，就可以使用断路器功能，所以SpringCloud内部是如何整合Hystrix的话先从这个注解开始分析。</p>
<p>@EnableCircuitBreaker注解定义如下：</p>
<pre><code>@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(EnableCircuitBreakerImportSelector.class)
public @interface EnableCircuitBreaker {

}
</code></pre><p>import了EnableCircuitBreakerImportSelector这个selector：</p>
<pre><code>public class EnableCircuitBreakerImportSelector extends
    SpringFactoryImportSelector&lt;EnableCircuitBreaker&gt; {

    @Override
    protected boolean isEnabled() {
        return new RelaxedPropertyResolver(getEnvironment()).getProperty(
            &quot;spring.cloud.circuit.breaker.enabled&quot;, Boolean.class, Boolean.TRUE);
    }

}
</code></pre><p>在之前的这篇<a href="http://fangjian0423.github.io/2016/11/13/springboot-enable-annotation/">SpringBoot自动化配置的注解开关原理</a>文章中分析过selector的原理，这个EnableCircuitBreakerImportSelector会加载spring.factories属性文件中key为org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker的类：</p>
<pre><code>org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker=\
    org.springframework.cloud.netflix.hystrix.HystrixCircuitBreakerConfiguration
</code></pre><p>会加载HystrixCircuitBreakerConfiguration这个配置类。</p>
<p>这个配置类内部构造了一个aspect：</p>
<pre><code>@Bean
public HystrixCommandAspect hystrixCommandAspect() {
    return new HystrixCommandAspect();
}
</code></pre><p>这个aspect对应的pointcut如下，所以使用@HystrixCommand注解修饰的方法会被这个aspect处理：</p>
<pre><code>@annotation(com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand) || @annotation(com.netflix.hystrix.contrib.javanica.annotation.HystrixCollapser)
</code></pre><p>对应的aop处理方法：</p>
<pre><code>public Object methodsAnnotatedWithHystrixCommand(final ProceedingJoinPoint joinPoint) throws Throwable {
    Method method = getMethodFromTarget(joinPoint);  // 得到初始的方法
    Validate.notNull(method, &quot;failed to get method from joinPoint: %s&quot;, joinPoint);
    if (method.isAnnotationPresent(HystrixCommand.class) &amp;&amp; method.isAnnotationPresent(HystrixCollapser.class)) { // 如果使用@HystrixCommand注解和@HystrixCollapser注解同时修改，不允许
        throw new IllegalStateException(&quot;method cannot be annotated with HystrixCommand and HystrixCollapser &quot; +
                &quot;annotations at the same time&quot;);
    }
    MetaHolderFactory metaHolderFactory = META_HOLDER_FACTORY_MAP.get(HystrixPointcutType.of(method));
    MetaHolder metaHolder = metaHolderFactory.create(joinPoint); // 创建一个MetaHolder，这个MetaHolder封装了方法中的一些以及Hystrix的一些信息
    HystrixInvokable invokable = HystrixCommandFactory.getInstance().create(metaHolder); // 根据这个metaHolder创建出一个HystrixInvokable，也就是一个HystrixCommand
    ExecutionType executionType = metaHolder.isCollapserAnnotationPresent() ?
            metaHolder.getCollapserExecutionType() : metaHolder.getExecutionType(); // 得到执行类型，有3种类型：1. 异步 2. 同步  3. reactive
    Object result;
    try {
        result = CommandExecutor.execute(invokable, executionType, metaHolder);
    } catch (HystrixBadRequestException e) {
        throw e.getCause();
    }
    return result;
}
</code></pre><p>CommandExecutor的execute方法：</p>
<pre><code>public static Object execute(HystrixInvokable invokable, ExecutionType executionType, MetaHolder metaHolder) throws RuntimeException {
    Validate.notNull(invokable);
    Validate.notNull(metaHolder);

    switch (executionType) {
        case SYNCHRONOUS: { // 同步方式的话，调用HystrixCommand的execute方法
            return castToExecutable(invokable, executionType).execute();
        }
        case ASYNCHRONOUS: { // 异步方式的话，调用HystrixCommand的queue方法
            HystrixExecutable executable = castToExecutable(invokable, executionType);
            if (metaHolder.hasFallbackMethodCommand()
                    &amp;&amp; ExecutionType.ASYNCHRONOUS == metaHolder.getFallbackExecutionType()) {
                return new FutureDecorator(executable.queue());
            }
            return executable.queue();
        }
        case OBSERVABLE: { // reactive方式的话，调用HystrixCommand的observe或者toObservable方法
            HystrixObservable observable = castToObservable(invokable);
            return ObservableExecutionMode.EAGER == metaHolder.getObservableExecutionMode() ? observable.observe() : observable.toObservable();
        }
        default:
            throw new RuntimeException(&quot;unsupported execution type: &quot; + executionType);
    }
}
</code></pre><p>根据metaHolder创建出HystrixCommand的过程在HystrixCommandBuilderFactory中：</p>
<pre><code>return HystrixCommandBuilder.builder()
            .setterBuilder(createGenericSetterBuilder(metaHolder))
            .commandActions(createCommandActions(metaHolder))
            .collapsedRequests(collapsedRequests)
            .cacheResultInvocationContext(createCacheResultInvocationContext(metaHolder))
            .cacheRemoveInvocationContext(createCacheRemoveInvocationContext(metaHolder))
            .ignoreExceptions(metaHolder.getHystrixCommand().ignoreExceptions())
            .executionType(metaHolder.getExecutionType())
            .build();
</code></pre><p>所以这个aspect的作用就是把一个普通的Java方法转换成HystrixCommand。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>HystrixCircuitBreakerConfiguration配置类中有个HystrixWebConfiguration内部配置类，它构造了一个HystrixStreamEndpoint这个endpoint，这个endpoint使用HystrixMetricsStreamServlet暴露出/hystrix.stream地址来获取hystrix的metrics信息。</p>
<p>Hystrix还提供了一个dashboard，这个dashboard可以查看各个断路器的健康状况，要使用这个dashboard，在项目中加入这些依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>然后在代码里加上开关：</p>
<pre><code>@EnableHystrixDashboard
...
</code></pre><p>启动项目，打开：</p>
<pre><code>http://localhost:3333/hystrix
</code></pre><p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/hystrix01.png" alt="image"><br>输入：</p>
<pre><code>http://localhost:3333/hystrix.stream
</code></pre><p>我们使用wrk模拟请求：</p>
<pre><code>wrk -c 10 -t 10 -d 20s http://localhost:3333/add
</code></pre><p>然后dashboard中发生了变化：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/hystrix02.png" alt="image"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://cloud.spring.io/spring-cloud-static/Brixton.SR7/" target="_blank" rel="external">http://cloud.spring.io/spring-cloud-static/Brixton.SR7/</a></p>
<p><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="external">https://github.com/Netflix/Hystrix</a></p>
<p><a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="external">https://github.com/Netflix/Hystrix/wiki</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Netflix/Hystrix&quot;&gt;Hystrix&lt;/a&gt;是一个供分布式系统使用，提供延迟和容错功能，保证复杂的分布系统在面临不可避免的失败时，仍能有其弹性。&lt;/p&gt;
&lt;p&gt;比如系统中有很多服务，当某些服务不稳定的时候，使用这些服务的用户线程将会阻塞，如果没有隔离机制，系统随时就有可能会挂掉，从而带来很大的风险。&lt;/p&gt;
&lt;p&gt;SpringCloud使用Hystrix组件提供断路器、资源隔离与自我修复功能。下图表示服务B触发了断路器，阻止了级联失败。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cloud.spring.io/spring-cloud-static/Brixton.SR7/images/HystrixFallback.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="springcloud" scheme="http://fangjian0423.github.io/categories/springcloud/"/>
    
    
      <category term="springcloud" scheme="http://fangjian0423.github.io/tags/springcloud/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Loadbalance的几种算法以及在ribbon中的使用</title>
    <link href="http://fangjian0423.github.io/2017/01/29/loadbalance/"/>
    <id>http://fangjian0423.github.io/2017/01/29/loadbalance/</id>
    <published>2017-01-29T11:32:16.000Z</published>
    <updated>2017-01-29T11:47:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Load Balance负载均衡是用于解决一台机器(一个进程)无法解决所有请求而产生的一种算法。</p>
<p>像nginx可以使用负载均衡分配流量，ribbon为客户端提供负载均衡，dubbo服务调用里的负载均衡等等，很多地方都使用到了负载均衡。</p>
<p>使用负载均衡带来的好处很明显：</p>
<ol>
<li>当集群里的1台或者多台服务器down的时候，剩余的没有down的服务器可以保证服务的继续使用</li>
<li>使用了更多的机器保证了机器的良性使用，不会由于某一高峰时刻导致系统cpu急剧上升</li>
</ol>
<p>负载均衡有好几种实现策略，常见的有：</p>
<ol>
<li>随机 (Random)</li>
<li>轮询 (RoundRobin)</li>
<li>一致性哈希 (ConsistentHash)</li>
<li>哈希 (Hash)</li>
<li>加权（Weighted）</li>
</ol>
<a id="more"></a>
<p>我们以<a href="https://github.com/Netflix/ribbon" target="_blank" rel="external">ribbon</a>的实现为基础，看看其中的一些算法是如何实现的。</p>
<p>ribbon是一个为客户端提供负载均衡功能的服务，它内部提供了一个叫做ILoadBalance的接口代表负载均衡器的操作，比如有添加服务器操作、选择服务器操作、获取所有的服务器列表、获取可用的服务器列表等等。</p>
<p>还提供了一个叫做IRule的接口代表负载均衡策略：</p>
<pre><code>public interface IRule{
    public Server choose(Object key);
    public void setLoadBalancer(ILoadBalancer lb);
    public ILoadBalancer getLoadBalancer();    
}
</code></pre><p>IRule接口的实现类有以下几种：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/loadbalance01.png" alt="image"></p>
<p>其中RandomRule表示随机策略、RoundRobin表示轮询策略、WeightedResponseTimeRule表示加权策略、BestAvailableRule表示请求数最少策略等等。</p>
<p>随机策略很简单，就是从服务器中随机选择一个服务器，RandomRule的实现代码如下：</p>
<pre><code>public Server choose(ILoadBalancer lb, Object key) {
    if (lb == null) {
        return null;
    }
    Server server = null;

    while (server == null) {
        if (Thread.interrupted()) {
            return null;
        }
        List&lt;Server&gt; upList = lb.getReachableServers();
        List&lt;Server&gt; allList = lb.getAllServers();
        int serverCount = allList.size();
        if (serverCount == 0) {
            return null;
        }
        int index = rand.nextInt(serverCount); // 使用jdk内部的Random类随机获取索引值index
        server = upList.get(index); // 得到服务器实例

        if (server == null) {
            Thread.yield();
            continue;
        }

        if (server.isAlive()) {
            return (server);
        }

        server = null;
        Thread.yield();
    }
    return server;
}
</code></pre><p>RoundRobin轮询策略表示每次都取下一个服务器，比如一共有5台服务器，第1次取第1台，第2次取第2台，第3次取第3台，以此类推：</p>
<pre><code>public Server choose(ILoadBalancer lb, Object key) {
    if (lb == null) {
        log.warn(&quot;no load balancer&quot;);
        return null;
    }

    Server server = null;
    int count = 0;
    while (server == null &amp;&amp; count++ &lt; 10) { // retry 10 次
        List&lt;Server&gt; reachableServers = lb.getReachableServers();
        List&lt;Server&gt; allServers = lb.getAllServers();
        int upCount = reachableServers.size();
        int serverCount = allServers.size();

        if ((upCount == 0) || (serverCount == 0)) {
            log.warn(&quot;No up servers available from load balancer: &quot; + lb);
            return null;
        }

        int nextServerIndex = incrementAndGetModulo(serverCount); // incrementAndGetModulo方法内部使用nextServerCyclicCounter这个AtomicInteger属性原子递增对serverCount取模得到索引值
        server = allServers.get(nextServerIndex); // 得到服务器实例

        if (server == null) {
            Thread.yield();
            continue;
        }

        if (server.isAlive() &amp;&amp; (server.isReadyToServe())) {
            return (server);
        }

        server = null;
    }

    if (count &gt;= 10) {
        log.warn(&quot;No available alive servers after 10 tries from load balancer: &quot;
                + lb);
    }
    return server;
}
</code></pre><p>BestAvailableRule策略用来选取最少并发量请求的服务器：</p>
<pre><code>public Server choose(Object key) {
    if (loadBalancerStats == null) {
        return super.choose(key);
    }
    List&lt;Server&gt; serverList = getLoadBalancer().getAllServers(); // 获取所有的服务器列表
    int minimalConcurrentConnections = Integer.MAX_VALUE;
    long currentTime = System.currentTimeMillis();
    Server chosen = null;
    for (Server server: serverList) { // 遍历每个服务器
        ServerStats serverStats = loadBalancerStats.getSingleServerStat(server); // 获取各个服务器的状态
        if (!serverStats.isCircuitBreakerTripped(currentTime)) { // 没有触发断路器的话继续执行
            int concurrentConnections = serverStats.getActiveRequestsCount(currentTime); // 获取当前服务器的请求个数
            if (concurrentConnections &lt; minimalConcurrentConnections) { // 比较各个服务器之间的请求数，然后选取请求数最少的服务器并放到chosen变量中
                minimalConcurrentConnections = concurrentConnections;
                chosen = server;
            }
        }
    }
    if (chosen == null) { // 如果没有选上，调用父类ClientConfigEnabledRoundRobinRule的choose方法，也就是使用RoundRobinRule轮询的方式进行负载均衡        
        return super.choose(key);
    } else {
        return chosen;
    }
}
</code></pre><h2 id="实例验证Ribbon中的LoadBalance功能"><a href="#实例验证Ribbon中的LoadBalance功能" class="headerlink" title="实例验证Ribbon中的LoadBalance功能"></a>实例验证Ribbon中的LoadBalance功能</h2><p>ServerList中提供了3个instance，分别是：</p>
<pre><code>compute-service:2222
compute-service:2223
compute-service:2224
</code></pre><p>然后使用不同的IRule策略查看负载均衡的实现。</p>
<p>首先先使用ribbon提供的LoadBalanced注解加在RestTemplate上面，这个注解会自动构造LoadBalancerClient接口的实现类并注册到Spring容器中。</p>
<pre><code>@Bean
@LoadBalanced
RestTemplate restTemplate() {
    return new RestTemplate();
}
</code></pre><p>接下来使用RestTemplate进行rest操作的时候，会自动使用负载均衡策略，它内部会在RestTemplate中加入LoadBalancerInterceptor这个拦截器，这个拦截器的作用就是使用负载均衡。</p>
<p>例子中，我们的实例的name叫做compute-service，里面提供了一个方法add用于相加2个Integer类型的数值。</p>
<p>loadbalance的具体操作：</p>
<pre><code>public String loadbalance() {
    ServiceInstance serviceInstance = loadBalancerClient.choose(&quot;compute-service&quot;);
    StringBuilder sb = new StringBuilder();
    sb.append(&quot;host: &quot;).append(serviceInstance.getHost()).append(&quot;, &quot;);
    sb.append(&quot;port: &quot;).append(serviceInstance.getPort()).append(&quot;, &quot;);
    sb.append(&quot;uri: &quot;).append(serviceInstance.getUri());
    return sb.toString();
}
</code></pre><h3 id="RandomRule随机策略"><a href="#RandomRule随机策略" class="headerlink" title="RandomRule随机策略"></a>RandomRule随机策略</h3><p>RandomRule：</p>
<pre><code>@Configuration
public class RibbonConfiguration {

    @Autowired
    private SpringClientFactory springClientFactory;

    @Bean
    public IRule ribbonRule() {
        return new RandomRule();
    }

}
</code></pre><p>测试结果如下，确实是随机获取的：</p>
<pre><code>host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2224, uri: http://192.168.31.113:2224
host: 192.168.31.113, port: 2224, uri: http://192.168.31.113:2224
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223    
</code></pre><h3 id="RoundRobinRule轮询策略"><a href="#RoundRobinRule轮询策略" class="headerlink" title="RoundRobinRule轮询策略"></a>RoundRobinRule轮询策略</h3><p>RoundRobinRule：</p>
<pre><code>@Bean
public IRule ribbonRule() {
    return new RandomRule();
}
</code></pre><p>测试结果如下，确实是轮询每个服务器的：</p>
<pre><code>host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2224, uri: http://192.168.31.113:2224
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2224, uri: http://192.168.31.113:2224
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2224, uri: http://192.168.31.113:2224
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2224, uri: http://192.168.31.113:2224
</code></pre><h3 id="BestAvailableRule最少并发数策略"><a href="#BestAvailableRule最少并发数策略" class="headerlink" title="BestAvailableRule最少并发数策略"></a>BestAvailableRule最少并发数策略</h3><p>BestAvailableRule：</p>
<pre><code>@Bean
public IRule ribbonRule() {
    return new BestAvailableRule();
}
</code></pre><p>如果直接访问浏览器的话，测试结果如下(因为每次访问完请求数都变成0，下次遍历永远都是2223这个端口的实例)：</p>
<pre><code>host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
..
</code></pre><p>使用wrk模拟并发请求，结果会出现多个实例：</p>
<pre><code>wrk -c 1000 -t 10 -d 10s http://localhost:3333/test
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Load Balance负载均衡是用于解决一台机器(一个进程)无法解决所有请求而产生的一种算法。&lt;/p&gt;
&lt;p&gt;像nginx可以使用负载均衡分配流量，ribbon为客户端提供负载均衡，dubbo服务调用里的负载均衡等等，很多地方都使用到了负载均衡。&lt;/p&gt;
&lt;p&gt;使用负载均衡带来的好处很明显：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当集群里的1台或者多台服务器down的时候，剩余的没有down的服务器可以保证服务的继续使用&lt;/li&gt;
&lt;li&gt;使用了更多的机器保证了机器的良性使用，不会由于某一高峰时刻导致系统cpu急剧上升&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;负载均衡有好几种实现策略，常见的有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;随机 (Random)&lt;/li&gt;
&lt;li&gt;轮询 (RoundRobin)&lt;/li&gt;
&lt;li&gt;一致性哈希 (ConsistentHash)&lt;/li&gt;
&lt;li&gt;哈希 (Hash)&lt;/li&gt;
&lt;li&gt;加权（Weighted）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="springcloud" scheme="http://fangjian0423.github.io/categories/springcloud/"/>
    
    
      <category term="algorithm" scheme="http://fangjian0423.github.io/tags/algorithm/"/>
    
      <category term="springcloud" scheme="http://fangjian0423.github.io/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>2016总结</title>
    <link href="http://fangjian0423.github.io/2017/01/01/2016_end/"/>
    <id>http://fangjian0423.github.io/2017/01/01/2016_end/</id>
    <published>2017-01-01T14:28:04.000Z</published>
    <updated>2017-01-01T14:28:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2016年总结"><a href="#2016年总结" class="headerlink" title="2016年总结"></a>2016年总结</h2><p>2016年过去了，转眼已经毕业3年多了，时间过得很快。对自己有点失望，感觉技术还没有达到自己期望的那个3年水平。</p>
<p>有进步的地方：</p>
<ol>
<li>blog从每天的200-300pv增加到了500-600pv。2016年一年达到了9w4 pv，没有突破10w，有点小遗憾。不过这不是重点，写博客的初衷是为了自己对知识点的总结，并不在乎pv</li>
<li>补了一下java的基础知识；包括常用数据结构底层的实现，数组、链表、哈希表、红黑树、跳表等；aqs、juc包下的各个工具类实现原理；jvm的一些知识点。基础好真的很关键，不然看一些东西的时候，里面的一些知识点是基础知识，不了解的话还得重新去补基础知识</li>
<li>把springboot的实现原理看了一下，这样就可以知道官方或者一些第三方提供的starter底层到底做了什么事情。不然只能查阅官方文档，文档里如果又没写相关内容的话，还是得看源码解决。最后自己尝试着写了个starter练练手</li>
<li>熟悉了一下springcloud和dubbo这2个框架。以前rpc相关的只是用过hessian框架，发现dubbo很强大，封装地也很好，而且文档也很详细，是一个值得学习的好框架</li>
<li>学习了一下netty和nio相关的内容，由于工作中没有用到，算是自我补充了知识点</li>
<li>把flume的一些组件的源码看了一遍，发现了有不合理的地方，但是进行改进的话也会引入其他的一些问题。flume的实现还是有缺陷的，需要配合一些额外的操作才能把数据收集这块做得更好。比如实时报错，错误数据重跑，重启策略等</li>
<li>写了spark相关的计算，由于精力有限，并没有深入地研究spark的东西</li>
<li>看了分布式相关的一些内容，比如一致性哈希、心跳检测、分布式锁、cap原理等</li>
</ol>
<p>懂了一些道理：</p>
<ol>
<li>自己觉得对的事情，一定要尽早去做，不然可能会来不及，如果错过后，就会很后悔</li>
<li>拥有的时候，一定要珍惜。等到失去后，会很后悔</li>
<li>要有耐心地听别人说话，不能显得很不耐烦</li>
<li>对自己说的话要负责，话说出去就收不回来了</li>
<li>做决定前，要冷静。伤害了别人也等于伤害了自己</li>
<li>换位思考。对别人做的事，别人反过来也对你这么做，自己是什么感受</li>
</ol>
<p>2017年的计划还没有想过，最近发生了很多事，等稳定下来后再去定计划。</p>
]]></content>
    
    <summary type="html">
    
      2016年总结
    
    </summary>
    
      <category term="总结" scheme="http://fangjian0423.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="杂事" scheme="http://fangjian0423.github.io/tags/%E6%9D%82%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot编写自定义的starter</title>
    <link href="http://fangjian0423.github.io/2016/11/16/springboot-custom-starter/"/>
    <id>http://fangjian0423.github.io/2016/11/16/springboot-custom-starter/</id>
    <published>2016-11-15T17:40:32.000Z</published>
    <updated>2016-11-23T07:32:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章中，我们分析过SpringBoot内部的<a href="http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/">自动化配置原理</a>和<a href="http://fangjian0423.github.io/2016/11/13/springboot-enable-annotation/">自动化配置注解开关原理</a>。</p>
<p>我们先简单分析一下<a href="https://github.com/mybatis/spring-boot-starter" target="_blank" rel="external">mybatis starter</a>的编写，然后再编写自定义的starter。</p>
<p>mybatis中的autoconfigure模块中使用了一个叫做MybatisAutoConfiguration的自动化配置类。</p>
<p>这个MybatisAutoConfiguration需要在这些Condition条件下才会执行：</p>
<ol>
<li>@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class })。需要SqlSessionFactory和SqlSessionFactoryBean在classpath中都存在</li>
<li>@ConditionalOnBean(DataSource.class)。 spring factory中需要存在一个DataSource的bean</li>
<li>@AutoConfigureAfter(DataSourceAutoConfiguration.class)。需要在DataSourceAutoConfiguration自动化配置之后进行配置，因为mybatis需要数据源的支持</li>
</ol>
<p>同时在META-INF目录下有个spring.factories这个properties文件，而且它的key为org.springframework.boot.autoconfigure.EnableAutoConfiguration，这样才会被springboot加载：</p>
<pre><code># Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration
</code></pre><p>有了这些东西之后，mybatis相关的配置会被自动加入到spring container中，只要在maven中加入starter即可：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><a id="more"></a>
<h2 id="编写自定义的starter"><a href="#编写自定义的starter" class="headerlink" title="编写自定义的starter"></a>编写自定义的starter</h2><p>接下来，我们来编写自定义的starter：log-starter。</p>
<p>这个starter内部定义了一个注解，使用这个注解修饰方法之后，该方法的调用会在日志中被打印并且还会打印出方法的耗时。starter支持exclude配置，在exclude中出现的方法不会进行计算。</p>
<p>pom文件：</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starters&lt;/artifactId&gt;
    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>定义修饰方法的注解@Log：</p>
<pre><code>package me.format.springboot.log.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;    

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Log { }
</code></pre><p>然后是配置类：</p>
<pre><code>package me.format.springboot.log.autoconfigure;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.util.StringUtils;

import javax.annotation.PostConstruct;

@ConfigurationProperties(prefix = &quot;mylog&quot;)
public class LogProperties {

    private String exclude;

    private String[] excludeArr;

    @PostConstruct
    public void init() {
        this.excludeArr = StringUtils.split(exclude, &quot;,&quot;);
    }

    public String getExclude() {
        return exclude;
    }

    public void setExclude(String exclude) {
        this.exclude = exclude;
    }

    public String[] getExcludeArr() {
        return excludeArr;
    }
}
</code></pre><p>接下来是AutoConfiguration：</p>
<pre><code>package me.format.springboot.log.autoconfigure;

import me.format.springboot.log.annotation.Log;
import me.format.springboot.log.aop.LogMethodInterceptor;
import org.aopalliance.aop.Advice;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.aop.Pointcut;
import org.springframework.aop.support.AbstractPointcutAdvisor;
import org.springframework.aop.support.annotation.AnnotationMatchingPointcut;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import javax.annotation.PostConstruct;

@Configuration
@EnableConfigurationProperties(LogProperties.class)
public class LogAutoConfiguration extends AbstractPointcutAdvisor {

    private Logger logger = LoggerFactory.getLogger(LogAutoConfiguration.class);

    private Pointcut pointcut;

    private Advice advice;

    @Autowired
    private LogProperties logProperties;

    @PostConstruct
    public void init() {
        logger.info(&quot;init LogAutoConfiguration start&quot;);
        this.pointcut = new AnnotationMatchingPointcut(null, Log.class);
        this.advice = new LogMethodInterceptor(logProperties.getExcludeArr());
        logger.info(&quot;init LogAutoConfiguration end&quot;);
    }

    @Override
    public Pointcut getPointcut() {
        return this.pointcut;
    }

    @Override
    public Advice getAdvice() {
        return this.advice;
    }

}
</code></pre><p>由于计算方法调用的时候需要使用aop相关的lib，所以我们的AutoConfiguration继承了AbstractPointcutAdvisor。这样就有了Pointcut和Advice。Pointcut是一个支持注解的修饰方法的Pointcut，Advice则自己实现：</p>
<pre><code>package me.format.springboot.log.aop;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Arrays;
import java.util.List;

public class LogMethodInterceptor implements MethodInterceptor {
    private Logger logger = LoggerFactory.getLogger(LogMethodInterceptor.class);
    private List&lt;String&gt; exclude;
    public LogMethodInterceptor(String[] exclude) {
        this.exclude = Arrays.asList(exclude);
    }
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        String methodName = invocation.getMethod().getName();
        if(exclude.contains(methodName)) {
            return invocation.proceed();
        }
        long start = System.currentTimeMillis();
        Object result = invocation.proceed();
        long end = System.currentTimeMillis();
        logger.info(&quot;====method({}), cost({}) &quot;, methodName, (end - start));
        return result;
    }
}
</code></pre><p>最后resources/META-INF/spring.factories中加入这个AutoConfiguration：</p>
<pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
me.format.springboot.log.autoconfigure.LogAutoConfiguration
</code></pre><p>我们在项目中使用这个log-starter：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;me.format.springboot&lt;/groupId&gt;
    &lt;artifactId&gt;log-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>使用配置：</p>
<pre><code>mylog.exclude=core,log
</code></pre><p>然后编写一个简单的Service：</p>
<pre><code>@Service
public class SimpleService {

    @Log
    public void test(int num) {
        System.out.println(&quot;----test---- &quot; + num);
    }

    @Log
    public void core(int num) {
        System.out.println(&quot;----core---- &quot; + num);
    }

    public void work(int num) {
        System.out.println(&quot;----work---- &quot; + num);
    }

}
</code></pre><p>使用单元测试分别调用这3个方法，由于work方法没有加上@Log注解，core方法虽然加上了@Log注解，但是在配置中被exclude了，只有test方法可以正常计算耗时：</p>
<pre><code>----test---- 666
2016-11-16 01:29:32.255  INFO 41010 --- [           main] m.f.s.log.aop.LogMethodInterceptor       : ====method(test),     cost(36) 
----work---- 666
----core---- 666
</code></pre><p>总结：</p>
<p>自定义springboot的starter，注意这两点。</p>
<ol>
<li>如果自动化配置类需要在程序启动的时候就加载，可以在META-INF/spring.factories文件中定义。如果本次加载还需要其他一些lib的话，可以使用ConditionalOnClass注解协助</li>
<li>如果自动化配置类要在使用自定义注解后才加载，可以使用自定义注解+@Import注解或@ImportSelector注解完成</li>
</ol>
<p>参考：</p>
<p><a href="http://www.jianshu.com/p/85460c1d835a" target="_blank" rel="external">http://www.jianshu.com/p/85460c1d835a</a></p>
<p><a href="http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-auto-configuration.html" target="_blank" rel="external">http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-auto-configuration.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的文章中，我们分析过SpringBoot内部的&lt;a href=&quot;http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/&quot;&gt;自动化配置原理&lt;/a&gt;和&lt;a href=&quot;http://fangjian0423.github.io/2016/11/13/springboot-enable-annotation/&quot;&gt;自动化配置注解开关原理&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们先简单分析一下&lt;a href=&quot;https://github.com/mybatis/spring-boot-starter&quot;&gt;mybatis starter&lt;/a&gt;的编写，然后再编写自定义的starter。&lt;/p&gt;
&lt;p&gt;mybatis中的autoconfigure模块中使用了一个叫做MybatisAutoConfiguration的自动化配置类。&lt;/p&gt;
&lt;p&gt;这个MybatisAutoConfiguration需要在这些Condition条件下才会执行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class })。需要SqlSessionFactory和SqlSessionFactoryBean在classpath中都存在&lt;/li&gt;
&lt;li&gt;@ConditionalOnBean(DataSource.class)。 spring factory中需要存在一个DataSource的bean&lt;/li&gt;
&lt;li&gt;@AutoConfigureAfter(DataSourceAutoConfiguration.class)。需要在DataSourceAutoConfiguration自动化配置之后进行配置，因为mybatis需要数据源的支持&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同时在META-INF目录下有个spring.factories这个properties文件，而且它的key为org.springframework.boot.autoconfigure.EnableAutoConfiguration，这样才会被springboot加载：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有了这些东西之后，mybatis相关的配置会被自动加入到spring container中，只要在maven中加入starter即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.1.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动化配置的注解开关原理</title>
    <link href="http://fangjian0423.github.io/2016/11/13/springboot-enable-annotation/"/>
    <id>http://fangjian0423.github.io/2016/11/13/springboot-enable-annotation/</id>
    <published>2016-11-13T08:22:51.000Z</published>
    <updated>2016-11-23T07:29:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前我们分析<a href="http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/">SpringBoot的自动化配置原理</a>的时候，分析了freemarker的自动化配置类FreeMarkerAutoConfiguration，这个自动化配置类需要classloader中的一些类需要存在并且在其他的一些配置类之后进行加载。</p>
<p>但是还存在一些自动化配置类，它们需要在使用一些注解开关的情况下才会生效。比如spring-boot-starter-batch里的@EnableBatchProcessing注解、@EnableCaching等。</p>
<a id="more"></a>
<h2 id="一个需求"><a href="#一个需求" class="headerlink" title="一个需求"></a>一个需求</h2><p>在分析这些开关的原理之前，我们来看一个需求：</p>
<pre><code>定义一个Annotation，让使用了这个Annotaion的应用程序自动化地注入一些类或者做一些底层的事情。
</code></pre><p>我们会使用Spring提供的@Import注解配合一个配置类来完成。</p>
<p>我们以一个最简单的例子来完成这个需求：定义一个注解EnableContentService，使用了这个注解的程序会自动注入ContentService这个bean。</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Import(ContentConfiguration.class)
public @interface EnableContentService {}

public interface ContentService {
    void doSomething();
}

public class SimpleContentService implements ContentService {
    @Override
    public void doSomething() {
        System.out.println(&quot;do some simple things&quot;);
    }
}
</code></pre><p>然后在应用程序的入口加上@EnableContentService注解。</p>
<p>这样的话，ContentService就被注入进来了。 SpringBoot也就是用这个完成的。只不过它用了更加高级点的ImportSelector。</p>
<h2 id="ImportSelector的使用"><a href="#ImportSelector的使用" class="headerlink" title="ImportSelector的使用"></a>ImportSelector的使用</h2><p>用了ImportSelector之后，我们可以在Annotation上添加一些属性，然后根据属性的不同加载不同的bean。</p>
<p>我们在@EnableContentService注解添加属性policy，同时Import一个Selector。</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Import(ContentImportSelector.class)
public @interface EnableContentService {
    String policy() default &quot;simple&quot;;
}
</code></pre><p>这个ContentImportSelector根据EnableContentService注解里的policy加载不同的bean。</p>
<pre><code>public class ContentImportSelector implements ImportSelector {

    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        Class&lt;?&gt; annotationType = EnableContentService.class;
        AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(
                annotationType.getName(), false));
        String policy = attributes.getString(&quot;policy&quot;);
        if (&quot;core&quot;.equals(policy)) {
            return new String[] { CoreContentConfiguration.class.getName() };
        } else {
            return new String[] { SimpleContentConfiguration.class.getName() };
        }
    }

}
</code></pre><p>CoreContentService和CoreContentConfiguration如下：</p>
<pre><code>public class CoreContentService implements ContentService {
    @Override
    public void doSomething() {
        System.out.println(&quot;do some import things&quot;);
    }
}

public class CoreContentConfiguration {
    @Bean
    public ContentService contentService() {
        return new CoreContentService();
    }
}
</code></pre><p>这样的话，如果在@EnableContentService注解的policy中使用core的话，应用程序会自动加载CoreContentService，否则会加载SimpleContentService。</p>
<h2 id="ImportSelector在SpringBoot中的使用"><a href="#ImportSelector在SpringBoot中的使用" class="headerlink" title="ImportSelector在SpringBoot中的使用"></a>ImportSelector在SpringBoot中的使用</h2><p>SpringBoot里的ImportSelector是通过SpringBoot提供的@EnableAutoConfiguration这个注解里完成的。</p>
<p>这个@EnableAutoConfiguration注解可以显式地调用，否则它会在@SpringBootApplication注解中隐式地被调用。</p>
<p>@EnableAutoConfiguration注解中使用了EnableAutoConfigurationImportSelector作为ImportSelector。下面这段代码就是EnableAutoConfigurationImportSelector中进行选择的具体代码：</p>
<pre><code>@Override
public String[] selectImports(AnnotationMetadata metadata) {
    try {
        AnnotationAttributes attributes = getAttributes(metadata);
        List&lt;String&gt; configurations = getCandidateConfigurations(metadata,
                attributes);
        configurations = removeDuplicates(configurations); // 删除重复的配置
        Set&lt;String&gt; exclusions = getExclusions(metadata, attributes); // 去掉需要exclude的配置
        configurations.removeAll(exclusions);
        configurations = sort(configurations); // 排序
        recordWithConditionEvaluationReport(configurations, exclusions);
        return configurations.toArray(new String[configurations.size()]);
    }
    catch (IOException ex) {
        throw new IllegalStateException(ex);
    }
}
</code></pre><p>其中getCandidateConfigurations方法将获取配置类：</p>
<pre><code>protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata,
        AnnotationAttributes attributes) {
    return SpringFactoriesLoader.loadFactoryNames(
            getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());
}
</code></pre><p>SpringFactoriesLoader.loadFactoryNames方法会根据FACTORIES_RESOURCE_LOCATION这个静态变量从所有的jar包中读取META-INF/spring.factories文件信息：</p>
<pre><code>public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) {
    String factoryClassName = factoryClass.getName();
    try {
        Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :
                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
        List&lt;String&gt; result = new ArrayList&lt;String&gt;();
        while (urls.hasMoreElements()) {
            URL url = urls.nextElement();
            Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));
            String factoryClassNames = properties.getProperty(factoryClassName); // 只会过滤出key为factoryClassNames的值
            result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));
        }
        return result;
    }
    catch (IOException ex) {
        throw new IllegalArgumentException(&quot;Unable to load [&quot; + factoryClass.getName() +
                &quot;] factories from location [&quot; + FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);
    }
}
</code></pre><p>getCandidateConfigurations方法中的getSpringFactoriesLoaderFactoryClass方法返回的是EnableAutoConfiguration.class，所以会过滤出key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的值。</p>
<p>下面这段配置代码就是autoconfigure这个jar包里的spring.factories文件的一部分内容(有个key为org.springframework.boot.autoconfigure.EnableAutoConfiguration，所以会得到这些AutoConfiguration)：</p>
<pre><code># Initializers
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer

# Application Listeners
org.springframework.context.ApplicationListener=\
org.springframework.boot.autoconfigure.BackgroundPreinitializer

# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
org.springframework.boot.autoconfigure.MessageSourceAutoConfiguration,\
</code></pre><p>当然了，这些AutoConfiguration不是所有都会加载的，会根据AutoConfiguration上的@ConditionalOnClass等条件判断是否加载。</p>
<p>上面这个例子说的读取properties文件的时候只会过滤出key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的值。</p>
<p>SpringBoot内部还有一些其他的key用于过滤得到需要加载的类：</p>
<ul>
<li><p>org.springframework.test.context.TestExecutionListener</p>
</li>
<li><p>org.springframework.beans.BeanInfoFactory</p>
</li>
<li><p>org.springframework.context.ApplicationContextInitializer</p>
</li>
<li><p>org.springframework.context.ApplicationListener</p>
</li>
<li><p>org.springframework.boot.SpringApplicationRunListener</p>
</li>
<li><p>org.springframework.boot.env.EnvironmentPostProcessor</p>
</li>
<li><p>org.springframework.boot.env.PropertySourceLoader</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前我们分析&lt;a href=&quot;http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/&quot;&gt;SpringBoot的自动化配置原理&lt;/a&gt;的时候，分析了freemarker的自动化配置类FreeMarkerAutoConfiguration，这个自动化配置类需要classloader中的一些类需要存在并且在其他的一些配置类之后进行加载。&lt;/p&gt;
&lt;p&gt;但是还存在一些自动化配置类，它们需要在使用一些注解开关的情况下才会生效。比如spring-boot-starter-batch里的@EnableBatchProcessing注解、@EnableCaching等。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="spring" scheme="http://fangjian0423.github.io/tags/spring/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBatch中的retry和skip机制实现分析</title>
    <link href="http://fangjian0423.github.io/2016/11/09/springbatch-retry-skip/"/>
    <id>http://fangjian0423.github.io/2016/11/09/springbatch-retry-skip/</id>
    <published>2016-11-09T00:15:22.000Z</published>
    <updated>2016-11-09T04:22:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://projects.spring.io/spring-batch/" target="_blank" rel="external">SpringBatch</a>是spring框架下的一个子模块，用于处理批处理的批次框架。</p>
<p>本文主要分析SpringBatch中的retry和skip机制的实现。</p>
<p>先简单说明下SpringBatch在SpringBoot中的使用。</p>
<p>如果要在springboot中使用batch的话，直接加入以下依赖即可：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-batch&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>然后使用注解开启Batch模块：</p>
<pre><code>...
@EnableBatchProcessing
public class Application { ... }
</code></pre><p>之后就可以注入JobBuilderFactory和StepBuilderFactory：</p>
<pre><code>@Autowired
private JobBuilderFactory jobs;

@Autowired
private StepBuilderFactory steps;
</code></pre><p>有了这2个factory之后，就可以build job。</p>
<a id="more"></a>
<p>SpringBatch中的相关基础概念比如ItemReader、ItemWriter、Chunk等本文就不介绍了。</p>
<p>我们以FlatFileItemReader作为reader，一个自定义Writer用于打印reader中读取出来的数据。</p>
<p>这个定义的writer遇到good job这条数据的时候会报错，具体逻辑如下：</p>
<pre><code>@Override
public void write(List&lt;? extends String&gt; items) throws Exception {
    System.out.println(&quot;handle start =====&quot; + items);
    for(String a : items) {
        if(a.equals(&quot;good job&quot;)) {
            throw new Exception(&quot;custom exception&quot;);
        }
    }
    System.out.println(&quot;handle end.. -----&quot; + items);
}
</code></pre><p>其中reader中读取的文件中的数据如下：</p>
<pre><code>hello world
hello coder
good job
cool
66666
</code></pre><p>我们使用StepBuilderFactory构造Step，chunkSize设置为2。然后在job1中使用并执行：</p>
<pre><code>stepBuilderFactory.get(&quot;test-step&quot;).chunk(2).reader(reader).writer(writer).build();
</code></pre><p>执行job1后console打印如下：</p>
<pre><code>handle start =====[hello world, hello coder]
handle end.. -----[hello world, hello coder]
handle start =====[good job, cool]
</code></pre><p>job1遇到了good job这条数据，writer抛出了异常，由于没有使用skip或者retry机制，导致整个流程停止。job1的处理流程底层在<strong>SimpleChunkProcessor</strong>这个类中完成，包括processor、writer的使用。</p>
<p>接下里我们构造一个job2，job2使用skip机制(其中skipLimit必须要和skip(Class&lt;? extends Throwable&gt; type)一起使用)，skip机制可以防止writer发生异常后不停止整个job，但是需要同时满足skip的限制次数和skip对应的Exception是发生异常的父类或自身关系条件才不会停止整个job，这里我们使用Exception作为异常和Integer.MAX_VALUE作为skip的限制次数为例：</p>
<pre><code>stepBuilderFactory.get.get(&quot;test-step&quot;).chunk(2).reader(reader).writer(writer).faultTolerant().skipLimit(Integer.MAX_VALUE).skip(Exception.class).build();
</code></pre><p>执行job2    后console打印如下：</p>
<pre><code>handle start =====[hello world, hello coder]
handle end.. -----[hello world, hello coder]
handle start =====[good job, cool]
handle start =====[good job]
handle start =====[cool]
handle end.. -----[cool]
handle start =====[66666]
handle end.. -----[66666]
</code></pre><p>我们看到good job这条数据发生的异常被skip掉了，job完整的执行。</p>
<p>但是发现了另外一个问题，那就是处理 [good job, cool] 这批数据的时候，发生了异常，但是接下来执行了 [good job] 和 [cool] 这两批chunk为1的批次。这是在ItemWriter中执行的，它也会在ItemWriteListener中执行多次。</p>
<p><strong>换句话说，如果使用了skip功能，那么对于需要被skip的批次数据中会进行scan操作找出具体是哪1条数据的原因，这里的scan操作指的是一条一条数据的遍历。</strong></p>
<p>这个过程为什么叫scan呢?  在源码中，FaultTolerantChunkProcessor类(处理带有skip或者retry机制的处理器，跟SimpleChunkProcessor类似，只不过SimpleChunkProcessor处理简单的Job)里有个私有方法scan：</p>
<pre><code>private void scan(final StepContribution contribution, final Chunk&lt;I&gt; inputs, final Chunk&lt;O&gt; outputs,
        ChunkMonitor chunkMonitor, boolean recovery) throws Exception {

    ...

    Chunk&lt;I&gt;.ChunkIterator inputIterator = inputs.iterator();
    Chunk&lt;O&gt;.ChunkIterator outputIterator = outputs.iterator();

    List&lt;O&gt; items = Collections.singletonList(outputIterator.next()); // 拿出需要写的数据中的每一条数据
    inputIterator.next();
    try {
        writeItems(items); // 写每条数据
        doAfterWrite(items);
        contribution.incrementWriteCount(1);
        inputIterator.remove();
        outputIterator.remove();
    }
    catch (Exception e) { // 写的时候如果发生了异常
        doOnWriteError(e, items);
        if (!shouldSkip(itemWriteSkipPolicy, e, -1) &amp;&amp; !rollbackClassifier.classify(e)) {
            inputIterator.remove();
            outputIterator.remove();
        }
        else {
            // 具体的skip策略
            checkSkipPolicy(inputIterator, outputIterator, e, contribution, recovery);
        }
        if (rollbackClassifier.classify(e)) {
            throw e;
        }
    }
    chunkMonitor.incrementOffset();
    if (outputs.isEmpty()) { // 批次里的所有数据处理完毕之后 scanning 设置为false
        data.scanning(false);
        inputs.setBusy(false);
        chunkMonitor.resetOffset();
    }
}
</code></pre><p>这个scan方法触发的条件是UserData这个内部类里的scanning被设置为true，这里被设置为true是在处理批次数据出现异常后并且不能retry的情况下才会被设置的。</p>
<pre><code>try {
    batchRetryTemplate.execute(retryCallback, recoveryCallback, new DefaultRetryState(inputs,
            rollbackClassifier));
}
catch (Exception e) {
    RetryContext context = contextHolder.get();
     if (!batchRetryTemplate.canRetry(context)) {
         // 设置scanning为true
        data.scanning(true);
    }
    throw e;
}
</code></pre><p>这就是为什么skip机制在skip数据的时候会去scan批次中的每条数据，然后并找出需要被skip的数据的原理。</p>
<p>job3带有retry功能，retry的功能在于出现某个异常并且这个异常可以被retry所接受的话会进行retry，retry的次数可以进行配置，我们配置了3次retry：</p>
<pre><code>stepBuilderFactory.get.get(&quot;test-step&quot;).chunk(2).reader(reader).writer(writer).faultTolerant().skipLimit(Integer.MAX_VALUE).skip(Exception.class).retryLimit(3).retry(Exception.class).build();
</code></pre><p>执行 job3后console打印如下：</p>
<pre><code>handle start =====[hello world, hello coder]
handle end.. -----[hello world, hello coder]
handle start =====[good job, cool]
handle start =====[good job, cool]
handle start =====[good job, cool]
handle start =====[good job]
handle start =====[cool]
handle end.. -----[cool]
handle start =====[66666]
handle end.. -----[66666]
</code></pre><p>[good job, cool] 这批数据retry了3次，而且都失败了。失败之后进行了skip操作。</p>
<p>SpringBatch中的retry和skip都有对应的policy实现，默认的retry policy是SimpleRetryPolicy，可以设置retry次数和接收的exception。比如可以使用NeverRetryPolicy：</p>
<pre><code>.retryPolicy(new NeverRetryPolicy())
</code></pre><p>使用NeverRetryPolicy之后，便不再retry了，只会skip。SpringBatch内部的retry是使用Spring的<a href="https://github.com/spring-projects/spring-retry" target="_blank" rel="external">retry模块</a>完成的。执行的时候可以设置RetryCallback和RecoveryCallback。</p>
<p>SpringBatch中默认的skip policy是LimitCheckingItemSkipPolicy。</p>
<p>参考资料: </p>
<p><a href="http://stackoverflow.com/questions/16567432/how-is-the-skipping-implemented-in-spring-batch" target="_blank" rel="external">http://stackoverflow.com/questions/16567432/how-is-the-skipping-implemented-in-spring-batch</a></p>
<p><a href="http://docs.spring.io/spring-batch/reference/html/retry.html" target="_blank" rel="external">http://docs.spring.io/spring-batch/reference/html/retry.html</a></p>
<p><a href="https://github.com/spring-projects/spring-retry" target="_blank" rel="external">https://github.com/spring-projects/spring-retry</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://projects.spring.io/spring-batch/&quot;&gt;SpringBatch&lt;/a&gt;是spring框架下的一个子模块，用于处理批处理的批次框架。&lt;/p&gt;
&lt;p&gt;本文主要分析SpringBatch中的retry和skip机制的实现。&lt;/p&gt;
&lt;p&gt;先简单说明下SpringBatch在SpringBoot中的使用。&lt;/p&gt;
&lt;p&gt;如果要在springboot中使用batch的话，直接加入以下依赖即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-batch&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后使用注解开启Batch模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
@EnableBatchProcessing
public class Application { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后就可以注入JobBuilderFactory和StepBuilderFactory：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Autowired
private JobBuilderFactory jobs;

@Autowired
private StepBuilderFactory steps;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有了这2个factory之后，就可以build job。&lt;/p&gt;
    
    </summary>
    
      <category term="spring" scheme="http://fangjian0423.github.io/categories/spring/"/>
    
    
      <category term="spring" scheme="http://fangjian0423.github.io/tags/spring/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springbatch" scheme="http://fangjian0423.github.io/tags/springbatch/"/>
    
  </entry>
  
  <entry>
    <title>java Annotation的RetentionPolicy介绍</title>
    <link href="http://fangjian0423.github.io/2016/11/04/java-annotation-retentionpolicy/"/>
    <id>http://fangjian0423.github.io/2016/11/04/java-annotation-retentionpolicy/</id>
    <published>2016-11-03T16:01:06.000Z</published>
    <updated>2016-11-03T16:03:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java Annotation对应的Retention有3种，在RetentionPolicy中定义，有3种：</p>
<ol>
<li>SOURCE. 注解保留在源代码中，但是编译的时候会被编译器所丢弃。比如@Override, @SuppressWarnings</li>
<li>CLASS. 这是默认的policy。注解会被保留在class文件中，但是在运行时期间就不会识别这个注解。</li>
<li>RUNTIME. 注解会被保留在class文件中，同时运行时期间也会被识别。所以可以使用反射机制获取注解信息。比如@Deprecated</li>
</ol>
<a id="more"></a>
<h2 id="RUNTIME"><a href="#RUNTIME" class="headerlink" title="RUNTIME"></a>RUNTIME</h2><p>大部分情况下，我们都是使用RUNTIME这个Policy。</p>
<p>下面就是一个RUNTIME Annotation的例子。</p>
<p>先定义Annotation：</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface MyClassRuntimeAnno {
    String name();
    int level() default 1;
}
</code></pre><p>然后在CLASS前面使用这个Annotation。</p>
<pre><code>@MyClassRuntimeAnno(name = &quot;simple&quot;, level = 10)
public class SimpleObj {
}
</code></pre><p>最后写一个testcase通过反射可以获取这个类的Annotation进行后续操作。</p>
<pre><code>@Test
public void testGetAnnotation() {
    Annotation[] annotations = SimpleObj.class.getAnnotations();
    System.out.println(Arrays.toString(annotations));
    MyClassRuntimeAnno myClassAnno = SimpleObj.class.getAnnotation(MyClassRuntimeAnno.class);
    System.out.println(myClassAnno.name() + &quot;, &quot; + myClassAnno.level());
    System.out.println(myClassAnno == annotations[0]);
}
</code></pre><h2 id="SOURCE"><a href="#SOURCE" class="headerlink" title="SOURCE"></a>SOURCE</h2><p>SOURCE这个policy表示注解保留在源代码中，但是编译的时候会被编译器所丢弃。 由于在编译的过程中这个注解还被保留着，所以在编译过程中可以针对这个policy进行一些操作。比如在自动生成java代码的场景下使用。最常见的就是<a href="https://projectlombok.org/" target="_blank" rel="external">lombok</a>的使用了，可以自动生成field的get和set方法以及toString方法，构造器等；消除了冗长的java代码。</p>
<p>SOURCE这个policy可以使用jdk中的javax.annotation.processing.*包中的processor处理器进行注解的处理过程。</p>
<p>以1个编译过程中会打印类中的方法的例子来说明SOUCRE这个policy的作用：</p>
<p>首先定义一个Printer注解：</p>
<pre><code>@Retention(RetentionPolicy.SOURCE)
@Target(ElementType.METHOD)
public @interface Printer {
}
</code></pre><p>然后一个类的方法使用这个注解：</p>
<pre><code>public class SimpleObject {

    @Printer
    public void methodA() {

    }

    public void methodB() {

    }

}
</code></pre><p>创建对应的Processor：</p>
<pre><code>@SupportedAnnotationTypes({&quot;me.format.annotaion.Printer&quot;})
public class PrintProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
        Messager messager = processingEnv.getMessager();
        messager.printMessage(Diagnostic.Kind.NOTE, &quot;start to use PrintProcessor ..&quot;);


        Set&lt;? extends Element&gt; rootElements = roundEnv.getRootElements();
        messager.printMessage(Diagnostic.Kind.NOTE, &quot;root classes: &quot;);
        for(Element root : rootElements) {
            messager.printMessage(Diagnostic.Kind.NOTE, &quot;&gt;&gt; &quot; + root.toString());
        }
        messager.printMessage(Diagnostic.Kind.NOTE, &quot;annotation: &quot;);
        for(TypeElement te : annotations) {
            messager.printMessage(Diagnostic.Kind.NOTE, &quot;&gt;&gt;&gt; &quot; + te.toString());
            Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(te);
            for(Element ele : elements) {
                messager.printMessage(Diagnostic.Kind.NOTE, &quot;&gt;&gt;&gt;&gt; &quot; + ele.toString());
            }
        }

        return true;
    }
    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }
}
</code></pre><p>然后先使用javac编译Printer和PrintProcessor：</p>
<pre><code>javac -d classes src/main/java/me/format/annotation/Printer.java src/main/java/me/format/annotation/PrintProcessor.java
</code></pre><p>最后再使用javac中的processor参数处理：</p>
<pre><code>javac -cp classes -processor me.format.annotation.PrintProcessor -d classes src/main/java/me/format/annotation/SimpleObject.java
</code></pre><p>控制台打印出：</p>
<pre><code>注: start to use PrintProcessor ..
注: root classes: 
注: &gt;&gt; hello.annotation.SimpleObject
注: annotation: 
注: &gt;&gt;&gt; hello.annotation.Printer
注: &gt;&gt;&gt;&gt; methodA()
</code></pre><h2 id="CLASS"><a href="#CLASS" class="headerlink" title="CLASS"></a>CLASS</h2><p>CLASS和RUNTIME的唯一区别是RUNTIME在运行时期间注解是存在的，而CLASS则不存在。</p>
<p>我们通过<a href="http://asm.ow2.org/" target="_blank" rel="external">asm</a>来获取class文件里的annotation。</p>
<p>首先定义注解：</p>
<p>policy为CLASS的注解。</p>
<pre><code>@Retention(RetentionPolicy.CLASS)
@Target(ElementType.TYPE)
public @interface Meta {

    String name();

}
</code></pre><p>policy为RUNTIME的注解。</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Header {

    int code();

}
</code></pre><p>使用注解：</p>
<pre><code>@Meta(name = &quot;obj&quot;)
@Header(code = 200)
public class AnnotationObject {

    private String val;

    public String getVal() {
        return val;
    }

    public void setVal(String val) {
        this.val = val;
    }
}
</code></pre><p>编译这3个java文件得到字节码文件AnnotationObject.class：</p>
<pre><code>javac -d classes src/main/java/me/format/annotaion/AnnotationObject.java src/main/java/me/format/annotation/Meta.java src/main/java/me/format/annotation/Header.java
</code></pre><p>使用asm获取字节码文件中的注解：</p>
<pre><code>ClassNode classNode = new ClassNode();

ClassReader cr = new ClassReader(new FileInputStream(&quot;classes/me/format/annotation/AnnotationObject.class&quot;));

cr.accept(classNode, 0);

System.out.println(&quot;Class Name: &quot; + classNode.name);
System.out.println(&quot;Source File: &quot; + classNode.sourceFile);

System.out.println(&quot;invisible: &quot;);
AnnotationNode anNode = null;
for (Object annotation : classNode.invisibleAnnotations) {
    anNode = (AnnotationNode) annotation;
    System.out.println(&quot;Annotation Descriptor : &quot; + anNode.desc);
    System.out.println(&quot;Annotation attribute pairs : &quot; + anNode.values);
}

System.out.println(&quot;visible: &quot;);
for (Object annotation : classNode.visibleAnnotations) {
    anNode = (AnnotationNode) annotation;
    System.out.println(&quot;Annotation Descriptor : &quot; + anNode.desc);
    System.out.println(&quot;Annotation attribute pairs : &quot; + anNode.values);
}
</code></pre><p>打印出：</p>
<pre><code>Class Name: me/format/annotation/AnnotationObject
Source File: AnnotationObject.java
invisible: 
Annotation Descriptor : Lme/format/annotation/Meta;
Annotation attribute pairs : [name, obj]
visible: 
Annotation Descriptor : Lme/format/annotation/Header;
Annotation attribute pairs : [code, 200]
</code></pre><p>其中policy为CLASS的注解编译完后不可见，而policy为RUNTIME的注解编译后可见。</p>
<p>同样，我们可以使用javap查看编译后的信息：</p>
<pre><code>javap -v me.format.annotation.AnnotationObject
</code></pre><p>会打印出注解的visible信息：</p>
<pre><code>#16 = Utf8               AnnotationObject.java
#17 = Utf8               RuntimeVisibleAnnotations
#18 = Utf8               Lhello/annotation/Header;
#19 = Utf8               code
#20 = Integer            200
#21 = Utf8               RuntimeInvisibleAnnotations
#22 = Utf8               Lhello/annotation/Meta;
#23 = Utf8               name
#24 = Utf8               obj
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java Annotation对应的Retention有3种，在RetentionPolicy中定义，有3种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SOURCE. 注解保留在源代码中，但是编译的时候会被编译器所丢弃。比如@Override, @SuppressWarnings&lt;/li&gt;
&lt;li&gt;CLASS. 这是默认的policy。注解会被保留在class文件中，但是在运行时期间就不会识别这个注解。&lt;/li&gt;
&lt;li&gt;RUNTIME. 注解会被保留在class文件中，同时运行时期间也会被识别。所以可以使用反射机制获取注解信息。比如@Deprecated&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Swagger在SpringBoot中的使用</title>
    <link href="http://fangjian0423.github.io/2016/10/09/springboot-swagger/"/>
    <id>http://fangjian0423.github.io/2016/10/09/springboot-swagger/</id>
    <published>2016-10-09T14:11:23.000Z</published>
    <updated>2016-10-09T13:50:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://swagger.io/" target="_blank" rel="external">Swagger</a>是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p>
<p>在SpringBoot中要使用Swagger的话，可以使用<a href="https://github.com/springfox/springfox" target="_blank" rel="external">springfox</a>。</p>
<p>在sbt中添加依赖即可：</p>
<pre><code>libraryDependencies += &quot;io.springfox&quot; % &quot;springfox-swagger2&quot; % &quot;2.6.0&quot;
libraryDependencies += &quot;io.springfox&quot; % &quot;springfox-swagger-ui&quot; % &quot;2.6.0&quot;
</code></pre><p>查看springfox-swagger2中的源码，发现springfox并不是通过autoconfigure实现和swagger的整合的，而是基于Spring的方式Import各种bean构造Swagger。</p>
<p>所以本文指的Swagger在SpringBoot中的使用同样也可以在Spring中使用。</p>
<a id="more"></a>
<p>要整合Spring和Swagger的话需要这么做。</p>
<ol>
<li>加上@EnableSwagger2注解</li>
<li>构造一个Docket</li>
</ol>
<p>以下代码就是例子：</p>
<pre><code>@EnableSwagger2
@Configuration
public class SwaggerConfiguration {

    @Bean
    public Docket userDocket() {
        ApiInfo apiInfo = new ApiInfo(&quot;A Simple of SpringBoot-Swagger&quot;,// 大标题
                &quot;two controllers: UserController and DeptController&quot;,// 小标题
                &quot;1.0&quot;,// 版本
                &quot;NO terms of service&quot;,
                new Contact(&quot;format&quot;, &quot;fangjian0423.github.io&quot;, &quot;fangjian0423@gmail.com&quot;), // 作者信息
                &quot;The Apache License, Version 2.0&quot;,// 开源许可证
                &quot;http://www.apache.org/licenses/LICENSE-2.0.html&quot;// 许可证详情
        );
        return new Docket(DocumentationType.SWAGGER_2)
                .select()
                .paths(Predicates.or(PathSelectors.regex(&quot;/user/.*&quot;), PathSelectors.regex(&quot;/dept/.*&quot;)))
                .build()
                .apiInfo(apiInfo);
    }

}
</code></pre><p>需要注意的是path方法表示要构造的url，这里使用了or连接了 /user/.*<em> 和 /dept/.*</em> 这2个地址，这里用的是正则的匹配方式。</p>
<p>UserController：</p>
<pre><code>@RestController
@RequestMapping(Array(&quot;/user&quot;))
class UserController {

  @ApiOperation(nickname = &quot;test method&quot;, value = &quot;just a test method&quot;)
  @RequestMapping(value = Array(&quot;/demo&quot;), method = Array(RequestMethod.POST, RequestMethod.GET))
  def demo(): String = {
    &quot;Hello Swagger&quot;
  }

  @RequestMapping(value = Array(&quot;/get/{id}&quot;), method = Array(RequestMethod.GET))
  def get(@PathVariable id: String): String = {
    s&quot;get ${id}&quot;
  }

  @RequestMapping(value = Array(&quot;/delete/{id}&quot;), method = Array(RequestMethod.POST))
  def delete(
              @ApiParam(name = &quot;id&quot;, value = &quot;the identity of user&quot;, required = true)
              @PathVariable id: String
              ): String = {
    s&quot;delete ${id}&quot;
  }

  @ApiImplicitParams(
    Array(
      new ApiImplicitParam(name = &quot;name&quot;, value = &quot;the name of user&quot;, required = true, paramType = &quot;form&quot;, dataType = &quot;string&quot;),
      new ApiImplicitParam(name = &quot;age&quot;, value = &quot;the age of user&quot;, required = true, paramType = &quot;form&quot;, dataType = &quot;int&quot;)
    )
  )

  @RequestMapping(value = Array(&quot;/add&quot;), method = Array(RequestMethod.POST))
  def add(req: HttpServletRequest): String = {
    s&quot;${req.getParameter(&quot;name&quot;)}-${req.getParameter(&quot;age&quot;)}&quot;
  }

}
</code></pre><p>Swagger默认会去找被@RequestMapping注解的方法。</p>
<p>@ApiOperation注解用于说明接口的作用，作用在方法上，如果没有使用这个注解，会去@RequestMapping中的value和method等属性。</p>
<p>@ApiParam注解用来额外说明参数的meta data。</p>
<p>@ApiImplicitParams注解也用来额外说明参数，当参数不在方法里声明的时候，可以使用这个注解。需要注意的是这个注解只能作用在方法上。</p>
<p>Swagger还提供了@ApiModel、@ApiResponse、@Example等诸多注解用于说明接口的作用。</p>
<p>另外一个Controller: </p>
<pre><code>@RestController
@RequestMapping(Array(&quot;/dept&quot;))
class DeptController {

  @ApiOperation(nickname = &quot;dept test method&quot;, value = &quot;dept just a test method&quot;)
  @RequestMapping(value = Array(&quot;/demo&quot;), method = Array(RequestMethod.POST, RequestMethod.GET))
  def demo(): String = {
    &quot;Hello Swagger&quot;
  }

}
</code></pre><p>Swagger展示如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/swagger01.png" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://swagger.io/&quot;&gt;Swagger&lt;/a&gt;是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。&lt;/p&gt;
&lt;p&gt;在SpringBoot中要使用Swagger的话，可以使用&lt;a href=&quot;https://github.com/springfox/springfox&quot;&gt;springfox&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在sbt中添加依赖即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;libraryDependencies += &amp;quot;io.springfox&amp;quot; % &amp;quot;springfox-swagger2&amp;quot; % &amp;quot;2.6.0&amp;quot;
libraryDependencies += &amp;quot;io.springfox&amp;quot; % &amp;quot;springfox-swagger-ui&amp;quot; % &amp;quot;2.6.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看springfox-swagger2中的源码，发现springfox并不是通过autoconfigure实现和swagger的整合的，而是基于Spring的方式Import各种bean构造Swagger。&lt;/p&gt;
&lt;p&gt;所以本文指的Swagger在SpringBoot中的使用同样也可以在Spring中使用。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="swagger" scheme="http://fangjian0423.github.io/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot的事务管理</title>
    <link href="http://fangjian0423.github.io/2016/10/07/springboot-transaction/"/>
    <id>http://fangjian0423.github.io/2016/10/07/springboot-transaction/</id>
    <published>2016-10-06T17:28:36.000Z</published>
    <updated>2016-10-06T17:33:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Springboot内部提供的事务管理器是根据autoconfigure来进行决定的。</p>
<p>比如当使用jpa的时候，也就是pom中加入了spring-boot-starter-data-jpa这个starter之后(之前我们分析过<a href="http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/">springboot的自动化配置原理</a>)。</p>
<p>Springboot会构造一个JpaTransactionManager这个事务管理器。</p>
<p>而当我们使用spring-boot-starter-jdbc的时候，构造的事务管理器则是DataSourceTransactionManager。</p>
<p>这2个事务管理器都实现了spring中提供的PlatformTransactionManager接口，这个接口是spring的事务核心接口。</p>
<p>这个核心接口有以下这几个常用的实现策略：</p>
<ol>
<li>HibernateTransactionManager</li>
<li>DataSourceTransactionManager</li>
<li>JtaTransactionManager</li>
<li>JpaTransactionManager</li>
</ol>
<p>具体的PlatformTransactionManager继承关系如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/transactionmanager.png" alt=""></p>
<a id="more"></a>
<p>spring-boot-starter-data-jpa这个starter会触发HibernateJpaAutoConfiguration这个自动化配置类，HibernateJpaAutoConfiguration继承了JpaBaseConfiguration基础类。</p>
<p>在JpaBaseConfiguration中构造了事务管理器：</p>
<pre><code>@Bean
@ConditionalOnMissingBean(PlatformTransactionManager.class)
public PlatformTransactionManager transactionManager() {
    return new JpaTransactionManager();
}
</code></pre><p>spring-boot-starter-jdbc会触发DataSourceTransactionManagerAutoConfiguration这个自动化配置类，也会构造事务管理器：</p>
<pre><code>@Bean
@ConditionalOnMissingBean(PlatformTransactionManager.class)
@ConditionalOnBean(DataSource.class)
public DataSourceTransactionManager transactionManager() {
    return new DataSourceTransactionManager(this.dataSource);
}
</code></pre><p>Spring的事务管理器PlatformTransactionManager接口中定义了3个方法：</p>
<pre><code>// 基于事务的传播特性，返回一个已经存在的事务或者创建一个新的事务
TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;

// 提交事务
void commit(TransactionStatus status) throws TransactionException;

// 回滚事务
void rollback(TransactionStatus status) throws TransactionException;
</code></pre><p>其中TransactionDefinition接口表示跟spring兼容的事务属性，比如传播行为、隔离级别、超时时间、是否只读等属性。</p>
<p>DefaultTransactionDefinition类是一个默认的TransactionDefinition实现，它的传播行为是PROPAGATION_REQUIRED(如果当前没事务，则创建一个，否则加入到当前事务中)，隔离级别是数据库默认级别。</p>
<p>TransactionStatus接口表示事务的状态，比如事务是否是一个刚构造的事务、事务是否已经完成等状态。</p>
<p>下面这段代码就是传统事务的常见写法：</p>
<pre><code>transaction.begin();
try {
    ...
    transaction.commit();
} catch(Exception e) {
    ...
    transaction.rollback();
} finally {

}
</code></pre><p>由于spring的事务操作被封装到了PlatformTransactionManager接口中，commit和rollback方法对应接口中的方法，begin方法在getTransaction方法中会被调用。</p>
<p>细心的读者发现文章前面构造事务管理器的时候都会加上这段注解：</p>
<pre><code>@ConditionalOnMissingBean(PlatformTransactionManager.class)
</code></pre><p>也就是说如果我们手动配置了事务管理器，Springboot就不会再为我们自动配置事务管理器。</p>
<p>如果要使用多个事务管理器的话，那么需要手动配置多个：</p>
<pre><code>@Configuration
public class DatabaseConfiguration {

    @Bean
    public PlatformTransactionManager transactionManager1(EntityManagerFactory entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory);
    }

    @Bean
    public PlatformTransactionManager transactionManager2(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }

}
</code></pre><p>然后使用Transactional注解的时候需要声明是哪个事务管理器：</p>
<pre><code>@Transactional(value=&quot;transactionManager1&quot;)
public void save() {
    doSave();
}
</code></pre><p>Spring给我们提供了一个TransactionManagementConfigurer接口，该接口只有一个方法返回PlatformTransactionManager。其中返回的PlatformTransactionManager就表示这是默认的事务处理器，这样在Transactional注解上就不需要声明是使用哪个事务管理器了。</p>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/davidwang456/p/4309038.html" target="_blank" rel="external">http://www.cnblogs.com/davidwang456/p/4309038.html</a></p>
<p><a href="http://blog.csdn.net/chjttony/article/details/6528344" target="_blank" rel="external">http://blog.csdn.net/chjttony/article/details/6528344</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Springboot内部提供的事务管理器是根据autoconfigure来进行决定的。&lt;/p&gt;
&lt;p&gt;比如当使用jpa的时候，也就是pom中加入了spring-boot-starter-data-jpa这个starter之后(之前我们分析过&lt;a href=&quot;http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/&quot;&gt;springboot的自动化配置原理&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;Springboot会构造一个JpaTransactionManager这个事务管理器。&lt;/p&gt;
&lt;p&gt;而当我们使用spring-boot-starter-jdbc的时候，构造的事务管理器则是DataSourceTransactionManager。&lt;/p&gt;
&lt;p&gt;这2个事务管理器都实现了spring中提供的PlatformTransactionManager接口，这个接口是spring的事务核心接口。&lt;/p&gt;
&lt;p&gt;这个核心接口有以下这几个常用的实现策略：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HibernateTransactionManager&lt;/li&gt;
&lt;li&gt;DataSourceTransactionManager&lt;/li&gt;
&lt;li&gt;JtaTransactionManager&lt;/li&gt;
&lt;li&gt;JpaTransactionManager&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体的PlatformTransactionManager继承关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wh6.com1.z0.glb.clouddn.com/transactionmanager.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Netty的单元测试</title>
    <link href="http://fangjian0423.github.io/2016/09/03/netty-unittest/"/>
    <id>http://fangjian0423.github.io/2016/09/03/netty-unittest/</id>
    <published>2016-09-03T13:04:52.000Z</published>
    <updated>2016-09-03T12:47:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在编写完Netty程序之后，会需要进行ChannelHandler的一些测试。</p>
<p>在初学Netty的时候，我们都是直接起一个Server，然后再写一个Client去连接Server，看传输的数据和接收到的数据是否正确。</p>
<p>在<a href="https://book.douban.com/subject/24700704/" target="_blank" rel="external">Netty in Action</a>书中的Transport和Unit-test your code这两章就提出了可以使用EmbeddedChannel进行ChanndlHandler的单元测试。</p>
<a id="more"></a>
<h2 id="EmbeddedChannel介绍"><a href="#EmbeddedChannel介绍" class="headerlink" title="EmbeddedChannel介绍"></a>EmbeddedChannel介绍</h2><p>EmbeddedChannel中提供了一些方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>writeInbound</td>
<td>写数据到Channel中，但是这些数据只会被ChannelPipeline中的inbound handler处理。如果可以从EmbeddedChannel的readInbound方法中读取出数据的话，就返回true</td>
</tr>
<tr>
<td>readInbound</td>
<td>读取在EmbeddedChannel上被所有inbound handler处理过的数据，如果已经没有数据可以读取就返回null</td>
</tr>
<tr>
<td>writeInbound</td>
<td>写数据到Channel中，但是这些数据只会被ChannelPipeline中的outbound handler处理。如果可以从EmbeddedChannel的readOutbound方法中读取出数据的话，就返回true</td>
</tr>
<tr>
<td>readOutbound</td>
<td>读取在EmbeddedChannel上被所有outbound handler处理过的数据，如果已经没有数据可以读取就返回null</td>
</tr>
<tr>
<td>finish</td>
<td>标记EmbeddedChannel已经完成。如果可以从inbound或者outbound中返回数据，该方法就返回true。这个方法还会关闭Channel</td>
</tr>
</tbody>
</table>
<p>下图就是EmbeddedChannel的处理流程图：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty10.png" alt=""></p>
<p>使用writeInbound方法写入的数据，并经过Pipeline中所有的inbound handler，之后可以使用readInbound方法读取经过inbound handler之后的数据。</p>
<p>使用writeOutbound方法写入的数据，并经过Pipeline中所有的outbound handler，之后可以使用readOutbound方法读取经过outbound handler之后的数据。</p>
<p>调用finish方法可以标记EmbeddedChannel已经完成。</p>
<h2 id="Inbound-Handler的测试"><a href="#Inbound-Handler的测试" class="headerlink" title="Inbound Handler的测试"></a>Inbound Handler的测试</h2><p>Netty内部提供了一个FixedLengthFrameDecoder解码器用于把长度不固定的字节转换成固定长度的字节，处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty11.png" alt=""></p>
<p>针对这个Decoder编写单元测试。</p>
<p>由于是个Decoder，针对的是inbound中的数据，所以需要使用的方法是writeInbound和readInbound：</p>
<pre><code>ByteBuf buf = Unpooled.buffer(); // 构造heap buffer
for(int i = 0; i &lt; 9; i ++) { // 写入9个字节
    buf.writeByte(i);
}

ByteBuf input = buf.copy();

// 构造EmbeddedChannel，并在Pipeline中加入FixedLengthFrameDecoder
EmbeddedChannel channel = new EmbeddedChannel(new FixedLengthFrameDecoder(3));

// 使用writeInbound方法写入数据
Assert.assertTrue(channel.writeInbound(input));
// 标记EmbeddedChannel状态已经complete
Assert.assertTrue(channel.finish());

// 读取经过FixedLengthFrameDecoder处理过后的字节
Assert.assertEquals(buf.readBytes(3), channel.readInbound());
Assert.assertEquals(buf.readBytes(3), channel.readInbound());
Assert.assertEquals(buf.readBytes(3), channel.readInbound());
Assert.assertNull(channel.readInbound());
</code></pre><p>我们在<a href="http://fangjian0423.github.io/2016/08/30/netty-custom-protocol/">使用Netty编写自定义的协议</a>文章中编写的自定义协议CustomProtocol的解码器，并最后通过一个server和client的编写完成了测试。</p>
<p>现在我们可以使用EmbeddedChannel进行Decoder的unit test：</p>
<pre><code>EmbeddedChannel channel = new EmbeddedChannel(new CustomProtocolDecoder());
String uuid = UUID.randomUUID().toString();
channel.writeInbound(new CustomProtocol(1024l, uuid, &quot;content content&quot;));
Assert.assertTrue(channel.finish());

CustomProtocol customProtocol = (CustomProtocol) channel.readInbound();
// 判断是否正确
Assert.assertEquals(1024l, customProtocol.getVersion());
Assert.assertEquals(uuid, customProtocol.getHeader());
Assert.assertEquals(&quot;content content&quot;, customProtocol.getContent());
Assert.assertNull(channel.readInbound());
</code></pre><h2 id="Outbound-Handler的测试"><a href="#Outbound-Handler的测试" class="headerlink" title="Outbound Handler的测试"></a>Outbound Handler的测试</h2><p>AbsIntegerEncoder对所有的int数据取绝对值。处理流过图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty12.png" alt=""></p>
<pre><code>public class AbsIntegerEncoder extends MessageToMessageEncoder&lt;ByteBuf&gt; {
    @Override
    protected void encode(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out) throws Exception {
        while(msg.readableBytes() &gt;= 4) {
            int value = Math.abs(msg.readInt());
            out.add(value);
        }
    }
}
</code></pre><p>针对这个Encoder编写单元测试。</p>
<p>由于是个Encoder，针对的是outbound中的数据，所以需要使用的方法是writeOutbound和readOutbound：</p>
<pre><code>ByteBuf buf = Unpooled.buffer(); // 构造heap buffer
for(int i = 1; i &lt; 10; i ++) { // 写入10个负数
    buf.writeInt(i * -1);
}
// 构造EmbeddedChannel，并在Pipeline中加入AbsIntegerEncoder
EmbeddedChannel channel = new EmbeddedChannel(new AbsIntegerEncoder());
// 使用writeOutbound方法写入数据
Assert.assertTrue(channel.writeOutbound(buf));
// 标记EmbeddedChannel状态已经complete
Assert.assertTrue(channel.finish());

// 测试是否所有的int数据都取了绝对值
for(int i = 1; i &lt; 10; i ++) {
    Assert.assertEquals(i, (int)channel.readOutbound());
}
Assert.assertNull(channel.readOutbound());
</code></pre><p>同理我们可以使用EmbeddedChannel进行CustomProtocol的Encoder的unit test：</p>
<pre><code>EmbeddedChannel channel = new EmbeddedChannel(new CustomProtocolEncoder());
String uuid = UUID.randomUUID().toString();

channel.writeOutbound(new CustomProtocol(1024l, uuid, &quot;content content&quot;));
Assert.assertTrue(channel.finish());

ByteBuf buf = (ByteBuf) channel.readOutbound();
Assert.assertEquals(1024l, buf.readLong());
byte[] headerBytes = new byte[36];
buf.readBytes(headerBytes);
Assert.assertEquals(uuid, new String(headerBytes));
byte[] contentBytes = new byte[buf.readableBytes()];
buf.readBytes(contentBytes);
Assert.assertEquals(&quot;content content&quot;, new String(contentBytes));
Assert.assertNull(channel.readOutbound());
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在编写完Netty程序之后，会需要进行ChannelHandler的一些测试。&lt;/p&gt;
&lt;p&gt;在初学Netty的时候，我们都是直接起一个Server，然后再写一个Client去连接Server，看传输的数据和接收到的数据是否正确。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://book.douban.com/subject/24700704/&quot;&gt;Netty in Action&lt;/a&gt;书中的Transport和Unit-test your code这两章就提出了可以使用EmbeddedChannel进行ChanndlHandler的单元测试。&lt;/p&gt;
    
    </summary>
    
      <category term="netty" scheme="http://fangjian0423.github.io/categories/netty/"/>
    
    
      <category term="nio" scheme="http://fangjian0423.github.io/tags/nio/"/>
    
      <category term="netty" scheme="http://fangjian0423.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>使用Netty编写自定义的协议</title>
    <link href="http://fangjian0423.github.io/2016/08/30/netty-custom-protocol/"/>
    <id>http://fangjian0423.github.io/2016/08/30/netty-custom-protocol/</id>
    <published>2016-08-30T14:04:52.000Z</published>
    <updated>2016-08-30T13:28:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Netty内部提供的Codec用于处理消息的编解码问题，比如Http，Ftp，SMTP这些协议，都需要进行编解码。</p>
<p>Netty内部直接提供了Http协议的Codec组件用于编解码Http协议。</p>
<p>在开发过程中，有时候我们需要构建一些适应自己业务的应用层协议，Netty可以很方便地实现自定义协议。</p>
<p>比如我们的自定义协议CucstomProtocol结构如下：</p>
<pre><code>| version | header | content |
</code></pre><p>其中version表示版本号，long类型；header是一个uuid，string类型，content则是具体的内容，string类型。</p>
<a id="more"></a>
<p>对应的POJO如下：</p>
<pre><code>public class CustomProtocol {
    private long version; // 版本
    private String header; // 头信息(UUID)
    private String content; // 具体内容
    // GET SET ...
    @Override
    public String toString() {
        return &quot;CustomProtocol{&quot; +
                &quot;version=&quot; + version +
                &quot;, header=&apos;&quot; + header + &apos;\&apos;&apos; +
                &quot;, content=&apos;&quot; + content + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}
</code></pre><p>解码器把byte转换成CustomProtocol，在server中使用：</p>
<pre><code>public class CustomProtocolDecoder extends ByteToMessageDecoder {
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {
        long version = in.readLong(); // 读取version

        byte[] headerBytes = new byte[36];
        in.readBytes(headerBytes); // 读取header

        String header = new String(headerBytes);

        byte[] contentBytes = new byte[in.readableBytes()]; // 读取content
        in.readBytes(contentBytes);

        out.add(new CustomProtocol(version, header, new String(contentBytes)));
    }
}
</code></pre><p>编码器把CustomProtocol转换成byte，在client中使用：</p>
<pre><code>public class CustomProtocolEncoder extends MessageToByteEncoder&lt;CustomProtocol&gt; {
    @Override
    protected void encode(ChannelHandlerContext ctx, CustomProtocol msg, ByteBuf out) throws Exception {
        out.writeLong(msg.getVersion());
        out.writeBytes(msg.getHeader().getBytes());
        out.writeBytes(msg.getContent().getBytes());
    }
}
</code></pre><p>server代码：</p>
<pre><code>ServerBootstrap serverBootstrap = new ServerBootstrap();
EventLoopGroup eventLoopGroup = new NioEventLoopGroup();
EventLoopGroup childEventLoopGroup = new NioEventLoopGroup();

try {
    serverBootstrap
            .group(eventLoopGroup, childEventLoopGroup)
            .channel(NioServerSocketChannel.class)
            .childHandler(new ChannelInitializer&lt;Channel&gt;() {
                @Override
                protected void initChannel(Channel ch) throws Exception {
                    ch.pipeline().addLast(new CustomProtocolDecoder()); // 解码器
                    ch.pipeline().addLast(new ServerHandler()); // 打印数据
                }
            });

    ChannelFuture future = serverBootstrap.bind(&quot;localhost&quot;, 9999).sync();

    future.channel().closeFuture().sync();
} catch (Exception e) {
    e.printStackTrace();
} finally {
    try {
        eventLoopGroup.shutdownGracefully().sync();
        childEventLoopGroup.shutdownGracefully().sync();
    } catch (Exception e1) {
        e1.printStackTrace();
    }
}
</code></pre><p>ServerHandler用于打印接收到的数据，并写数据回去给客户端表示接收到了数据：</p>
<pre><code>public class ServerHandler extends SimpleChannelInboundHandler&lt;CustomProtocol&gt; {
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, CustomProtocol msg) throws Exception {
        System.out.println(&quot;server receive: &quot; + msg);
        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;server get&quot;, CharsetUtil.UTF_8)).addListener(ChannelFutureListener.CLOSE);
    }
}
</code></pre><p>client代码：</p>
<pre><code>Bootstrap bootstrap = new Bootstrap();

EventLoopGroup eventLoopGroup = new NioEventLoopGroup();

try {
    bootstrap
            .group(eventLoopGroup)
            .channel(NioSocketChannel.class)
            .handler(new ChannelInitializer&lt;Channel&gt;() {
                @Override
                protected void initChannel(Channel ch) throws Exception {
                    ch.pipeline().addLast(new CustomProtocolEncoder()); // 编码器
                    ch.pipeline().addLast(new ClientHandler()); // 接收服务端数据
                }
            });
    ChannelFuture channelFuture = bootstrap.connect(&quot;localhost&quot;, 9999).sync();

    channelFuture.channel().writeAndFlush(new CustomProtocol(1024l, UUID.randomUUID().toString(), &quot;content detail&quot;));

    channelFuture.channel().closeFuture().sync();
} catch (Exception e) {
    e.printStackTrace();
} finally {
    try {
        eventLoopGroup.shutdownGracefully().sync();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre><p>ClientHandler用于接收服务端返回回来的数据：</p>
<pre><code>public class ClientHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; {
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
        System.out.println(&quot;send success, response is: &quot; + msg.toString(CharsetUtil.UTF_8));
    }
}
</code></pre><p>启动服务端和客户端之后，服务端收到客户端发来的CustomProtocol：</p>
<pre><code>server receive: CustomProtocol{version=1024, header=&apos;6ed7fa3d-7d54-4add-9081-d659d4b37d3f&apos;, content=&apos;content detail&apos;}
</code></pre><p>之后客户端也收到服务端成功接收数据的反馈：</p>
<pre><code>send success, response is: server get
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Netty内部提供的Codec用于处理消息的编解码问题，比如Http，Ftp，SMTP这些协议，都需要进行编解码。&lt;/p&gt;
&lt;p&gt;Netty内部直接提供了Http协议的Codec组件用于编解码Http协议。&lt;/p&gt;
&lt;p&gt;在开发过程中，有时候我们需要构建一些适应自己业务的应用层协议，Netty可以很方便地实现自定义协议。&lt;/p&gt;
&lt;p&gt;比如我们的自定义协议CucstomProtocol结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;| version | header | content |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中version表示版本号，long类型；header是一个uuid，string类型，content则是具体的内容，string类型。&lt;/p&gt;
    
    </summary>
    
      <category term="netty" scheme="http://fangjian0423.github.io/categories/netty/"/>
    
    
      <category term="nio" scheme="http://fangjian0423.github.io/tags/nio/"/>
    
      <category term="netty" scheme="http://fangjian0423.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty in Action笔记(二)</title>
    <link href="http://fangjian0423.github.io/2016/08/29/netty-in-action-note2/"/>
    <id>http://fangjian0423.github.io/2016/08/29/netty-in-action-note2/</id>
    <published>2016-08-29T12:36:52.000Z</published>
    <updated>2016-08-29T12:07:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录ChannelHandler、Codec以及Bootstrap的作用，还有Netty内置的一些ChannelHandler、Codec，以及Bootstrap的分类。</p>
<a id="more"></a>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>介绍Netty中的Channel、ChannelHandler、ChannelHandlerContext以及ChannelPipeline。</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>定义：一个Channel表示一个通道，跟io中的stream的角色一样，但是有几点不同。 1. stream是单向的，只支持读或者写，channel是双向的，既支持读也支持写。2. stream是阻塞的，channel是并行的。</p>
<p>其中Channel的生命周期状态如下：</p>
<table>
<thead>
<tr>
<th>状态说明</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>channelUnregistered</td>
<td>channel创建之后，还未注册到EventLoop</td>
</tr>
<tr>
<td>channelRegistered</td>
<td>channel注册到了对应的EventLoop</td>
</tr>
<tr>
<td>channelActive</td>
<td>channel处于活跃状态，活跃状态表示已经连接到了远程服务器，现在可以接收和发送数据</td>
</tr>
<tr>
<td>channelInactive</td>
<td>channel未连接到远程服务器</td>
</tr>
</tbody>
</table>
<p>一个Channel正常的生命周期如下：</p>
<p>channelRegistered -&gt; channelActice -&gt; channelInactive -&gt; channelUnregistered</p>
<p>在另外一种特殊情况下，会发生多次channelRegistered和channelUnregistered，这是因为用户可以从EventLoop上取消注册Channel来阻止事件的执行并在之后重新注册。状态变化如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty03.png" alt=""></p>
<h3 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h3><p>ChannelHandler有2种类型：</p>
<ol>
<li>Inbound Handler: 处理inbound数据(接收到的数据)以及所有类型的channel状态修改事件</li>
<li>Outbound Handler: 处理outbound数据(发送出去的数据)并且可以拦截各种操作，比如bind、connect、disconnect、close、write等操作</li>
</ol>
<p>Inbound和Outbound Handler都属于ChannelHandler，它们都可以被添加到ChannelPipeline中，它们内部也提供了handlerAdded、handlerRemoved这两种方法分别在ChannelHandler添加到ChannelPipeline和ChannelHandler从ChannelPipeline中被删除的时候触发。</p>
<h4 id="ChannelInboundHandler"><a href="#ChannelInboundHandler" class="headerlink" title="ChannelInboundHandler"></a>ChannelInboundHandler</h4><p>ChannelInboundHandler方法在两种情况下触发：channel状态的改变和channel接收到数据。</p>
<p>一些方法说明：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>channelRegistered(..)</td>
<td>Channel注册到EventLoop，并且可以处理IO请求</td>
</tr>
<tr>
<td>channelUnregistered(…)</td>
<td>Channel从EventLoop中被取消注册，并且不能处理任何IO请求</td>
</tr>
<tr>
<td>channelActive(…)</td>
<td>Channel已经连接到远程服务器，并准备好了接收数据</td>
</tr>
<tr>
<td>channelInactive(…)</td>
<td>Channel还没有连接到远程服务器</td>
</tr>
<tr>
<td>channelReadComplete(…)</td>
<td>Channel的读取操作已经完成</td>
</tr>
<tr>
<td>channelRead(…)</td>
<td>有数据可以读取的时候触发</td>
</tr>
<tr>
<td>userEventTriggered(…)</td>
<td>当用户调用Channel.fireUserEventTriggered方法的时候触发，用户可以传递一个自定义的对象当这个方法里</td>
</tr>
</tbody>
</table>
<p>ChannelInboundHandler有一个实现ChannelInboundHandlerAdapter，它实现了所有的方法，我们只需要继承这个类然后复写需要的方法即可。</p>
<p>ChannelInboundHandler中的channelRead方法中有读取的ByteBuf。由于Netty在ByteBuf的使用上使用了池的概念，当不需要这个ByteBuf的时候需要进行资源的释放以减少内存的消耗。</p>
<pre><code>@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
      // do something
      ReferenceCountUtil.release(msg);
}
</code></pre><p>Netty内部提供了一个SimpleChannelInboundHandler类，这个类读取数据会自动释放资源。它继承ChannelInboundHandlerAdapter并复写了channelRead方法，在channelRead方法里面finally代码里会自动release资源，并提供了channelRead0方法：</p>
<pre><code>@Override
public void channelRead0(ChannelHandlerContext ctx, Object msg) {
      // do something, do not need release
}
</code></pre><p>所以一般使用ChannelInboundHandler的话，有3种方法。 </p>
<ol>
<li>直接实现ChannelInBoundHandler接口 </li>
<li>继承ChannelInboundHandlerAdapter</li>
<li>继承SimpleChannelInboundHandler</li>
</ol>
<p>第1种基本不用，第3种用来处理接收消息，第2种用来处理事件状态的改变</p>
<h4 id="ChannelOutboundHandler"><a href="#ChannelOutboundHandler" class="headerlink" title="ChannelOutboundHandler"></a>ChannelOutboundHandler</h4><p>ChannelOutboundHandler方法在两种情况下触发：发送数据和拦截操作。</p>
<p>ChannelOutboundHandler有一个强大的功能，可以按需推迟一个操作，这使得处理请求可以用到更为复杂的策略。比如，如果写数据到远端被暂停，你可以推迟flush操作，稍后再试。</p>
<p>一些方法说明：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>bind(..)</td>
<td>请求绑定channel到本地地址</td>
</tr>
<tr>
<td>connect(…)</td>
<td>channel连接到远程地址</td>
</tr>
<tr>
<td>disconnect(…)</td>
<td>channel从远程服务器上断开</td>
</tr>
<tr>
<td>close(…)</td>
<td>关闭channel</td>
</tr>
<tr>
<td>deregister(…)</td>
<td>取消channel在eventloop上的注册</td>
</tr>
<tr>
<td>read(…)</td>
<td>在channel中读数据</td>
</tr>
<tr>
<td>flush(…)</td>
<td>flush数据到远程服务器</td>
</tr>
<tr>
<td>write(…)</td>
<td>写数据到远程服务器</td>
</tr>
</tbody>
</table>
<p>ChannelOutboundHandler有一个实现ChannelOutboundHandlerAdapter，它实现了所有的方法，我们只需要继承这个类然后复写需要的方法即可。</p>
<p>在outboundhandler中有时候也需要释放资源，当消息被消费并且不再需要传递给下一个outbound handler的时候，调用ReferenceCountUtil.release(message)释放消息。</p>
<p>当消息被写回去或者channel关闭的时候，这个消息的资源会被自动释放，所以没有一个类似SimpleChannelInboundHandler的概念。</p>
<h3 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h3><p>当ChannelHandler被添加到ChannelPipeline中的时候，ChannelHandlerContext会被创建。<br>所以说ChannelHandlerContext属于ChannelHandler。</p>
<p>可以通过ChannelHandlerContext的channel方法得到Channel和pipeline方法得到ChannelPipeline。</p>
<p>ChannelHandlerContext可以被保留下来并且在其他地方进行调用，比如在其他线程，或者在handler外部进行调用。</p>
<p>可以使用以下方法保留ChannelHandlerContext：</p>
<pre><code>class WriterHandler extends ChannelHandlerAdapter {
  private ChannelHandlerContext ctx;

  @Override
  public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
      this.ctx = ctx;
  }

  public void send(String msg) {
      ctx.write(msg);
  }
}
</code></pre><p>Netty中提供了一个@Sharable注解用来将一个实例的ChannelHandler添加到多个ChannelPipeline中，如果不加上这个注解，被多个ChannelPipeline使用的话会抛出异常。</p>
<h3 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h3><p>多个ChannelHandler可以组成一个ChannelPipeline，里面的每个ChannelHandler可以转发给下一个ChannelHandler。</p>
<p>ChannelPipeline内部的所有ChannelHandler的处理流程图：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty01.png" alt=""></p>
<p>ChannelPipeline提供了多种方法用于添加或删除或代替ChannelHandler，比如addLast, addFirst, remove, replace等方法。</p>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><p>介绍Netty中的编码器、解码器。我们知道网络中传输的是字节-ByteBuf。我们需要对ByteBuf进行一些解码用于解码成熟悉的POJO，对ByteBuf进行编码用于网络传输。</p>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>解码器，针对的是inbound的数据，也就是读取数据的解码。</p>
<p>2种类型：</p>
<ol>
<li>bytes到message的解码(ByteToMessageDecoder和ReplayingDecoder)</li>
<li>message到message的解码(MessageToMessageDecoder)</li>
</ol>
<p>decoders的作用是把inbound中读取的数据从一种格式转换成另一种格式，由于decoders处理的是inbound中的数据，所以它也是ChannelInboundHandler的一种实现类。</p>
<p>ByteToMessageDecoder和ReplayingDecoder属于bytes到message的解码。</p>
<p>一个ByteToMessageDecoder例子，将byte转换成integer：</p>
<pre><code>public class ToIntegerDecoder extends ByteToMessageDecoder {
    @Override  protected void decode(ChannelHandlerContext ctx, ByteBuf in,     List&lt;Object&gt; out) throws Exception {
        if(in.readableBytes() &gt;= 4) {
            out.add(in.readInt());
        }
    }    
}
</code></pre><p>处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty04.png" alt=""></p>
<p>如果使用ReplayingDecoder，不需要进行可读字节的判断，直接添加到List里即可。跟ToIntegerDecoder实现一样的功能，ReplayingDecoder只需要这样即可。(但是有一定的局限性：1.不是所有的操作都被ByteBuf支持 2.ByteBuf.readableBytes方法大部分时间不会返回期望的值)</p>
<pre><code>public class ToIntegerDecoder2 extends ReplayingDecoder&lt;Void&gt; {
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt;     out) throws Exception {
        out.add(in.readInt());
    }
}
</code></pre><p>一个MessageToMessageDecoder例子，将integer转换成string：</p>
<pre><code>public class IntegerToStringDecoder extends MessageToMessageDecoder&lt;Integer&gt; {
    @Override
    protected void decode(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out) throws Exception {
        out.add(String.valueOf(msg));
    }
}
</code></pre><p>处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty05.png" alt=""></p>
<h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><p>编码器，针对的是outbound的数据，也就是发送出去的数据的编码。</p>
<p>2种类型：</p>
<ol>
<li>message到message的编码(MessageToMessageEncoder)</li>
<li>message到byte的编码(MessageToByteEncoder)</li>
</ol>
<p>decoders的作用是把outbound中发送出去的数据从一种格式转换成另一种格式，由于eecoders处理的是outbound中的数据，所以它也是ChannelOutboundHandler的一种实现类。</p>
<p>一个MessageToByteEncoder例子，将integer转换成byte：</p>
<pre><code>public class IntegerToByteEncoder extends MessageToByteEncoder&lt;Integer&gt; {
    @Override
    protected void encode(ChannelHandlerContext ctx, Integer msg, ByteBuf out) throws Exception {
        out.writeInt(msg);
    }
}
</code></pre><p>处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty06.png" alt=""></p>
<p>一个MessageToMessageEncoder例子，将integer转换成string：</p>
<pre><code>public class IntegerToStringEncoder extends MessageToMessageEncoder&lt;Integer&gt; {
    @Override
    protected void encode(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out) throws Exception {
        out.add(String.valueOf(msg));
    }
}
</code></pre><p>处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty07.png" alt=""></p>
<h3 id="Codec"><a href="#Codec" class="headerlink" title="Codec"></a>Codec</h3><p>编解码器，既支持编码器的功能，也支持解码器的功能。</p>
<p>2种类型：</p>
<ol>
<li>ByteToMessageCodec：message到byte的编解码</li>
<li>MessageToMessageCodec：message到message的编解码</li>
</ol>
<h3 id="CombinedChannelDuplexHandler"><a href="#CombinedChannelDuplexHandler" class="headerlink" title="CombinedChannelDuplexHandler"></a>CombinedChannelDuplexHandler</h3><p>结合解码器和编码器在一起可能会牺牲可重用性。为了避免这种方式，可以使用CombinedChannelDuplexHandler。</p>
<p>CombinedChannelDuplexHandler也就是codec的另外一种方式，如果已经有个encoder和decoder，不需要重新写了codec，直接使用CombinedChannelDuplexHandler整合这个encoder和decoder即可。</p>
<p>上面的ToIntegerDecoder和IntegerToByteEncoder就可以构成一个编解码器，直接使用CombinedChannelDuplexHandler即可。</p>
<pre><code>public class CombinedByteIntegerCodec extends CombinedChannelDuplexHandler&lt;ToIntegerDecoder, IntegerToByteEncoder&gt; {
    public CombinedByteIntegerCodec() {
        super(new ToIntegerDecoder(), new IntegerToByteEncoder());
    }
}
</code></pre><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><p>主要说明jetty内置的一些ChannelHandler和Codec。</p>
<p>使用SSL/TLS加密Netty程序的话，可以使用内置的SslHandler。</p>
<p>要构建Http应用的话，可以使用HttpClientCodec/HttpServerCodec(http客户端和服务端的编解码)以及HttpObjectAggregator(Http的消息聚合)。</p>
<p>可以使用HttpContentDecompressor和HttpContentCompressor对http的内容进行解压和压缩。</p>
<p>还有一些WebSocket、SPDY，一些空置链接、超时链接等处理的内置解决方案。</p>
<h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><p>主要讲解Bootstrap中Netty中的作用。</p>
<p>之前分析过各种ChannelHandler，各种Codec，以及把这两个东西添加到Channel 的ChannelPipeline中。有了这些东西之后，该用什么把他们整合起来呢，那就是Bootstrap。</p>
<p>Bootstrap分别ServerBootstrap(服务端)和Bootstrap(客户端)，它们都继承AbstractBootstrap。</p>
<h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><p>客户端服务启动类，内部提供的一些方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>group(..)</td>
<td>设置Bootstrap使用的EventLoopGroup，用来处理Channel的IO操作</td>
</tr>
<tr>
<td>channel(..)</td>
<td>Channel的类型，比如有NioSocketChannel, OioSocketChannel等</td>
</tr>
<tr>
<td>channelFactory(..)</td>
<td>如果Channel没有没有参数的构造函数，需要使用ChannelFactory构造Channel</td>
</tr>
<tr>
<td>localAddress(..)</td>
<td>Channel需要绑定的地址和端口，可以不调用，使用connect或者bind再进行设置</td>
</tr>
<tr>
<td>option(..)</td>
<td>一些可选的设置，使用ChannelOptions完成。比如keep-alive时间，超时时间</td>
</tr>
<tr>
<td>handler(..)</td>
<td>设置ChannelHandler处理事件</td>
</tr>
<tr>
<td>clone(..)</td>
<td>复制一个新的Bootstrap，AbstractBootstrap实现了Cloneable接口</td>
</tr>
<tr>
<td>remoteAddress()..)</td>
<td>设置远程地址，也可以在调用connect方法的时候设置</td>
</tr>
<tr>
<td>connect()..)</td>
<td>链接到远程地址</td>
</tr>
<tr>
<td>bind()..)</td>
<td>绑定本地端口</td>
</tr>
</tbody>
</table>
<p>需要注意的是如果EventLoopGroup选择的是NioEventLoopGroup，那么对应的channel需要选择NioSocketChannel，否则会抛出兼容性的错误异常。</p>
<h3 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h3><p>服务端服务启动类，内部提供的一些方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>group(..)</td>
<td>设置ServerBootstrap使用的EventLoopGroup，用来处理ServerChannel的IO操作并接收Channel</td>
</tr>
<tr>
<td>channel(..)</td>
<td>ServerChannel的类型，比如有NioServerSocketChannel, OioServerSocketChannel等</td>
</tr>
<tr>
<td>channelFactory(..)</td>
<td>如果ServerChannel没有没有参数的构造函数，需要使用ChannelFactory构造ServerChannel</td>
</tr>
<tr>
<td>localAddress(..)</td>
<td>ServerChannel需要绑定的地址和端口，可以不调用，使用connect或者bind再进行设置</td>
</tr>
<tr>
<td>option(..)</td>
<td>一些ServerChannel可选的设置，使用ChannelOptions完成。比如keep-alive时间，超时时间</td>
</tr>
<tr>
<td>childOption(..)</td>
<td>被ServerChannel接收的Channel的可选的设置，使用ChannelOptions完成</td>
</tr>
<tr>
<td>handler(..)</td>
<td>设置ServerChannel的ChannelHandler处理事件</td>
</tr>
<tr>
<td>childHandler(..)</td>
<td>设置被ServerChannel接收的Channel的ChannelHandler处理事件</td>
</tr>
<tr>
<td>clone(..)</td>
<td>复制一个新的ServerBootstrap，AbstractBootstrap实现了Cloneable接口</td>
</tr>
<tr>
<td>bind()..)</td>
<td>绑定本地端口</td>
</tr>
</tbody>
</table>
<p>ServerBootstrap的处理过程：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty08.png" alt=""></p>
<p>ServerBootstrap调用bind绑定地址和端口的时候，会创建ServerChannel。这个ServerChannel会接收客户的各个链接，针对各个链接创建Channel。</p>
<p>handler方法就是为ServerChannel服务的，而childHandler是给被ServerChannel接收的Channel服务器的。所以说只要服务器已起来，handler中的ChannelHandler就会触发，而有链接被ServerChannel接收之后childHandler中的ChannelHandler才会触发。</p>
<h3 id="从一个已经存在的Channel中使用Bootstrap启动客户端"><a href="#从一个已经存在的Channel中使用Bootstrap启动客户端" class="headerlink" title="从一个已经存在的Channel中使用Bootstrap启动客户端"></a>从一个已经存在的Channel中使用Bootstrap启动客户端</h3><p>在ServerBootstrap接收到新的Channel的时候准备启动Bootstrap客户端的时候，可以使用一个全新的EventLoop用于处理Channel的IO模型。</p>
<p>但是没有必要，可以跟ServerBootstrap共享同一个EventLoop，因为一个EventLoop是跟一个线程绑定的，如果使用了多个EventLoop的话，那就相当于需要进行线程的上下文切换，需要消耗一定的资源。</p>
<p>1个在ServerBootstrap接收到链接之后，使用Bootstrap链接另外一个地址的处理过程：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty09.png" alt=""></p>
<p>其中第3点就是ServerChannel接收到的新的Channel，第5点是Bootstrap创建的连接到远程服务器的Channel，它们使用同一个EventLoop。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要记录ChannelHandler、Codec以及Bootstrap的作用，还有Netty内置的一些ChannelHandler、Codec，以及Bootstrap的分类。&lt;/p&gt;
    
    </summary>
    
      <category term="netty" scheme="http://fangjian0423.github.io/categories/netty/"/>
    
    
      <category term="nio" scheme="http://fangjian0423.github.io/tags/nio/"/>
    
      <category term="netty" scheme="http://fangjian0423.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty in Action笔记(一)</title>
    <link href="http://fangjian0423.github.io/2016/08/19/netty-in-action-note1/"/>
    <id>http://fangjian0423.github.io/2016/08/19/netty-in-action-note1/</id>
    <published>2016-08-18T17:36:52.000Z</published>
    <updated>2016-08-18T17:41:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>一篇读书笔记，根据章节进行下总结。已经看了5章，先对这5个章节做个小总结。</p>
<a id="more"></a>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>然后介绍了一下Netty出来的背景以及Netty所拥有的一些强大的特性，比如Netty的设计高可用，可扩展，性能高，使用NIO这种非阻塞式的IO模型等特点。</p>
<p>然后介绍了一下异步编程的设计，有两种方式：</p>
<ol>
<li>基于Callback</li>
<li>基于Future</li>
</ol>
<p>基于Callback的跟javascript相似，这种方式比较大的问题就是当callback多的时候，代码就变得难以阅读。</p>
<p>基于Future的方式就是jdk里的concurrent包里的Future接口一样，代表着未来的一个值。</p>
<p>Netty内部这2种异步编程方式都有使用。</p>
<p>之后对IO阻塞模型和NIO非阻塞模型进行了一番比较。</p>
<p>其中IO阻塞模型对于每一个Socket都会创建一个线程进行处理，虽然可以使用线程池解决线程过多的问题，但是底层还是使用线程处理每一个请求，系统的瓶颈在于线程的个数，并且线程多了会导致频繁的线程切换，导致CPU利用效率不高。</p>
<p>NIO非阻塞模型采用Reactor模式，一个Reactor线程内部使用一个多路复用器selector，这个selector可以同时注册、监听和轮询成百上千个Channel，一个IO线程可以同时并发处理多个客户端连接，就不会存在频繁的IO线程之间的切换，CPU利用率高。</p>
<p>之后使用JDK的NIO Api编写了一个demo，发现JDK的NIO Api比较难用，比如在ByteBuffer中进行读操作后又要进行写操作，需要调用flip进行切换，api很难用，而netty很好地解决了这个问题，这也是netty的一个优点。</p>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>第二章主要就是使用netty的api编写了一个server端和client端，让读者先简单熟悉一下netty中的一些api的使用。</p>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p>第三章主要对netty中的一些主要的组件做一个简单的介绍。</p>
<p>Channel: 一个Channel表示一个通道，跟io中的stream的角色一样，但是有几点不同。 1. stream是单向的，只支持读或者写，channel是双向的，既支持读也支持写。2. stream是阻塞的，channel是并行的。</p>
<p>EventLoop: 当一个channel注册之后，会将这个channel绑定到EventLoop里来处理channel的IO操作，一个EventLoop对应一个线程。</p>
<p>EventLoopGroup: 多个EventLoop的集合</p>
<p>Bootstrap: 用于配置客户端netty程序，比如连接的host和port，EventLoop等</p>
<p>ServerBootstrap: 用于配置服务端netty程序，比如绑定的port，EventLoop等</p>
<p>ChannelHandler: 主要用于处理关于Channel的业务逻辑。比如转换数据格式、当channel状态改变的时候被通知到，当channel注册到EventLoop的时候被通知到以及通知一些用户执行的特殊事件等。ChannelHandler有很多很多的实现类</p>
<p>ChannelPipeline: 把很多ChannelHandler整合在一起并进行处理</p>
<p>Future or ChannelFuture: 由于所有的netty都是异步操作。异步操作的结果就是ChannelFuture</p>
<p>ChannelInBoundHandler和ChannelOutBoundHandler是ChannelHandler的两种很常见的实现类，他们分别用于读取socket中的数据和写数据到socket中，他们存储在ChannelPipeline中用于处理socket，有一张很经典关于ChannelInboundHandler和ChannelOutboundHandler的图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty01.png" alt="image"></p>
<p>最后讲解了关于java对象的编码和解码，因为使用netty开发的时候需要传输字节数据，而这些字节数据可以跟java对象之间进行互相转换使编程更加方便。</p>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>第四章主要讲解了netty中的4种transport，分别是OIO、NIO、Local和Embedded。</p>
<p>其中OIO这种transport在netty中的io.netty.channel.socket.oio包里，底层使用jdk的java.net包里的类，io模型为阻塞io模型</p>
<p>NIO在netty中的io.netty.channel.socket.nio包里，底层使用jdk的java.nio.channels包里的类，netty提供了2种nio的实现，分别是基于selector和基于epoll的实现。</p>
<p>Local在io.netty.channel.local包里，这是一种在同一个JVM中客户端与服务器进行通信的一种transport。</p>
<p>Embedded在io.netty.channel.embedded包里，主要用于测试，可以在不需要网络的情况下进行ChannelHandler的单元测试。</p>
<p>这4种transport的使用场景如下：</p>
<p>OIO: 低连接数，低延迟，需要阻塞时使用<br>NIO: 搞链接数<br>Local: 同一个JVM中进行通信时使用<br>Embedded: ChannelHandler单元测试时使用</p>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p>第五章主要讲解netty中的ByteBuf的使用。</p>
<p>Jdk的NIO中的ByteBuffer使用成本过多，netty发现了这一缺点并进行了改造，设计出了ByteBuf这个类来代替ByteBuffer，相比ByteBuffer，ByteBuf有如下几个特点：</p>
<ol>
<li>可以定义自己的buffer类型，比如heap buffer, direct buffer等</li>
<li>可以使用内置的composite buffer类型完成零拷贝</li>
<li>buffer容量可以扩展</li>
<li>不需要调用flip来切换读写模式</li>
<li>区分readerIndex和writerIndex</li>
<li>方法链式调用</li>
<li>使用引用计数</li>
<li>可以使用pool来创建buffer</li>
</ol>
<p>ByteBuf工作原理：内部有2个索引，分别是readerIndex和writerIndex，初始化时，这2个值都是0，当写入数据到buffer中，writerIndex会增加；当读取数据时，readerIndex会增加。当readerIndex = writerIndex的时候，再进行读取将会抛出IndexOutOfBoundsException异常。</p>
<p>ByteBuf是有容量概念的，默认情况下的最大的容量是Integer.MAX_VALUE。当writerIndex超过这个容量大小时，将会抛出异常。</p>
<p>下图就是一个ByteBuf的结构：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty02.png" alt="image"></p>
<p>ByteBuf共有3种类型：</p>
<ol>
<li>heap buffer: 存储在JVM的堆中，内部使用一个字节数组存储字节。可以使用ByteBuf的hasArray方法判断是否是heap buffer</li>
<li>direct buffer：在堆外直接内存中分配，效率高，相比于堆内分配的buffer，在堆外直接内存中分配的buffer少了一次缓冲区的内存拷贝(实际上，当使用一个非直接内存buffer的时候，在发送buffer数据出去之前jvm内部会拷贝这个buffer到堆外直接内存中)</li>
<li>composite buffer：组合型的buffer，比如一个ByteBuf由2个ByteBuf构成，可以使用Composite Buffer完成，可以避免创建一个新的ByteBuf来整合这2个ByteBuf导致的内存拷贝</li>
</ol>
<p>以上2、3点再加上netty文件传输采用的transferTo方法(可以直接将文件缓存区的数据发送到目标Channel，不需要通过循环write方式导致的内存拷贝问题)构成了Netty的零拷贝。</p>
<p>接下来就是ByteBuf的一些常用方法介绍，比如copy, slice, duplicate, readInt, writeInt, indexOf, clear, discardReadBytes方法等等。</p>
<p>一些参考资料：</p>
<p><a href="http://www.open-open.com/news/view/1d31d83" target="_blank" rel="external">http://www.open-open.com/news/view/1d31d83</a></p>
<p><a href="http://www.infoq.com/cn/articles/netty-high-performance" target="_blank" rel="external">http://www.infoq.com/cn/articles/netty-high-performance</a></p>
<p><a href="http://www.infoq.com/cn/author/%E6%9D%8E%E6%9E%97%E9%94%8B#%E6%96%87%E7%AB%A0" target="_blank" rel="external">http://www.infoq.com/cn/author/%E6%9D%8E%E6%9E%97%E9%94%8B#%E6%96%87%E7%AB%A0</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇读书笔记，根据章节进行下总结。已经看了5章，先对这5个章节做个小总结。&lt;/p&gt;
    
    </summary>
    
      <category term="netty" scheme="http://fangjian0423.github.io/categories/netty/"/>
    
    
      <category term="nio" scheme="http://fangjian0423.github.io/tags/nio/"/>
    
      <category term="netty" scheme="http://fangjian0423.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot的actuator模块</title>
    <link href="http://fangjian0423.github.io/2016/06/25/springboot-actuator/"/>
    <id>http://fangjian0423.github.io/2016/06/25/springboot-actuator/</id>
    <published>2016-06-25T06:52:52.000Z</published>
    <updated>2016-06-25T07:38:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>springboot内部提供了一个模块spring-boot-actuator用于监控和管理springboot应用。</p>
<p>这个模块内部提供了很多功能，endpoint就是其中一块功能。</p>
<p>我们在sbt中加入这个模块的依赖：</p>
<pre><code>libraryDependencies += &quot;org.springframework.boot&quot; % &quot;spring-boot-starter-actuator&quot; % &quot;1.3.5.RELEASE&quot;
</code></pre><p>然后启动项目，访问地址 <a href="http://localhost:8080/health，看到以下页面：" target="_blank" rel="external">http://localhost:8080/health，看到以下页面：</a></p>
<pre><code>{
    status: &quot;UP&quot;,
    diskSpace: {
        status: &quot;UP&quot;,
        total: 249779191808,
        free: 22231089152,
        threshold: 10485760
    },
    db: {
        status: &quot;UP&quot;,
        database: &quot;H2&quot;,
        hello: 1
    }
}
</code></pre><a id="more"></a>
<p>这个/health endpoint显示了目前应用的一些健康情况。</p>
<h2 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h2><p>spring-boot-autoconfigure模块中还提供了其他很多endpoint，比如 /beans(查看spring工厂信息，里面存在哪些bean)、/dump(应用中的所有线程状态)、/env(应用环境信息，比如jvm环境信息、配置文件内容、应用端口等信息)、/mappings(SpringMVC的RequestMapping映射信息)、/configprops(框架配置信息，比如数据源、freemarker、spring的配置信息)、/metrics(度量信息)等等。</p>
<p>具体其他的endpoint可以查看springboot官方文档上的信息： <a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready-endpoints" target="_blank" rel="external">http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready-endpoints</a></p>
<p>这些endpoint是如何暴露出来的呢，是通过SpringBoot内部的一个Endpoint接口完成的。</p>
<pre><code>public interface Endpoint&lt;T&gt; {
    String getId(); // endpoint的唯一标识
    boolean isEnabled(); // 是否可用
    boolean isSensitive(); // 是否对一般用户可见
    T invoke(); // 具体的执行过程，返回值会被解析成json暴露出口
}
</code></pre><p>这个接口的实现类有DumpEndpoint、BeansEndpoint、InfoEndpoint、HealthEndpoint、RequestMappingEndpoint等等。这些EndPoint实现类就是对应对外暴露的endpoint。BeansEndpoint的代码如下：</p>
<pre><code>@ConfigurationProperties(prefix = &quot;endpoints.beans&quot;) // 配置以endpoints.beans开头，可以覆盖
public class BeansEndpoint extends AbstractEndpoint&lt;List&lt;Object&gt;&gt;
        implements ApplicationContextAware {

    private final LiveBeansView liveBeansView = new LiveBeansView();

    private final JsonParser parser = JsonParserFactory.getJsonParser();

    public BeansEndpoint() {
        super(&quot;beans&quot;); // id为beans
    }

    @Override
    public void setApplicationContext(ApplicationContext context) throws BeansException {
        if (context.getEnvironment()
                .getProperty(LiveBeansView.MBEAN_DOMAIN_PROPERTY_NAME) == null) {
            this.liveBeansView.setApplicationContext(context);
        }
    }

    @Override
    public List&lt;Object&gt; invoke() {
        return this.parser.parseList(this.liveBeansView.getSnapshotAsJson()); // 返回值就是最后展示的json数组
    }
}
</code></pre><p>可以使用配置覆盖默认的beans endpoint中的信息：</p>
<pre><code>endpoints.beans.enabled= # Enable the endpoint.
endpoints.beans.id= # Endpoint identifier.
endpoints.beans.path= # Endpoint path.
endpoints.beans.sensitive= # Mark if the endpoint exposes sensitive information.
</code></pre><h2 id="Health-Indicator"><a href="#Health-Indicator" class="headerlink" title="Health Indicator"></a>Health Indicator</h2><p>HealthEndpoint这个endpoint是暴露通过扫描出的HealthIndicator接口的实现类完成的。</p>
<p>用于查看应用的健康状况。</p>
<p>在我们的应用中只使用了h2数据库，最终/health显示出来的内容如下(只有硬盘容量和数据库健康状况)：</p>
<pre><code>{
    status: &quot;UP&quot;,
    diskSpace: {
        status: &quot;UP&quot;,
        total: 249779191808,
        free: 20595720192,
        threshold: 10485760
    },
    db: {
        status: &quot;UP&quot;,
        database: &quot;H2&quot;,
        hello: 1
    }
}
</code></pre><p>springboot内置的HealthIndicator有这些：SolrHealthIndicator、RedisHealthIndicator、RabbitHealthIndicator、MongoHealthIndicator、ElasticsearchHealthIndicator、CassandraHealthIndicator、DiskSpaceHealthIndicator、DataSourceHealthIndicator等。</p>
<p>这些都是springboot内置的，我们也可以编写自定义的health indicator。</p>
<p>以服务器中某个目录中的文件个数不能超过某个值为健康指标作为需求进行编写health indicator。</p>
<p>编写HealthIndicator：</p>
<pre><code>@Component
public class TempDirHealthIndicator implements HealthIndicator {

    @Override
    public Health health() {
        Health.Builder builder = new Health.Builder();
        File file = new File(&quot;youdirpath&quot;);
        File[] fileList = file.listFiles();
        if(fileList.length &gt; 10) {
            builder.down().withDetail(&quot;file num&quot;,fileList.length);
        } else {
            builder.up();
        }
        return builder.build();
    }

}
</code></pre><p>访问 <a href="http://localhost:8080/health" target="_blank" rel="external">http://localhost:8080/health</a></p>
<pre><code>{
    status: &quot;DOWN&quot;,
    tempDir: {
        status: &quot;DOWN&quot;,
        file num: 34
    },
    diskSpace: {
        status: &quot;UP&quot;,
        total: 249779191808,
        free: 20690649088,
        threshold: 10485760
    },
    db: {
        status: &quot;UP&quot;,
        database: &quot;H2&quot;,
        hello: 1
    }
}
</code></pre><h2 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h2><p>Metrics服务用来做一些度量支持，springboot提供了两种Metrics，分别是gauge(单一的值)和counter(计数器，自增或自减)。springboot提供了PublicMetrics接口用来支持Metrics服务。</p>
<p>metrics这个endpoint中使用的metrics都是由SystemPublicMetrics完成的：</p>
<pre><code>{
    mem: 388503,
    mem.free: 199992,
    processors: 4,
    instance.uptime: 58260089,
    uptime: 21843805,
    systemload.average: 3.28369140625,
    heap.committed: 320000,
    heap.init: 131072,
    heap.used: 120007,
    heap: 1864192,
    nonheap.committed: 69528,
    nonheap.init: 2496,
    nonheap.used: 68501,
    nonheap: 0,
    threads.peak: 15,
    threads.daemon: 13,
    threads.totalStarted: 20,
    threads: 15,
    classes: 9483,
    classes.loaded: 9484,
    classes.unloaded: 1,
    gc.ps_scavenge.count: 9,
    gc.ps_scavenge.time: 152,
    gc.ps_marksweep.count: 2,
    gc.ps_marksweep.time: 167,
    httpsessions.max: -1,
    httpsessions.active: 0,
    datasource.primary.active: 0,
    datasource.primary.usage: 0,
    gauge.response.health: 218,
    gauge.response.star-star.favicon.ico: 29,
    counter.status.200.star-star.favicon.ico: 1,
    counter.status.503.health: 1
}
</code></pre><p>gauge和counter度量通过GaugeService和CounterService完成。</p>
<p>比如我们要查看各个Controller中的接口被调用的次数话，可以使用CounterService和aop完成：</p>
<pre><code>@Aspect
@Component
class ControllerAspect @Autowired() (
  counterService: CounterService
) {

  @Before(&quot;execution(* me.format.controller.*.*(..))&quot;)
  def controllerCounter(joinPoint: JoinPoint): Unit = {
    counterService.increment(joinPoint.getSignature.toString + &quot;-invokeNum&quot;)
  }

}
</code></pre><p>启动应用，调用getPersons接口4次，调用get/{long} 2次，查看metrics endpoint，得到以下信息：</p>
<pre><code>counter.List me.format.controller.PersonController.get(HttpServletRequest)-invokeNum: 4,
counter.Person me.format.controller.PersonController.get(long)-invokeNum: 2,
</code></pre><p>比如我们要查看各个Controller中的接口的延迟情况，可以使用GaugeService和aop完成：</p>
<pre><code>@Aspect
@Component
class ControllerAspect @Autowired() (
  counterService: CounterService,
  gaugeService: GaugeService
) {

  @Before(&quot;execution(* me.format.controller.*.*(..))&quot;)
  def controllerCounter(joinPoint: JoinPoint): Unit = {
    counterService.increment(joinPoint.getSignature.toString + &quot;-invokeNum&quot;)
  }

  @Around(&quot;execution(* me.format.controller.*.*(..))&quot;)
  def controllerGauge(proceedingJoinPoint: ProceedingJoinPoint): AnyRef = {
    val st = System.currentTimeMillis()
    val result = proceedingJoinPoint.proceed()
    val et = System.currentTimeMillis()
    gaugeService.submit(proceedingJoinPoint.getSignature.toString + &quot;-invokeTime&quot;, (et - st))
    result
  }

}
</code></pre><p>启动应用，调用getPersons接口4次，调用get/{long} 2次，查看metrics endpoint，得到以下信息：</p>
<pre><code>gauge.List me.format.controller.PersonController.get(HttpServletRequest)-invokeTime: 4,
gauge.Person me.format.controller.PersonController.get(long)-invokeTime: 11,
counter.List me.format.controller.PersonController.get(HttpServletRequest)-invokeNum: 4,
counter.Person me.format.controller.PersonController.get(long)-invokeNum: 2,
</code></pre><p>当然，actuator模块提供的功能远不止这些，更多的信息可以查看官方文档。</p>
<p><a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready" target="_blank" rel="external">http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;springboot内部提供了一个模块spring-boot-actuator用于监控和管理springboot应用。&lt;/p&gt;
&lt;p&gt;这个模块内部提供了很多功能，endpoint就是其中一块功能。&lt;/p&gt;
&lt;p&gt;我们在sbt中加入这个模块的依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;libraryDependencies += &amp;quot;org.springframework.boot&amp;quot; % &amp;quot;spring-boot-starter-actuator&amp;quot; % &amp;quot;1.3.5.RELEASE&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后启动项目，访问地址 &lt;a href=&quot;http://localhost:8080/health，看到以下页面：&quot;&gt;http://localhost:8080/health，看到以下页面：&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    status: &amp;quot;UP&amp;quot;,
    diskSpace: {
        status: &amp;quot;UP&amp;quot;,
        total: 249779191808,
        free: 22231089152,
        threshold: 10485760
    },
    db: {
        status: &amp;quot;UP&amp;quot;,
        database: &amp;quot;H2&amp;quot;,
        hello: 1
    }
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="scala" scheme="http://fangjian0423.github.io/tags/scala/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot with Scala</title>
    <link href="http://fangjian0423.github.io/2016/06/22/springboot-with-scala/"/>
    <id>http://fangjian0423.github.io/2016/06/22/springboot-with-scala/</id>
    <published>2016-06-22T15:22:39.000Z</published>
    <updated>2016-06-23T06:06:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下，我们使用java开发springboot应用，可以使用scala开发springboot应用吗？</p>
<p>答案当然是可以的。</p>
<p>今天参考了阿福老师的这篇<a href="http://afoo.me/posts/2015-07-21-scala-developers-springboot-guide.html" target="_blank" rel="external">Scala开发者的SpringBoot快速入门指南</a>以及一位国际友人的一个<a href="https://github.com/bijukunjummen/spring-boot-scala-web" target="_blank" rel="external">spring-boot-scala-web</a> demo。</p>
<p>自己尝试地搭建了一下环境，发现用scala编写springboot应用这种体验也是非常赞的。</p>
<p>下面是具体的环境搭建流程：</p>
<a id="more"></a>
<p>1.使用sbt作为构建工具，由于springboot官方只有基于maven或者gradle的构建方法，所以我们只能自己写了。</p>
<p>参考了springboot的maven配置，比如要开发web应用，需要1个spring-boot-starter-web模块，这个spring-boot-starter-web模块内地又引用了spring-boot-starter模块，spring-boot-starter模块是一个基础的starter模块，内部的依赖如下：</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;commons-logging&lt;/groupId&gt;
                &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.yaml&lt;/groupId&gt;
        &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>其中springb-boot模块内部使用了spring的依赖，spring-boot-autoconfigure模块内部有很多自动化配置的类，spring-boot-starter-web模块内部使用了spring的web模块，一些tomcat模块等。</p>
<p>我们将这3个模块加入到sbt中：</p>
<pre><code>libraryDependencies += &quot;org.springframework.boot&quot; % &quot;spring-boot&quot; % &quot;1.3.5.RELEASE&quot;
libraryDependencies += &quot;org.springframework.boot&quot; % &quot;spring-boot-autoconfigure&quot; % &quot;1.3.5.RELEASE&quot;
libraryDependencies += &quot;org.springframework.boot&quot; % &quot;spring-boot-starter-web&quot; % &quot;1.3.5.RELEASE&quot;
</code></pre><p>再加入jpa的依赖：</p>
<pre><code>libraryDependencies += &quot;org.springframework.boot&quot; % &quot;spring-boot-starter-data-jpa&quot; % &quot;1.3.5.RELEASE&quot;
libraryDependencies += &quot;com.h2database&quot; % &quot;h2&quot; % &quot;1.4.192&quot;
</code></pre><p>2.编写domain，使用BeanProperty可以自动给field加入get，set方法。</p>
<pre><code>@Entity
class Person(pName: String, pAge: Int) {

  @Id
  @GeneratedValue
  @BeanProperty
  var id: Long = _

  @BeanProperty
  var name: String = pName

  @BeanProperty
  var age: Int = pAge

  def this() = this(&quot;unknown&quot;, -1)

}

object Person {
  def apply(name: String, age: Int) = new Person(name, age)
}
</code></pre><p>3.编写Repository，由于scala中没有接口这个概念，我们使用trait代替。</p>
<pre><code>@Repository
trait PersonRepository extends CrudRepository[Person, Long]
</code></pre><p>4.编写Controller。利用构造器依赖注入将PersonRepository注入到属性里。</p>
<pre><code>@RestController
class PersonController @Autowired() (
  private val personRepository: PersonRepository
) {

  @RequestMapping(value = Array(&quot;/index&quot;))
  def index(): String = {
    &quot;hello springboot&quot;
  }

  @RequestMapping(value = Array(&quot;/add&quot;))
  def add(req: HttpServletRequest): String = {
    val p = Person(req.getParameter(&quot;name&quot;), Some(req.getParameter(&quot;age&quot;).toInt).getOrElse(-1))
    personRepository.save(p)
    &quot;ok&quot;
  }

  @RequestMapping(value = Array(&quot;/getAll&quot;))
  def get(req: HttpServletRequest): java.util.List[Person] = {
    personRepository.findAll().toList
  }

  @RequestMapping(value = Array(&quot;/get/{id}&quot;))
  def get(@PathVariable() id: Long): Person = {
    personRepository.findOne(id)
  }

}
</code></pre><p>5.使用CommandLineRunner做一些初始化工作。</p>
<pre><code>@SpringBootApplication
class MainClass {

  @Bean
  def init(personRepository: PersonRepository): CommandLineRunner = {
    return new CommandLineRunner {
      override def run(strings: String*): Unit = {
        personRepository.save(Person(&quot;jim&quot;, 1))
        personRepository.save(Person(&quot;tom&quot;, 2))
        personRepository.save(Person(&quot;jerry&quot;, 3))
      }
    }
  }

}
</code></pre><p>6.配置文件application.properties中加入以下配置。</p>
<pre><code>spring.datasource.url=jdbc:h2:mem:AZ;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
</code></pre><p>7.写一个入口对象启动应用。</p>
<pre><code>object Application extends App {
  SpringApplication.run(classOf[MainClass]);
}
</code></pre><p>测试：</p>
<pre><code>curl http://localhost:8080/index

hello springboot

curl http://localhost:8080/getPersons

[{&quot;id&quot;:1,&quot;name&quot;:&quot;jim&quot;,&quot;age&quot;:1},{&quot;id&quot;:2,&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:2},{&quot;id&quot;:3,&quot;name&quot;:&quot;jerry&quot;,&quot;age&quot;:3}]

curl http://localhost:8080/get/1

{&quot;id&quot;:1,&quot;name&quot;:&quot;jim&quot;,&quot;age&quot;:1}

curl http://localhost:8080/add\?name\=format\&amp;age\=4

ok

curl http://localhost:8080/getPersons

[{&quot;id&quot;:1,&quot;name&quot;:&quot;jim&quot;,&quot;age&quot;:1},{&quot;id&quot;:2,&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:2},{&quot;id&quot;:3,&quot;name&quot;:&quot;jerry&quot;,&quot;age&quot;:3},{&quot;id&quot;:4,&quot;name&quot;:&quot;format&quot;,&quot;age&quot;:4}]
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般情况下，我们使用java开发springboot应用，可以使用scala开发springboot应用吗？&lt;/p&gt;
&lt;p&gt;答案当然是可以的。&lt;/p&gt;
&lt;p&gt;今天参考了阿福老师的这篇&lt;a href=&quot;http://afoo.me/posts/2015-07-21-scala-developers-springboot-guide.html&quot;&gt;Scala开发者的SpringBoot快速入门指南&lt;/a&gt;以及一位国际友人的一个&lt;a href=&quot;https://github.com/bijukunjummen/spring-boot-scala-web&quot;&gt;spring-boot-scala-web&lt;/a&gt; demo。&lt;/p&gt;
&lt;p&gt;自己尝试地搭建了一下环境，发现用scala编写springboot应用这种体验也是非常赞的。&lt;/p&gt;
&lt;p&gt;下面是具体的环境搭建流程：&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="scala" scheme="http://fangjian0423.github.io/tags/scala/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot内部的一些自动化配置原理</title>
    <link href="http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/"/>
    <id>http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/</id>
    <published>2016-06-12T11:30:57.000Z</published>
    <updated>2016-09-23T17:07:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>springboot用来简化Spring框架带来的大量XML配置以及复杂的依赖管理，让开发人员可以更加关注业务逻辑的开发。</p>
<p>比如不使用springboot而使用SpringMVC作为web框架进行开发的时候，需要配置相关的SpringMVC配置以及对应的依赖，比较繁琐；而使用springboot的话只需要以下短短的几行代码就可以使用SpringMVC，可谓相当地方便：</p>
<pre><code>@RestController
class App {
  @RequestMapping(&quot;/&quot;)
  String home() {
    &quot;hello&quot;
  }
}
</code></pre><p>其中maven配置如下：</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
&lt;/parent&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><a id="more"></a>
<p>我们以使用SpringMVC并且视图使用freemarker为例，分析springboot内部是如何解析freemarker视图的。</p>
<p>如果要在springboot中使用freemarker视图框架，并且使用maven构建项目的时候，还需要加入以下依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;
    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>这个spring-boot-starter-freemarker依赖对应的jar包里的文件如下：</p>
<pre><code>META-INF
├── MANIFEST.MF
├── maven
│   └── org.springframework.boot
│       └── spring-boot-starter-freemarker
│           ├── pom.properties
│           └── pom.xml
└── spring.provides
</code></pre><p>内部的pom.xml里需要的依赖如下：</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
  &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>我们可以看到这个spring-boot-starter-freemarker依赖内部并没有freemarker的ViewResolver，而是仅仅加入了freemarker的依赖，还有3个依赖，分别是spring-boot-starter、spring-boot-starter-web和spring-context-support。</p>
<p>接下来我们来分析一下为什么在springboot中加入了freemarker的依赖spring-boot-starter-freemarker后，SpringMVC自动地构造了一个freemarker的ViewResolver？</p>
<p>在分析之前，首先我们先看下maven配置，看到了一个parent配置：</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
&lt;/parent&gt;
</code></pre><p>这个spring-boot-starter-parent的pom文件在 <a href="http://central.maven.org/maven2/org/springframework/boot/spring-boot-starter-parent/1.3.5.RELEASE/spring-boot-starter-parent-1.3.5.RELEASE.pom" target="_blank" rel="external">http://central.maven.org/maven2/org/springframework/boot/spring-boot-starter-parent/1.3.5.RELEASE/spring-boot-starter-parent-1.3.5.RELEASE.pom</a> 里。</p>
<p>它内部也有一个parent：</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
    &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;
&lt;/parent&gt;
</code></pre><p>这个spring-boot-dependencies的pom文件在<a href="http://central.maven.org/maven2/org/springframework/boot/spring-boot-dependencies/1.3.5.RELEASE/spring-boot-dependencies-1.3.5.RELEASE.pom，内部有很多依赖。" target="_blank" rel="external">http://central.maven.org/maven2/org/springframework/boot/spring-boot-dependencies/1.3.5.RELEASE/spring-boot-dependencies-1.3.5.RELEASE.pom，内部有很多依赖。</a></p>
<p>比如spring-boot-starter-web、spring-boot-starter-websocket、spring-boot-starter-data-solrspring-boot-starter-freemarker等等，基本上所有的依赖都在这个parent里。</p>
<p>我们的例子中使用了parent依赖里的两个依赖，分别是spring-boot-starter-web和spring-boot-starter-freemarker。</p>
<p>其中spring-boot-starter-web内部依赖了spring的两个spring web依赖：spring-web和spring-webmvc。</p>
<p>spring-boot-starter-web内部还依赖spring-boot-starter，这个spring-boot-starter依赖了spring核心依赖spring-core；还依赖了<strong>spring-boot</strong>和<strong>spring-boot-autoconfigure</strong>这两个。</p>
<p><strong>spring-boot</strong>定义了很多基础功能类，像运行程序的SpringApplication，Logging系统，一些tomcat或者jetty这些EmbeddedServlet容器，配置属性loader等等。</p>
<p>包括了这些包：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/springboot01.png" alt="image"></p>
<p><strong>spring-boot-autoconfigure</strong>定义了很多自动配置的类，比如jpa，solr，redis，elasticsearch、mongo、freemarker、velocity，thymeleaf等等自动配置的类。</p>
<p>以freemarker为例，看一下它的自动化配置类：</p>
<pre><code>@Configuration // 使用Configuration注解，自动构造一些内部定义的bean
@ConditionalOnClass({ freemarker.template.Configuration.class,
        FreeMarkerConfigurationFactory.class }) // 需要freemarker.template.Configuration和FreeMarkerConfigurationFactory这两个类存在在classpath中才会进行自动配置
@AutoConfigureAfter(WebMvcAutoConfiguration.class) // 本次自动配置需要依赖WebMvcAutoConfiguration这个配置类配置之后触发。这个WebMvcAutoConfiguration内部会配置很多Wen基础性的东西，比如RequestMappingHandlerMapping、RequestMappingHandlerAdapter等
@EnableConfigurationProperties(FreeMarkerProperties.class) // 使用FreeMarkerProperties类中的配置
public class FreeMarkerAutoConfiguration {

    private static final Log logger = LogFactory
            .getLog(FreeMarkerAutoConfiguration.class);

    @Autowired
    private ApplicationContext applicationContext;

    @Autowired
    private FreeMarkerProperties properties;

    @PostConstruct // 构造之后调用的方法，组要检查模板位置是否存在
    public void checkTemplateLocationExists() {
        if (this.properties.isCheckTemplateLocation()) {
            TemplateLocation templatePathLocation = null;
            List&lt;TemplateLocation&gt; locations = new ArrayList&lt;TemplateLocation&gt;();
            for (String templateLoaderPath : this.properties.getTemplateLoaderPath()) {
                TemplateLocation location = new TemplateLocation(templateLoaderPath);
                locations.add(location);
                if (location.exists(this.applicationContext)) {
                    templatePathLocation = location;
                    break;
                }
            }
            if (templatePathLocation == null) {
                logger.warn(&quot;Cannot find template location(s): &quot; + locations
                        + &quot; (please add some templates, &quot;
                        + &quot;check your FreeMarker configuration, or set &quot;
                        + &quot;spring.freemarker.checkTemplateLocation=false)&quot;);
            }
        }
    }

    protected static class FreeMarkerConfiguration {

        @Autowired
        protected FreeMarkerProperties properties;

        protected void applyProperties(FreeMarkerConfigurationFactory factory) {
            factory.setTemplateLoaderPaths(this.properties.getTemplateLoaderPath());
            factory.setPreferFileSystemAccess(this.properties.isPreferFileSystemAccess());
            factory.setDefaultEncoding(this.properties.getCharsetName());
            Properties settings = new Properties();
            settings.putAll(this.properties.getSettings());
            factory.setFreemarkerSettings(settings);
        }

    }

    @Configuration
    @ConditionalOnNotWebApplication // 非Web项目的自动配置
    public static class FreeMarkerNonWebConfiguration extends FreeMarkerConfiguration {

        @Bean
        @ConditionalOnMissingBean
        public FreeMarkerConfigurationFactoryBean freeMarkerConfiguration() {
            FreeMarkerConfigurationFactoryBean freeMarkerFactoryBean = new FreeMarkerConfigurationFactoryBean();
            applyProperties(freeMarkerFactoryBean);
            return freeMarkerFactoryBean;
        }

    }

    @Configuration // 自动配置的类
    @ConditionalOnClass(Servlet.class) // 需要运行在Servlet容器下
    @ConditionalOnWebApplication // 需要在Web项目下
    public static class FreeMarkerWebConfiguration extends FreeMarkerConfiguration {

        @Bean
        @ConditionalOnMissingBean(FreeMarkerConfig.class)
        public FreeMarkerConfigurer freeMarkerConfigurer() {
            FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
            applyProperties(configurer);
            return configurer;
        }

        @Bean
        public freemarker.template.Configuration freeMarkerConfiguration(
                FreeMarkerConfig configurer) {
            return configurer.getConfiguration();
        }

        @Bean
        @ConditionalOnMissingBean(name = &quot;freeMarkerViewResolver&quot;) // 没有配置freeMarkerViewResolver这个bean的话，会自动构造一个freeMarkerViewResolver
        @ConditionalOnProperty(name = &quot;spring.freemarker.enabled&quot;, matchIfMissing = true) // 配置文件中开关开启的话，才会构造
        public FreeMarkerViewResolver freeMarkerViewResolver() {
            // 构造了freemarker的ViewSolver，这就是一开始我们分析的为什么没有设置ViewResolver，但是最后却还是存在的原因
            FreeMarkerViewResolver resolver = new FreeMarkerViewResolver();
            this.properties.applyToViewResolver(resolver);
            return resolver;
        }

    }
}
</code></pre><p>freemarker对应的配置类：</p>
<pre><code>@ConfigurationProperties(prefix = &quot;spring.freemarker&quot;) // 使用配置文件中以spring.freemarker开头的配置
public class FreeMarkerProperties extends AbstractTemplateViewResolverProperties {
    public static final String DEFAULT_TEMPLATE_LOADER_PATH = &quot;classpath:/templates/&quot;; // 默认路径

    public static final String DEFAULT_PREFIX = &quot;&quot;; // 默认前缀

    public static final String DEFAULT_SUFFIX = &quot;.ftl&quot;; // 默认后缀

    ...

}
</code></pre><p>下面是官网上的freemarker配置：</p>
<pre><code># FREEMARKER (FreeMarkerAutoConfiguration)
spring.freemarker.allow-request-override=false # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.
spring.freemarker.allow-session-override=false # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.
spring.freemarker.cache=false # Enable template caching.
spring.freemarker.charset=UTF-8 # Template encoding.
spring.freemarker.check-template-location=true # Check that the templates location exists.
spring.freemarker.content-type=text/html # Content-Type value.
spring.freemarker.enabled=true # Enable MVC view resolution for this technology.
spring.freemarker.expose-request-attributes=false # Set whether all request attributes should be added to the model prior to merging with the template.
spring.freemarker.expose-session-attributes=false # Set whether all HttpSession attributes should be added to the model prior to merging with the template.
spring.freemarker.expose-spring-macro-helpers=true # Set whether to expose a RequestContext for use by Spring&apos;s macro library, under the name &quot;springMacroRequestContext&quot;.
spring.freemarker.prefer-file-system-access=true # Prefer file system access for template loading. File system access enables hot detection of template changes.
spring.freemarker.prefix= # Prefix that gets prepended to view names when building a URL.
spring.freemarker.request-context-attribute= # Name of the RequestContext attribute for all views.
spring.freemarker.settings.*= # Well-known FreeMarker keys which will be passed to FreeMarker&apos;s Configuration.
spring.freemarker.suffix= # Suffix that gets appended to view names when building a URL.
spring.freemarker.template-loader-path=classpath:/templates/ # Comma-separated list of template paths.
spring.freemarker.view-names= # White list of view names that can be resolved.
</code></pre><p>所以说一开始我们加入了一个spring-boot-starter-freemarker依赖，这个依赖中存在freemarker的lib，满足了FreeMarkerAutoConfiguration中的ConditionalOnClass里写的freemarker.template.Configuration.class这个类存在于classpath中。</p>
<p>所以就构造了FreeMarkerAutoConfiguration里的ViewResolver，这个ViewResolver被自动加入到SpringMVC中。</p>
<p>同样地，如果我们要使用velocity模板，springboot内部也有velocity的自动配置类VelocityAutoConfiguration，原理是跟freemarker一样的。</p>
<p>其他：</p>
<p><a href="https://github.com/mybatis/spring-boot-starter" target="_blank" rel="external">Mybatis的autoconfigure</a>是Mybatis提供的springboot的自动配置模块，由于springboot官方没有提供mybatis的自动化配置模块，所以mybatis自己写了这么一个模块，观察它的源码，发现基本上跟freemarker的autoconfigure模块一样，只需要构造对应的实例即可。</p>
<p>总结：</p>
<p>springboot内部提供了很多自动化配置的类，这些类会判断classpath中是否存在自己需要的那个类，如果存在则会自动配置相关的配置，否则就不会自动配置。</p>
<p>如果我们需要使用一些框架，只需要加入依赖即可，这些依赖内部是没有代码的，只是一些对应框架需要的lib，有了这些lib就会触发自动化配置，于是就能使用框架了。</p>
<p>这一点跟当时看springmvc的时候对response进行json或xml渲染的原理相同。springmvc中的requestmapping注解加上responsebody注解后会返回xml或者json，如果依赖中加入jackson依赖就会转换成json，如果依赖中加入xstream依赖就会转换成xml。当然，前提是springmvc中有了这两种依赖的HttpMessageConverter代码，这个HttpMessageConverter代码就相当于springboot中的各种AutoConfiguration。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;springboot用来简化Spring框架带来的大量XML配置以及复杂的依赖管理，让开发人员可以更加关注业务逻辑的开发。&lt;/p&gt;
&lt;p&gt;比如不使用springboot而使用SpringMVC作为web框架进行开发的时候，需要配置相关的SpringMVC配置以及对应的依赖，比较繁琐；而使用springboot的话只需要以下短短的几行代码就可以使用SpringMVC，可谓相当地方便：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RestController
class App {
  @RequestMapping(&amp;quot;/&amp;quot;)
  String home() {
    &amp;quot;hello&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中maven配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3.5.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/parent&amp;gt;
&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Java线程状态分析</title>
    <link href="http://fangjian0423.github.io/2016/06/04/java-thread-state/"/>
    <id>http://fangjian0423.github.io/2016/06/04/java-thread-state/</id>
    <published>2016-06-04T15:53:35.000Z</published>
    <updated>2016-06-04T15:53:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java线程的生命周期中，存在几种状态。在Thread类里有一个枚举类型State，定义了线程的几种状态，分别有：</p>
<ol>
<li>NEW: 线程创建之后，但是还没有启动(not yet started)。这时候它的状态就是NEW</li>
<li>RUNNABLE: 正在Java虚拟机下跑任务的线程的状态。在RUNNABLE状态下的线程可能会处于等待状态， 因为它正在等待一些系统资源的释放，比如IO</li>
<li>BLOCKED: 阻塞状态，等待锁的释放，比如线程A进入了一个synchronized方法，线程B也想进入这个方法，但是这个方法的锁已经被线程A获取了，这个时候线程B就处于BLOCKED状态</li>
<li>WAITING: 等待状态，处于等待状态的线程是由于执行了3个方法中的任意方法。 1. Object的wait方法，并且没有使用timeout参数; 2. Thread的join方法，没有使用timeout参数 3. LockSupport的park方法。  处于waiting状态的线程会等待另外一个线程处理特殊的行为。 再举个例子，如果一个线程调用了一个对象的wait方法，那么这个线程就会处于waiting状态直到另外一个线程调用这个对象的notify或者notifyAll方法后才会解除这个状态</li>
<li>TIMED_WAITING: 有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。 1. Thread.sleep方法 2. Object的wait方法，带有时间 3. Thread.join方法，带有时间 4. LockSupport的parkNanos方法，带有时间 5. LockSupport的parkUntil方法，带有时间</li>
<li>TERMINATED: 线程中止的状态，这个线程已经完整地执行了它的任务</li>
</ol>
<a id="more"></a>
<p>下面通过几个例子再次说明一下在什么情况下，线程会处于这几种状态：</p>
<h2 id="NEW状态"><a href="#NEW状态" class="headerlink" title="NEW状态"></a>NEW状态</h2><p>NEW状态比较简单，实例化一个线程之后，并且这个线程没有开始执行，这个时候的状态就是NEW：</p>
<pre><code>Thread thread = new Thread();
System.out.println(thread.getState()); // NEW
</code></pre><h2 id="RUNNABLE状态"><a href="#RUNNABLE状态" class="headerlink" title="RUNNABLE状态"></a>RUNNABLE状态</h2><p>正在运行的状态。</p>
<pre><code>Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
        for(int i = 0; i &lt; Integer.MAX_VALUE; i ++) {
            System.out.println(i);
        }
    }
}, &quot;RUNNABLE-Thread&quot;);
thread.start();
</code></pre><p>使用jstack查看线程状态：</p>
<pre><code>&quot;RUNNABLE-Thread&quot; #10 prio=5 os_prio=31 tid=0x00007f8e04981000 nid=0x4f03 runnable [0x000070000124c000]
   java.lang.Thread.State: RUNNABLE
  at java.io.FileOutputStream.writeBytes(Native Method)
  at java.io.FileOutputStream.write(FileOutputStream.java:315)
  at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82)
  at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140)
  - locked &lt;0x000000079764cc50&gt; (a java.io.BufferedOutputStream)
  at java.io.PrintStream.write(PrintStream.java:482)
  - locked &lt;0x0000000797604dc0&gt; (a java.io.PrintStream)
  at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)
  at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291)
  at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104)
  - locked &lt;0x0000000797604d78&gt; (a java.io.OutputStreamWriter)
  at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185)
  at java.io.PrintStream.write(PrintStream.java:527)
  - eliminated &lt;0x0000000797604dc0&gt; (a java.io.PrintStream)
  at java.io.PrintStream.print(PrintStream.java:597)
  at java.io.PrintStream.println(PrintStream.java:736)
  - locked &lt;0x0000000797604dc0&gt; (a java.io.PrintStream)
  at study.thread.ThreadStateTest$1.run(ThreadStateTest.java:23)
  at java.lang.Thread.run(Thread.java:745)
</code></pre><h2 id="BLOCKED状态"><a href="#BLOCKED状态" class="headerlink" title="BLOCKED状态"></a>BLOCKED状态</h2><p>线程A和线程B都需要持有lock对象的锁才能调用方法。如果线程A持有锁，那么线程B处于BLOCKED状态；如果线程B持有锁，那么线程A处于BLOCKED状态。例子中使用Thread.sleep方法主要是用于调试方便：</p>
<pre><code>final Object lock = new Object();
Thread threadA = new Thread(new Runnable() {
    @Override
    public void run() {
        synchronized (lock) {
            System.out.println(Thread.currentThread().getName() + &quot; invoke&quot;);
            try {
                Thread.sleep(20000l);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}, &quot;BLOCKED-Thread-A&quot;);
Thread threadB = new Thread(new Runnable() {
    @Override
    public void run() {
        synchronized (lock) {
            System.out.println(Thread.currentThread().getName() + &quot; invoke&quot;);
            try {
                Thread.sleep(20000l);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}, &quot;BLOCKED-Thread-B&quot;);
threadA.start();
threadB.start();
</code></pre><p>使用jstack查看线程状态。由于线程A先执行，线程B后执行，而且线程A执行后调用了Thread.sleep方法，所以线程A会处于TIMED_WAITING状态，线程B处于BLOCKED状态：</p>
<pre><code>&quot;BLOCKED-Thread-B&quot; #11 prio=5 os_prio=31 tid=0x00007fa7db8ff000 nid=0x5103 waiting for monitor entry [0x000070000134f000]
   java.lang.Thread.State: BLOCKED (on object monitor)
  at study.thread.ThreadStateTest$3.run(ThreadStateTest.java:50)
  - waiting to lock &lt;0x0000000795a03bf8&gt; (a java.lang.Object)
  at java.lang.Thread.run(Thread.java:745)

&quot;BLOCKED-Thread-A&quot; #10 prio=5 os_prio=31 tid=0x00007fa7db15a000 nid=0x4f03 waiting on condition [0x000070000124c000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
  at java.lang.Thread.sleep(Native Method)
  at study.thread.ThreadStateTest$2.run(ThreadStateTest.java:39)
  - locked &lt;0x0000000795a03bf8&gt; (a java.lang.Object)
  at java.lang.Thread.run(Thread.java:745)
</code></pre><h2 id="WAITING状态"><a href="#WAITING状态" class="headerlink" title="WAITING状态"></a>WAITING状态</h2><p>Object的wait方法、Thread的join方法以及Conditon的await方法都会产生WAITING状态。</p>
<p>1.没有时间参数的Object的wait方法</p>
<pre><code>final Object lock = new Object();
Thread threadA = new Thread(new Runnable() {
    @Override
    public void run() {
        synchronized (lock) {
            try {
                lock.wait();
                System.out.println(&quot;wait over&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}, &quot;WAITING-Thread-A&quot;);
Thread threadB = new Thread(new Runnable() {
    @Override
    public void run() {
        synchronized (lock) {
            try {
                Thread.sleep(20000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            lock.notifyAll();
        }
    }
}, &quot;WAITING-Thread-B&quot;);
threadA.start();
threadB.start();
</code></pre><p>WAITING-Thread-A调用了lock的wait，处于WAITING状态：</p>
<pre><code>&quot;WAITING-Thread-B&quot; #11 prio=5 os_prio=31 tid=0x00007f8de992d800 nid=0x5103 waiting on condition [0x000070000134f000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
  at java.lang.Thread.sleep(Native Method)
  at study.thread.ThreadStateTest$5.run(ThreadStateTest.java:84)
  - locked &lt;0x0000000795a03e40&gt; (a java.lang.Object)
  at java.lang.Thread.run(Thread.java:745)

&quot;WAITING-Thread-A&quot; #10 prio=5 os_prio=31 tid=0x00007f8dea193000 nid=0x4f03 in Object.wait() [0x000070000124c000]
   java.lang.Thread.State: WAITING (on object monitor)
  at java.lang.Object.wait(Native Method)
  - waiting on &lt;0x0000000795a03e40&gt; (a java.lang.Object)
  at java.lang.Object.wait(Object.java:502)
  at study.thread.ThreadStateTest$4.run(ThreadStateTest.java:71)
  - locked &lt;0x0000000795a03e40&gt; (a java.lang.Object)
  at java.lang.Thread.run(Thread.java:745)
</code></pre><p>2.Thread的join方法</p>
<pre><code>Thread threadA = new Thread(new Runnable() {
    @Override
    public void run() {
        try {
            Thread.sleep(20000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;Thread-A over&quot;);
    }
}, &quot;WAITING-Thread-A&quot;);
threadA.start();
try {
    threadA.join();
} catch (InterruptedException e) {
    e.printStackTrace();
}
</code></pre><p>主线程main处于WAITING状态：</p>
<pre><code>&quot;WAITING-Thread-A&quot; #10 prio=5 os_prio=31 tid=0x00007fd2d5100000 nid=0x4e03 waiting on condition [0x000070000124c000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
  at java.lang.Thread.sleep(Native Method)
  at study.thread.ThreadStateTest$6.run(ThreadStateTest.java:103)
  at java.lang.Thread.run(Thread.java:745)
&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007fd2d3815000 nid=0x1003 in Object.wait() [0x0000700000182000]
   java.lang.Thread.State: WAITING (on object monitor)
  at java.lang.Object.wait(Native Method)
  - waiting on &lt;0x0000000795a03ec0&gt; (a java.lang.Thread)
  at java.lang.Thread.join(Thread.java:1245)
  - locked &lt;0x0000000795a03ec0&gt; (a java.lang.Thread)
  at java.lang.Thread.join(Thread.java:1319)
  at study.thread.ThreadStateTest.WAITING_join(ThreadStateTest.java:118)
  at study.thread.ThreadStateTest.main(ThreadStateTest.java:13)
  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
  at java.lang.reflect.Method.invoke(Method.java:483)
  at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)
</code></pre><p>3.没有时间参数的Condition的await方法</p>
<p>Condition的await方法跟Obejct的wait方法原理是一样的，故也是WAITING状态</p>
<h2 id="TIMED-WAITING状态"><a href="#TIMED-WAITING状态" class="headerlink" title="TIMED_WAITING状态"></a>TIMED_WAITING状态</h2><p>TIMED_WAITING状态跟TIMEING状态类似，是一个有等待时间的等待状态，不会一直等待下去。</p>
<p>最简单的TIMED_WAITING状态例子就是Thread的sleep方法：</p>
<pre><code>Thread threadA = new Thread(new Runnable() {
    @Override
    public void run() {
        try {
            Thread.sleep(20000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;Thread-A over&quot;);
    }
}, &quot;WAITING-Thread-A&quot;);
threadA.start();
try {
    Thread.sleep(5000);
} catch (InterruptedException e) {
    e.printStackTrace();
}
System.out.println(threadA.getState()); // TIMED_WAITING
</code></pre><p>或者是Object的wait方法带有时间参数、Thread的join方法带有时间参数也会让线程的状态处于TIMED_WAITING状态。</p>
<h2 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h2><p>线程终止的状态，线程执行完成，结束生命周期。</p>
<pre><code>Thread threadA = new Thread();
threadA.start();
try {
    Thread.sleep(5000l);
} catch (InterruptedException e) {
    e.printStackTrace();
}
System.out.println(threadA.getState()); // TERMINATED
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>了解线程的状态可以分析一些问题。</p>
<p>比如线程处于BLOCKED状态，这个时候可以分析一下是不是lock加锁的时候忘记释放了，或者释放的时机不对。导致另外的线程一直处于BLOCKED状态。</p>
<p>比如线程处于WAITING状态，这个时候可以分析一下notifyAll或者signalAll方法的调用时机是否不对。</p>
<p>java自带的jstack工具可以分析查看线程的状态、优先级、描述等具体信息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java线程的生命周期中，存在几种状态。在Thread类里有一个枚举类型State，定义了线程的几种状态，分别有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NEW: 线程创建之后，但是还没有启动(not yet started)。这时候它的状态就是NEW&lt;/li&gt;
&lt;li&gt;RUNNABLE: 正在Java虚拟机下跑任务的线程的状态。在RUNNABLE状态下的线程可能会处于等待状态， 因为它正在等待一些系统资源的释放，比如IO&lt;/li&gt;
&lt;li&gt;BLOCKED: 阻塞状态，等待锁的释放，比如线程A进入了一个synchronized方法，线程B也想进入这个方法，但是这个方法的锁已经被线程A获取了，这个时候线程B就处于BLOCKED状态&lt;/li&gt;
&lt;li&gt;WAITING: 等待状态，处于等待状态的线程是由于执行了3个方法中的任意方法。 1. Object的wait方法，并且没有使用timeout参数; 2. Thread的join方法，没有使用timeout参数 3. LockSupport的park方法。  处于waiting状态的线程会等待另外一个线程处理特殊的行为。 再举个例子，如果一个线程调用了一个对象的wait方法，那么这个线程就会处于waiting状态直到另外一个线程调用这个对象的notify或者notifyAll方法后才会解除这个状态&lt;/li&gt;
&lt;li&gt;TIMED_WAITING: 有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。 1. Thread.sleep方法 2. Object的wait方法，带有时间 3. Thread.join方法，带有时间 4. LockSupport的parkNanos方法，带有时间 5. LockSupport的parkUntil方法，带有时间&lt;/li&gt;
&lt;li&gt;TERMINATED: 线程中止的状态，这个线程已经完整地执行了它的任务&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
  </entry>
  
</feed>
