<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Format's Notes]]></title>
  <subtitle><![CDATA[吃饭睡觉撸代码]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://fangjian0423.github.io/"/>
  <updated>2016-06-04T15:53:47.000Z</updated>
  <id>http://fangjian0423.github.io/</id>
  
  <author>
    <name><![CDATA[Format]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Java线程状态分析]]></title>
    <link href="http://fangjian0423.github.io/2016/06/04/java-thread-state/"/>
    <id>http://fangjian0423.github.io/2016/06/04/java-thread-state/</id>
    <published>2016-06-04T15:53:35.000Z</published>
    <updated>2016-06-04T15:53:47.000Z</updated>
    <content type="html"><![CDATA[<p>Java线程的生命周期中，存在几种状态。在Thread类里有一个枚举类型State，定义了线程的几种状态，分别有：</p>
<ol>
<li>NEW: 线程创建之后，但是还没有启动(not yet started)。这时候它的状态就是NEW</li>
<li>RUNNABLE: 正在Java虚拟机下跑任务的线程的状态。在RUNNABLE状态下的线程可能会处于等待状态， 因为它正在等待一些系统资源的释放，比如IO</li>
<li>BLOCKED: 阻塞状态，等待锁的释放，比如线程A进入了一个synchronized方法，线程B也想进入这个方法，但是这个方法的锁已经被线程A获取了，这个时候线程B就处于BLOCKED状态</li>
<li>WAITING: 等待状态，处于等待状态的线程是由于执行了3个方法中的任意方法。 1. Object的wait方法，并且没有使用timeout参数; 2. Thread的join方法，没有使用timeout参数 3. LockSupport的park方法。  处于waiting状态的线程会等待另外一个线程处理特殊的行为。 再举个例子，如果一个线程调用了一个对象的wait方法，那么这个线程就会处于waiting状态直到另外一个线程调用这个对象的notify或者notifyAll方法后才会解除这个状态</li>
<li>TIMED_WAITING: 有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。 1. Thread.sleep方法 2. Object的wait方法，带有时间 3. Thread.join方法，带有时间 4. LockSupport的parkNanos方法，带有时间 5. LockSupport的parkUntil方法，带有时间</li>
<li>TERMINATED: 线程中止的状态，这个线程已经完整地执行了它的任务</li>
</ol>
<a id="more"></a>
<p>下面通过几个例子再次说明一下在什么情况下，线程会处于这几种状态：</p>
<h2 id="NEW状态">NEW状态</h2><p>NEW状态比较简单，实例化一个线程之后，并且这个线程没有开始执行，这个时候的状态就是NEW：</p>
<pre><code><span class="keyword">Thread</span> <span class="keyword">thread</span> = <span class="literal">new</span> <span class="keyword">Thread</span>();
System<span class="built_in">.</span>out<span class="built_in">.</span>println(<span class="keyword">thread</span><span class="built_in">.</span>getState()); <span class="comment">// NEW</span>
</code></pre><h2 id="RUNNABLE状态">RUNNABLE状态</h2><p>正在运行的状态。</p>
<pre><code><span class="keyword">Thread</span> <span class="keyword">thread</span> = <span class="literal">new</span> <span class="keyword">Thread</span>(<span class="literal">new</span> Runnable() {
    @Override
    <span class="keyword">public</span> <span class="literal">void</span> run() {
        f<span class="subst">or</span>(int i = <span class="number">0</span>; i &lt; <span class="built_in">Integer</span><span class="built_in">.</span>MAX_VALUE; i ++) {
            System<span class="built_in">.</span>out<span class="built_in">.</span>println(i);
        }
    }
}, <span class="string">"RUNNABLE-Thread"</span>);
<span class="keyword">thread</span><span class="built_in">.</span>start();
</code></pre><p>使用jstack查看线程状态：</p>
<pre><code><span class="string">"RUNNABLE-Thread"</span> #<span class="number">10</span> prio=<span class="number">5</span> os_prio=<span class="number">31</span> tid=<span class="number">0</span>x00007f8e04981000 nid=<span class="number">0</span>x4f03 runnable [<span class="number">0</span>x000070000124c000]
   java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.State</span>: RUNNABLE
  at java<span class="class">.io</span><span class="class">.FileOutputStream</span><span class="class">.writeBytes</span>(Native Method)
  at java<span class="class">.io</span><span class="class">.FileOutputStream</span><span class="class">.write</span>(FileOutputStream<span class="class">.java</span>:<span class="number">315</span>)
  at java<span class="class">.io</span><span class="class">.BufferedOutputStream</span><span class="class">.flushBuffer</span>(BufferedOutputStream<span class="class">.java</span>:<span class="number">82</span>)
  at java<span class="class">.io</span><span class="class">.BufferedOutputStream</span><span class="class">.flush</span>(BufferedOutputStream<span class="class">.java</span>:<span class="number">140</span>)
  - locked &lt;<span class="number">0</span>x000000079764cc50&gt; (<span class="tag">a</span> java<span class="class">.io</span><span class="class">.BufferedOutputStream</span>)
  at java<span class="class">.io</span><span class="class">.PrintStream</span><span class="class">.write</span>(PrintStream<span class="class">.java</span>:<span class="number">482</span>)
  - locked &lt;<span class="number">0</span>x0000000797604dc0&gt; (<span class="tag">a</span> java<span class="class">.io</span><span class="class">.PrintStream</span>)
  at sun<span class="class">.nio</span><span class="class">.cs</span><span class="class">.StreamEncoder</span><span class="class">.writeBytes</span>(StreamEncoder<span class="class">.java</span>:<span class="number">221</span>)
  at sun<span class="class">.nio</span><span class="class">.cs</span><span class="class">.StreamEncoder</span><span class="class">.implFlushBuffer</span>(StreamEncoder<span class="class">.java</span>:<span class="number">291</span>)
  at sun<span class="class">.nio</span><span class="class">.cs</span><span class="class">.StreamEncoder</span><span class="class">.flushBuffer</span>(StreamEncoder<span class="class">.java</span>:<span class="number">104</span>)
  - locked &lt;<span class="number">0</span>x0000000797604d78&gt; (<span class="tag">a</span> java<span class="class">.io</span><span class="class">.OutputStreamWriter</span>)
  at java<span class="class">.io</span><span class="class">.OutputStreamWriter</span><span class="class">.flushBuffer</span>(OutputStreamWriter<span class="class">.java</span>:<span class="number">185</span>)
  at java<span class="class">.io</span><span class="class">.PrintStream</span><span class="class">.write</span>(PrintStream<span class="class">.java</span>:<span class="number">527</span>)
  - eliminated &lt;<span class="number">0</span>x0000000797604dc0&gt; (<span class="tag">a</span> java<span class="class">.io</span><span class="class">.PrintStream</span>)
  at java<span class="class">.io</span><span class="class">.PrintStream</span><span class="class">.print</span>(PrintStream<span class="class">.java</span>:<span class="number">597</span>)
  at java<span class="class">.io</span><span class="class">.PrintStream</span><span class="class">.println</span>(PrintStream<span class="class">.java</span>:<span class="number">736</span>)
  - locked &lt;<span class="number">0</span>x0000000797604dc0&gt; (<span class="tag">a</span> java<span class="class">.io</span><span class="class">.PrintStream</span>)
  at study<span class="class">.thread</span><span class="class">.ThreadStateTest</span>$<span class="number">1</span>.<span class="function"><span class="title">run</span><span class="params">(ThreadStateTest.java:<span class="number">23</span>)</span></span>
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)
</code></pre><h2 id="BLOCKED状态">BLOCKED状态</h2><p>线程A和线程B都需要持有lock对象的锁才能调用方法。如果线程A持有锁，那么线程B处于BLOCKED状态；如果线程B持有锁，那么线程A处于BLOCKED状态。例子中使用Thread.sleep方法主要是用于调试方便：</p>
<pre><code><span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();
Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">synchronized</span> (lock) {
            System.out.println(Thread.currentThread().getName() + <span class="string">" invoke"</span>);
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">20000</span>l);
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}, <span class="string">"BLOCKED-Thread-A"</span>);
Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">synchronized</span> (lock) {
            System.out.println(Thread.currentThread().getName() + <span class="string">" invoke"</span>);
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">20000</span>l);
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}, <span class="string">"BLOCKED-Thread-B"</span>);
threadA.start();
threadB.start();
</code></pre><p>使用jstack查看线程状态。由于线程A先执行，线程B后执行，而且线程A执行后调用了Thread.sleep方法，所以线程A会处于TIMED_WAITING状态，线程B处于BLOCKED状态：</p>
<pre><code><span class="string">"BLOCKED-Thread-B"</span> #<span class="number">11</span> prio=<span class="number">5</span> os_prio=<span class="number">31</span> tid=<span class="number">0</span>x00007fa7db8ff000 nid=<span class="number">0</span>x5103 waiting <span class="keyword">for</span> monitor entry [<span class="number">0</span>x000070000134f000]
   java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.State</span>: BLOCKED (on <span class="tag">object</span> monitor)
  at study<span class="class">.thread</span><span class="class">.ThreadStateTest</span>$<span class="number">3</span>.<span class="function"><span class="title">run</span><span class="params">(ThreadStateTest.java:<span class="number">50</span>)</span></span>
  - waiting to lock &lt;<span class="number">0</span>x0000000795a03bf8&gt; (<span class="tag">a</span> java<span class="class">.lang</span><span class="class">.Object</span>)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)

<span class="string">"BLOCKED-Thread-A"</span> #<span class="number">10</span> prio=<span class="number">5</span> os_prio=<span class="number">31</span> tid=<span class="number">0</span>x00007fa7db15a000 nid=<span class="number">0</span>x4f03 waiting on condition [<span class="number">0</span>x000070000124c000]
   java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.State</span>: TIMED_WAITING (sleeping)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.sleep</span>(Native Method)
  at study<span class="class">.thread</span><span class="class">.ThreadStateTest</span>$<span class="number">2</span>.<span class="function"><span class="title">run</span><span class="params">(ThreadStateTest.java:<span class="number">39</span>)</span></span>
  - locked &lt;<span class="number">0</span>x0000000795a03bf8&gt; (<span class="tag">a</span> java<span class="class">.lang</span><span class="class">.Object</span>)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)
</code></pre><h2 id="WAITING状态">WAITING状态</h2><p>Object的wait方法、Thread的join方法以及Conditon的await方法都会产生WAITING状态。</p>
<p>1.没有时间参数的Object的wait方法</p>
<pre><code>final Object <span class="keyword">lock</span> = <span class="keyword">new</span> Object();
Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
    @<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
        synchronized (<span class="keyword">lock</span>) {
            <span class="keyword">try</span> {
                <span class="keyword">lock</span>.wait();
                System.<span class="keyword">out</span>.println(<span class="string">"wait over"</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}, <span class="string">"WAITING-Thread-A"</span>);
Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
    @<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
        synchronized (<span class="keyword">lock</span>) {
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">20000</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
            <span class="keyword">lock</span>.notifyAll();
        }
    }
}, <span class="string">"WAITING-Thread-B"</span>);
threadA.start();
threadB.start();
</code></pre><p>WAITING-Thread-A调用了lock的wait，处于WAITING状态：</p>
<pre><code><span class="string">"WAITING-Thread-B"</span> #<span class="number">11</span> prio=<span class="number">5</span> os_prio=<span class="number">31</span> tid=<span class="number">0</span>x00007f8de992d800 nid=<span class="number">0</span>x5103 waiting on condition [<span class="number">0</span>x000070000134f000]
   java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.State</span>: TIMED_WAITING (sleeping)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.sleep</span>(Native Method)
  at study<span class="class">.thread</span><span class="class">.ThreadStateTest</span>$<span class="number">5</span>.<span class="function"><span class="title">run</span><span class="params">(ThreadStateTest.java:<span class="number">84</span>)</span></span>
  - locked &lt;<span class="number">0</span>x0000000795a03e40&gt; (<span class="tag">a</span> java<span class="class">.lang</span><span class="class">.Object</span>)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)

<span class="string">"WAITING-Thread-A"</span> #<span class="number">10</span> prio=<span class="number">5</span> os_prio=<span class="number">31</span> tid=<span class="number">0</span>x00007f8dea193000 nid=<span class="number">0</span>x4f03 <span class="keyword">in</span> Object.<span class="function"><span class="title">wait</span><span class="params">()</span></span> [<span class="number">0</span>x000070000124c000]
   java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.State</span>: WAITING (on <span class="tag">object</span> monitor)
  at java<span class="class">.lang</span><span class="class">.Object</span><span class="class">.wait</span>(Native Method)
  - waiting on &lt;<span class="number">0</span>x0000000795a03e40&gt; (<span class="tag">a</span> java<span class="class">.lang</span><span class="class">.Object</span>)
  at java<span class="class">.lang</span><span class="class">.Object</span><span class="class">.wait</span>(Object<span class="class">.java</span>:<span class="number">502</span>)
  at study<span class="class">.thread</span><span class="class">.ThreadStateTest</span>$<span class="number">4</span>.<span class="function"><span class="title">run</span><span class="params">(ThreadStateTest.java:<span class="number">71</span>)</span></span>
  - locked &lt;<span class="number">0</span>x0000000795a03e40&gt; (<span class="tag">a</span> java<span class="class">.lang</span><span class="class">.Object</span>)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)
</code></pre><p>2.Thread的join方法</p>
<pre><code>Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
    @<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
        <span class="keyword">try</span> {
            Thread.sleep(<span class="number">20000</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
        System.<span class="keyword">out</span>.println(<span class="string">"Thread-A over"</span>);
    }
}, <span class="string">"WAITING-Thread-A"</span>);
threadA.start();
<span class="keyword">try</span> {
    threadA.<span class="keyword">join</span>();
} <span class="keyword">catch</span> (InterruptedException e) {
    e.printStackTrace();
}
</code></pre><p>主线程main处于WAITING状态：</p>
<pre><code><span class="string">"WAITING-Thread-A"</span> #<span class="number">10</span> prio=<span class="number">5</span> os_prio=<span class="number">31</span> tid=<span class="number">0</span>x00007fd2d5100000 nid=<span class="number">0</span>x4e03 waiting on condition [<span class="number">0</span>x000070000124c000]
   java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.State</span>: TIMED_WAITING (sleeping)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.sleep</span>(Native Method)
  at study<span class="class">.thread</span><span class="class">.ThreadStateTest</span>$<span class="number">6</span>.<span class="function"><span class="title">run</span><span class="params">(ThreadStateTest.java:<span class="number">103</span>)</span></span>
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)
<span class="string">"main"</span> #<span class="number">1</span> prio=<span class="number">5</span> os_prio=<span class="number">31</span> tid=<span class="number">0</span>x00007fd2d3815000 nid=<span class="number">0</span>x1003 <span class="keyword">in</span> Object.<span class="function"><span class="title">wait</span><span class="params">()</span></span> [<span class="number">0</span>x0000700000182000]
   java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.State</span>: WAITING (on <span class="tag">object</span> monitor)
  at java<span class="class">.lang</span><span class="class">.Object</span><span class="class">.wait</span>(Native Method)
  - waiting on &lt;<span class="number">0</span>x0000000795a03ec0&gt; (<span class="tag">a</span> java<span class="class">.lang</span><span class="class">.Thread</span>)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.join</span>(Thread<span class="class">.java</span>:<span class="number">1245</span>)
  - locked &lt;<span class="number">0</span>x0000000795a03ec0&gt; (<span class="tag">a</span> java<span class="class">.lang</span><span class="class">.Thread</span>)
  at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.join</span>(Thread<span class="class">.java</span>:<span class="number">1319</span>)
  at study<span class="class">.thread</span><span class="class">.ThreadStateTest</span><span class="class">.WAITING_join</span>(ThreadStateTest<span class="class">.java</span>:<span class="number">118</span>)
  at study<span class="class">.thread</span><span class="class">.ThreadStateTest</span><span class="class">.main</span>(ThreadStateTest<span class="class">.java</span>:<span class="number">13</span>)
  at sun<span class="class">.reflect</span><span class="class">.NativeMethodAccessorImpl</span><span class="class">.invoke0</span>(Native Method)
  at sun<span class="class">.reflect</span><span class="class">.NativeMethodAccessorImpl</span><span class="class">.invoke</span>(NativeMethodAccessorImpl<span class="class">.java</span>:<span class="number">62</span>)
  at sun<span class="class">.reflect</span><span class="class">.DelegatingMethodAccessorImpl</span><span class="class">.invoke</span>(DelegatingMethodAccessorImpl<span class="class">.java</span>:<span class="number">43</span>)
  at java<span class="class">.lang</span><span class="class">.reflect</span><span class="class">.Method</span><span class="class">.invoke</span>(Method<span class="class">.java</span>:<span class="number">483</span>)
  at com<span class="class">.intellij</span><span class="class">.rt</span><span class="class">.execution</span><span class="class">.application</span><span class="class">.AppMain</span><span class="class">.main</span>(AppMain<span class="class">.java</span>:<span class="number">140</span>)
</code></pre><p>3.没有时间参数的Condition的await方法</p>
<p>Condition的await方法跟Obejct的wait方法原理是一样的，故也是WAITING状态</p>
<h2 id="TIMED_WAITING状态">TIMED_WAITING状态</h2><p>TIMED_WAITING状态跟TIMEING状态类似，是一个有等待时间的等待状态，不会一直等待下去。</p>
<p>最简单的TIMED_WAITING状态例子就是Thread的sleep方法：</p>
<pre><code>Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
    @<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            Thread.sleep(<span class="number">20000</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(<span class="string">"Thread-A over"</span>);
    }
}, <span class="string">"WAITING-Thread-A"</span>);
threadA.start();
<span class="keyword">try</span> {
    Thread.sleep(<span class="number">5000</span>);
} <span class="keyword">catch</span> (InterruptedException e) {
    e.printStackTrace();
}
System.out.println(threadA.getState()); <span class="comment">// TIMED_WAITING</span>
</code></pre><p>或者是Object的wait方法带有时间参数、Thread的join方法带有时间参数也会让线程的状态处于TIMED_WAITING状态。</p>
<h2 id="TERMINATED">TERMINATED</h2><p>线程终止的状态，线程执行完成，结束生命周期。</p>
<pre><code>Thread threadA = <span class="keyword">new</span> Thread();
threadA.start();
<span class="keyword">try</span> {
    Thread.sleep(<span class="number">5000</span>l);
} <span class="keyword">catch</span> (InterruptedException e) {
    e.printStackTrace();
}
System.<span class="keyword">out</span>.println(threadA.getState()); <span class="comment">// TERMINATED</span>
</code></pre><h2 id="总结">总结</h2><p>了解线程的状态可以分析一些问题。</p>
<p>比如线程处于BLOCKED状态，这个时候可以分析一下是不是lock加锁的时候忘记释放了，或者释放的时机不对。导致另外的线程一直处于BLOCKED状态。</p>
<p>比如线程处于WAITING状态，这个时候可以分析一下notifyAll或者signalAll方法的调用时机是否不对。</p>
<p>java自带的jstack工具可以分析查看线程的状态、优先级、描述等具体信息。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java线程的生命周期中，存在几种状态。在Thread类里有一个枚举类型State，定义了线程的几种状态，分别有：</p>
<ol>
<li>NEW: 线程创建之后，但是还没有启动(not yet started)。这时候它的状态就是NEW</li>
<li>RUNNABLE: 正在Java虚拟机下跑任务的线程的状态。在RUNNABLE状态下的线程可能会处于等待状态， 因为它正在等待一些系统资源的释放，比如IO</li>
<li>BLOCKED: 阻塞状态，等待锁的释放，比如线程A进入了一个synchronized方法，线程B也想进入这个方法，但是这个方法的锁已经被线程A获取了，这个时候线程B就处于BLOCKED状态</li>
<li>WAITING: 等待状态，处于等待状态的线程是由于执行了3个方法中的任意方法。 1. Object的wait方法，并且没有使用timeout参数; 2. Thread的join方法，没有使用timeout参数 3. LockSupport的park方法。  处于waiting状态的线程会等待另外一个线程处理特殊的行为。 再举个例子，如果一个线程调用了一个对象的wait方法，那么这个线程就会处于waiting状态直到另外一个线程调用这个对象的notify或者notifyAll方法后才会解除这个状态</li>
<li>TIMED_WAITING: 有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。 1. Thread.sleep方法 2. Object的wait方法，带有时间 3. Thread.join方法，带有时间 4. LockSupport的parkNanos方法，带有时间 5. LockSupport的parkUntil方法，带有时间</li>
<li>TERMINATED: 线程中止的状态，这个线程已经完整地执行了它的任务</li>
</ol>]]>
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java阻塞队列ArrayBlockingQueue和LinkedBlockingQueue实现原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/05/10/java-arrayblockingqueue-linkedblockingqueue-analysis/"/>
    <id>http://fangjian0423.github.io/2016/05/10/java-arrayblockingqueue-linkedblockingqueue-analysis/</id>
    <published>2016-05-10T12:30:57.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>Java中的阻塞队列接口BlockingQueue继承自Queue接口。</p>
<p>BlockingQueue接口提供了3个添加元素方法。</p>
<ol>
<li>add：添加元素到队列里，添加成功返回true，由于容量满了添加失败会抛出IllegalStateException异常</li>
<li>offer：添加元素到队列里，添加成功返回true，添加失败返回false</li>
<li>put：添加元素到队列里，如果容量满了会阻塞直到容量不满</li>
</ol>
<p>3个删除方法。</p>
<ol>
<li>poll：删除队列头部元素，如果队列为空，返回null。否则返回元素。</li>
<li>remove：基于对象找到对应的元素，并删除。删除成功返回true，否则返回false</li>
<li>take：删除队列头部元素，如果队列为空，一直阻塞到队列有元素并删除</li>
</ol>
<p>常用的阻塞队列具体类有ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、LinkedBlockingDeque等。</p>
<p>本文以ArrayBlockingQueue和LinkedBlockingQueue为例，分析它们的实现原理。</p>
<a id="more"></a>
<h2 id="ArrayBlockingQueue">ArrayBlockingQueue</h2><p>ArrayBlockingQueue的原理就是使用一个可重入锁和这个锁生成的两个条件对象进行并发控制(classic two-condition algorithm)。</p>
<p>ArrayBlockingQueue是一个带有长度的阻塞队列，初始化的时候必须要指定队列长度，且指定长度之后不允许进行修改。</p>
<p>它带有的属性如下：</p>
<pre><code><span class="comment">// 存储队列元素的数组，是个循环数组</span>
<span class="keyword">final</span> Object[] items;

<span class="comment">// 拿数据的索引，用于take，poll，peek，remove方法</span>
<span class="keyword">int</span> takeIndex;

<span class="comment">// 放数据的索引，用于put，offer，add方法</span>
<span class="keyword">int</span> putIndex;

<span class="comment">// 元素个数</span>
<span class="keyword">int</span> <span class="keyword">count</span>;

<span class="comment">// 可重入锁</span>
<span class="keyword">final</span> ReentrantLock lock;
<span class="comment">// notEmpty条件对象，由lock创建</span>
<span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;
<span class="comment">// notFull条件对象，由lock创建</span>
<span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;
</code></pre><h3 id="数据的添加">数据的添加</h3><p>ArrayBlockingQueue有不同的几个数据添加方法，add、offer、put方法。</p>
<p>add方法：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{
    <span class="keyword">if</span> (offer(e))
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">else</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);
}
</code></pre><p>add方法内部调用offer方法如下：</p>
<pre><code><span class="function"><span class="keyword">public</span> boolean <span class="title">offer</span>(<span class="params">E e</span>) </span>{
    checkNotNull(e); <span class="comment">// 不允许元素为空</span>
    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;
    <span class="keyword">lock</span>.<span class="keyword">lock</span>(); <span class="comment">// 加锁，保证调用offer方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">if</span> (count == items.length) <span class="comment">// 如果队列已满</span>
            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 直接返回false，添加失败</span>
        <span class="keyword">else</span> {
            insert(e); <span class="comment">// 数组没满的话调用insert方法</span>
            <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 返回true，添加成功</span>
        }
    } <span class="keyword">finally</span> {
        <span class="keyword">lock</span>.unlock(); <span class="comment">// 释放锁，让其他线程可以调用offer方法</span>
    }
}
</code></pre><p>insert方法如下：</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>{
    items[putIndex] = x; <span class="comment">// 元素添加到数组里</span>
    putIndex = inc(putIndex); <span class="comment">// 放数据索引+1，当索引满了变成0</span>
    ++count; <span class="comment">// 元素个数+1</span>
    notEmpty.signal(); <span class="comment">// 使用条件对象notEmpty通知，比如使用take方法的时候队列里没有数据，被阻塞。这个时候队列insert了一条数据，需要调用signal进行通知</span>
}
</code></pre><p>put方法：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(<span class="params">E e</span>) throws InterruptedException </span>{
    checkNotNull(e); <span class="comment">// 不允许元素为空</span>
    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;
    <span class="keyword">lock</span>.lockInterruptibly(); <span class="comment">// 加锁，保证调用put方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">while</span> (count == items.length) <span class="comment">// 如果队列满了，阻塞当前线程，并加入到条件对象notFull的等待队列里</span>
            notFull.await(); <span class="comment">// 线程阻塞并被挂起，同时释放锁</span>
        insert(e); <span class="comment">// 调用insert方法</span>
    } <span class="keyword">finally</span> {
        <span class="keyword">lock</span>.unlock(); <span class="comment">// 释放锁，让其他线程可以调用put方法</span>
    }
}
</code></pre><p>ArrayBlockingQueue的添加数据方法有add，put，offer这3个方法，总结如下：</p>
<p>add方法内部调用offer方法，如果队列满了，抛出IllegalStateException异常，否则返回true</p>
<p>offer方法如果队列满了，返回false，否则返回true</p>
<p>add方法和offer方法不会阻塞线程，put方法如果队列满了会阻塞线程，直到有线程消费了队列里的数据才有可能被唤醒。</p>
<p>这3个方法内部都会使用可重入锁保证原子性。</p>
<h3 id="数据的删除">数据的删除</h3><p>ArrayBlockingQueue有不同的几个数据删除方法，poll、take、remove方法。</p>
<p>poll方法：</p>
<pre><code><span class="function"><span class="keyword">public</span> E <span class="title">poll</span>(<span class="params"></span>) </span>{
    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;
    <span class="keyword">lock</span>.<span class="keyword">lock</span>(); <span class="comment">// 加锁，保证调用poll方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : extract(); <span class="comment">// 如果队列里没元素了，返回null，否则调用extract方法</span>
    } <span class="keyword">finally</span> {
        <span class="keyword">lock</span>.unlock(); <span class="comment">// 释放锁，让其他线程可以调用poll方法</span>
    }
}
</code></pre><p>poll方法内部调用extract方法：</p>
<pre><code><span class="keyword">private</span> <span class="function">E <span class="title">extract</span><span class="params">()</span> </span>{
    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;
    E x = <span class="keyword">this</span>.&lt;E&gt;cast(items[takeIndex]); <span class="comment">// 得到取索引位置上的元素</span>
    items[takeIndex] = <span class="keyword">null</span>; <span class="comment">// 对应取索引上的数据清空</span>
    takeIndex = inc(takeIndex); <span class="comment">// 取数据索引+1，当索引满了变成0</span>
    --count; <span class="comment">// 元素个数-1</span>
    notFull.signal(); <span class="comment">// 使用条件对象notFull通知，比如使用put方法放数据的时候队列已满，被阻塞。这个时候消费了一条数据，队列没满了，就需要调用signal进行通知</span>
    <span class="keyword">return</span> x; <span class="comment">// 返回元素</span>
}
</code></pre><p>take方法：</p>
<pre><code><span class="function"><span class="keyword">public</span> E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException </span>{
    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;
    <span class="keyword">lock</span>.lockInterruptibly(); <span class="comment">// 加锁，保证调用take方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// 如果队列空，阻塞当前线程，并加入到条件对象notEmpty的等待队列里</span>
            notEmpty.await(); <span class="comment">// 线程阻塞并被挂起，同时释放锁</span>
        <span class="keyword">return</span> extract(); <span class="comment">// 调用extract方法</span>
    } <span class="keyword">finally</span> {
        <span class="keyword">lock</span>.unlock(); <span class="comment">// 释放锁，让其他线程可以调用take方法</span>
    }
}
</code></pre><p>remove方法：</p>
<pre><code><span class="function"><span class="keyword">public</span> boolean <span class="title">remove</span>(<span class="params">Object o</span>) </span>{
    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
    final Object[] items = <span class="keyword">this</span>.items;
    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;
    <span class="keyword">lock</span>.<span class="keyword">lock</span>(); <span class="comment">// 加锁，保证调用remove方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">for</span> (<span class="keyword">int</span> i = takeIndex, k = count; k &gt; <span class="number">0</span>; i = inc(i), k--) { <span class="comment">// 遍历元素</span>
            <span class="keyword">if</span> (o.equals(items[i])) { <span class="comment">// 两个对象相等的话</span>
                removeAt(i); <span class="comment">// 调用removeAt方法</span>
                <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 删除成功，返回true</span>
            }
        }
        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 删除成功，返回false</span>
    } <span class="keyword">finally</span> {
        <span class="keyword">lock</span>.unlock(); <span class="comment">// 释放锁，让其他线程可以调用remove方法</span>
    }
}
</code></pre><p>removeAt方法：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{
    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;
    <span class="keyword">if</span> (i == takeIndex) { <span class="comment">// 如果要删除数据的索引是取索引位置，直接删除取索引位置上的数据，然后取索引+1即可</span>
        items[takeIndex] = <span class="keyword">null</span>;
        takeIndex = inc(takeIndex);
    } <span class="keyword">else</span> { <span class="comment">// 如果要删除数据的索引不是取索引位置，移动元素元素，更新取索引和放索引的值</span>
        <span class="keyword">for</span> (;;) {
            <span class="keyword">int</span> nexti = inc(i);
            <span class="keyword">if</span> (nexti != putIndex) {
                items[i] = items[nexti];
                i = nexti;
            } <span class="keyword">else</span> {
                items[i] = <span class="keyword">null</span>;
                putIndex = i;
                <span class="keyword">break</span>;
            }
        }
    }
    --count; <span class="comment">// 元素个数-1</span>
    notFull.signal(); <span class="comment">// 使用条件对象notFull通知，比如使用put方法放数据的时候队列已满，被阻塞。这个时候消费了一条数据，队列没满了，就需要调用signal进行通知 </span>
}
</code></pre><p>ArrayBlockingQueue的删除数据方法有poll，take，remove这3个方法，总结如下：</p>
<p>poll方法对于队列为空的情况，返回null，否则返回队列头部元素。</p>
<p>remove方法取的元素是基于对象的下标值，删除成功返回true，否则返回false。</p>
<p>poll方法和remove方法不会阻塞线程。</p>
<p>take方法对于队列为空的情况，会阻塞并挂起当前线程，直到有数据加入到队列中。</p>
<p>这3个方法内部都会调用notFull.signal方法通知正在等待队列满情况下的阻塞线程。</p>
<h2 id="LinkedBlockingQueue">LinkedBlockingQueue</h2><p>LinkedBlockingQueue是一个使用链表完成队列操作的阻塞队列。链表是单向链表，而不是双向链表。</p>
<p>内部使用放锁和拿锁，这两个锁实现阻塞(“two lock queue” algorithm)。</p>
<p>它带有的属性如下：</p>
<pre><code><span class="comment">// 容量大小</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;

<span class="comment">// 元素个数，因为有2个锁，存在竞态条件，使用AtomicInteger</span>
<span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);

<span class="comment">// 头结点</span>
<span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; head;

<span class="comment">// 尾节点</span>
<span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;

<span class="comment">// 拿锁</span>
<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();

<span class="comment">// 拿锁的条件对象</span>
<span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();

<span class="comment">// 放锁</span>
<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();

<span class="comment">// 放锁的条件对象</span>
<span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();
</code></pre><p>ArrayBlockingQueue只有1个锁，添加数据和删除数据的时候只能有1个被执行，不允许并行执行。</p>
<p>而LinkedBlockingQueue有2个锁，放锁和拿锁，添加数据和删除数据是可以并行进行的，当然添加数据和删除数据的时候只能有1个线程各自执行。</p>
<h3 id="数据的添加-1">数据的添加</h3><p>LinkedBlockingQueue有不同的几个数据添加方法，add、offer、put方法。</p>
<p>add方法内部调用offer方法：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">boolean</span> offer(E e) {
    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// 不允许空元素</span>
    <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span>;
    <span class="keyword">if</span> (<span class="keyword">count</span>.get() == capacity) <span class="comment">// 如果容量满了，返回false</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="keyword">int</span> c = -<span class="number">1</span>;
    Node&lt;E&gt; node = <span class="keyword">new</span> Node(e); <span class="comment">// 容量没满，以新元素构造节点</span>
    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;
    putLock.lock(); <span class="comment">// 放锁加锁，保证调用offer方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">if</span> (<span class="keyword">count</span>.get() &lt; capacity) { <span class="comment">// 再次判断容量是否已满，因为可能拿锁在进行消费数据，没满的话继续执行</span>
            enqueue(node); <span class="comment">// 节点添加到链表尾部</span>
            c = <span class="keyword">count</span>.getAndIncrement(); <span class="comment">// 元素个数+1</span>
            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity) <span class="comment">// 如果容量还没满</span>
                notFull.signal(); <span class="comment">// 在放锁的条件对象notFull上唤醒正在等待的线程，表示可以再次往队列里面加数据了，队列还没满</span>
        }
    } <span class="keyword">finally</span> {
        putLock.unlock(); <span class="comment">// 释放放锁，让其他线程可以调用offer方法</span>
    }
    <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="comment">// 由于存在放锁和拿锁，这里可能拿锁一直在消费数据，count会变化。这里的if条件表示如果队列中还有1条数据</span>
        signalNotEmpty(); <span class="comment">// 在拿锁的条件对象notEmpty上唤醒正在等待的1个线程，表示队列里还有1条数据，可以进行消费</span>
    <span class="keyword">return</span> c &gt;= <span class="number">0</span>; <span class="comment">// 添加成功返回true，否则返回false</span>
}
</code></pre><p>put方法：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">void</span> put(E e) <span class="keyword">throws</span> InterruptedException {
    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// 不允许空元素</span>
    <span class="keyword">int</span> c = -<span class="number">1</span>;
    Node&lt;E&gt; node = <span class="keyword">new</span> Node(e); <span class="comment">// 以新元素构造节点</span>
    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;
    <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span>;
    putLock.lockInterruptibly(); <span class="comment">// 放锁加锁，保证调用put方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">while</span> (<span class="keyword">count</span>.get() == capacity) { <span class="comment">// 如果容量满了</span>
            notFull.await(); <span class="comment">// 阻塞并挂起当前线程</span>
        }
        enqueue(node); <span class="comment">// 节点添加到链表尾部</span>
        c = <span class="keyword">count</span>.getAndIncrement(); <span class="comment">// 元素个数+1</span>
        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity) <span class="comment">// 如果容量还没满</span>
            notFull.signal(); <span class="comment">// 在放锁的条件对象notFull上唤醒正在等待的线程，表示可以再次往队列里面加数据了，队列还没满</span>
    } <span class="keyword">finally</span> {
        putLock.unlock(); <span class="comment">// 释放放锁，让其他线程可以调用put方法</span>
    }
    <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="comment">// 由于存在放锁和拿锁，这里可能拿锁一直在消费数据，count会变化。这里的if条件表示如果队列中还有1条数据</span>
        signalNotEmpty(); <span class="comment">// 在拿锁的条件对象notEmpty上唤醒正在等待的1个线程，表示队列里还有1条数据，可以进行消费</span>
}
</code></pre><p>LinkedBlockingQueue的添加数据方法add，put，offer跟ArrayBlockingQueue一样，不同的是它们的底层实现不一样。</p>
<p>ArrayBlockingQueue中放入数据阻塞的时候，需要消费数据才能唤醒。</p>
<p>而LinkedBlockingQueue中放入数据阻塞的时候，因为它内部有2个锁，可以并行执行放入数据和消费数据，不仅在消费数据的时候进行唤醒插入阻塞的线程，同时在插入的时候如果容量还没满，也会唤醒插入阻塞的线程。</p>
<h3 id="数据的删除-1">数据的删除</h3><p>LinkedBlockingQueue有不同的几个数据删除方法，poll、take、remove方法。</p>
<p>poll方法：</p>
<pre><code><span class="keyword">public</span> E poll() {
    <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span>;
    <span class="keyword">if</span> (<span class="keyword">count</span>.get() == <span class="number">0</span>) <span class="comment">// 如果元素个数为0</span>
        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回null</span>
    E x = <span class="keyword">null</span>;
    <span class="keyword">int</span> c = -<span class="number">1</span>;
    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;
    takeLock.lock(); <span class="comment">// 拿锁加锁，保证调用poll方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">if</span> (<span class="keyword">count</span>.get() &gt; <span class="number">0</span>) { <span class="comment">// 判断队列里是否还有数据</span>
            x = dequeue(); <span class="comment">// 删除头结点</span>
            c = <span class="keyword">count</span>.getAndDecrement(); <span class="comment">// 元素个数-1</span>
            <span class="keyword">if</span> (c &gt; <span class="number">1</span>) <span class="comment">// 如果队列里还有元素</span>
                notEmpty.signal(); <span class="comment">// 在拿锁的条件对象notEmpty上唤醒正在等待的线程，表示队列里还有数据，可以再次消费</span>
        }
    } <span class="keyword">finally</span> {
        takeLock.unlock(); <span class="comment">// 释放拿锁，让其他线程可以调用poll方法</span>
    }
    <span class="keyword">if</span> (c == capacity) <span class="comment">// 由于存在放锁和拿锁，这里可能放锁一直在添加数据，count会变化。这里的if条件表示如果队列中还可以再插入数据</span>
        signalNotFull(); <span class="comment">// 在放锁的条件对象notFull上唤醒正在等待的1个线程，表示队列里还能再次添加数据</span>
                <span class="keyword">return</span> x;
}
</code></pre><p>take方法：</p>
<pre><code><span class="keyword">public</span> <span class="type">E</span> take() <span class="keyword">throws</span> <span class="type">InterruptedException</span> {
    <span class="type">E</span> x;
    int <span class="built_in">c</span> = -<span class="number">1</span>;
    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="built_in">count</span> = this.<span class="built_in">count</span>;
    <span class="keyword">final</span> <span class="type">ReentrantLock</span> takeLock = this.takeLock;
    takeLock.lockInterruptibly(); <span class="comment">// 拿锁加锁，保证调用take方法的时候只有1个线程</span>
    <span class="keyword">try</span> {
        <span class="keyword">while</span> (<span class="built_in">count</span>.<span class="keyword">get</span>() == <span class="number">0</span>) { <span class="comment">// 如果队列里已经没有元素了</span>
            notEmpty.await(); <span class="comment">// 阻塞并挂起当前线程</span>
        }
        x = dequeue(); <span class="comment">// 删除头结点</span>
        <span class="built_in">c</span> = <span class="built_in">count</span>.getAndDecrement(); <span class="comment">// 元素个数-1</span>
        <span class="keyword">if</span> (<span class="built_in">c</span> &gt; <span class="number">1</span>) <span class="comment">// 如果队列里还有元素</span>
            notEmpty.signal(); <span class="comment">// 在拿锁的条件对象notEmpty上唤醒正在等待的线程，表示队列里还有数据，可以再次消费</span>
    } finally {
        takeLock.unlock(); <span class="comment">// 释放拿锁，让其他线程可以调用take方法</span>
    }
    <span class="keyword">if</span> (<span class="built_in">c</span> == capacity) <span class="comment">// 由于存在放锁和拿锁，这里可能放锁一直在添加数据，count会变化。这里的if条件表示如果队列中还可以再插入数据</span>
        signalNotFull(); <span class="comment">// 在放锁的条件对象notFull上唤醒正在等待的1个线程，表示队列里还能再次添加数据</span>
    <span class="keyword">return</span> x;
}
</code></pre><p>remove方法：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">boolean</span> remove(Object o) {
    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
    fullyLock(); <span class="comment">// remove操作要移动的位置不固定，2个锁都需要加锁</span>
    <span class="keyword">try</span> {
        <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.<span class="keyword">next</span>; <span class="comment">// 从链表头结点开始遍历</span>
             p != <span class="keyword">null</span>;
             trail = p, p = p.<span class="keyword">next</span>) {
            <span class="keyword">if</span> (o.equals(p.item)) { <span class="comment">// 判断是否找到对象</span>
                unlink(p, trail); <span class="comment">// 修改节点的链接信息，同时调用notFull的signal方法</span>
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    } <span class="keyword">finally</span> {
        fullyUnlock(); <span class="comment">// 2个锁解锁</span>
    }
}
</code></pre><p>LinkedBlockingQueue的take方法对于没数据的情况下会阻塞，poll方法删除链表头结点，remove方法删除指定的对象。</p>
<p>需要注意的是remove方法由于要删除的数据的位置不确定，需要2个锁同时加锁。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java中的阻塞队列接口BlockingQueue继承自Queue接口。</p>
<p>BlockingQueue接口提供了3个添加元素方法。</p>
<ol>
<li>add：添加元素到队列里，添加成功返回true，由于容量满了添加失败会抛出IllegalStateException异常</li>
<li>offer：添加元素到队列里，添加成功返回true，添加失败返回false</li>
<li>put：添加元素到队列里，如果容量满了会阻塞直到容量不满</li>
</ol>
<p>3个删除方法。</p>
<ol>
<li>poll：删除队列头部元素，如果队列为空，返回null。否则返回元素。</li>
<li>remove：基于对象找到对应的元素，并删除。删除成功返回true，否则返回false</li>
<li>take：删除队列头部元素，如果队列为空，一直阻塞到队列有元素并删除</li>
</ol>
<p>常用的阻塞队列具体类有ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、LinkedBlockingDeque等。</p>
<p>本文以ArrayBlockingQueue和LinkedBlockingQueue为例，分析它们的实现原理。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CountDownLatch和CyclicBarrier的区别]]></title>
    <link href="http://fangjian0423.github.io/2016/05/01/countdownlatch-cyclicbarrier-difference/"/>
    <id>http://fangjian0423.github.io/2016/05/01/countdownlatch-cyclicbarrier-difference/</id>
    <published>2016-04-30T17:59:39.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>CountDownLatch和CyclicBarrier都是java并发包下的工具类。</p>
<p>CountDownLatch用于处理一个或多个线程等待其他所有线程完毕之后再继续进行操作。</p>
<p>比如要处理一个非常耗时的任务，处理完之后需要更新这个任务的状态，需要开多线程去分批次处理任务中的各个子任务，当所有的子任务全部执行完毕之后，就可以更新任务状态了。这个时候就需要使用CountDownLatch。</p>
<p>CyclicBarrier用于N个线程相互等待，当到达条件之后所有线程继续执行。</p>
<p>比如一个抽奖活动，每个线程进行抽奖，当奖品全部抽完之后对各个线程中的用户进行后续操作。</p>
<p>个人理解的两者之间的区别有3点：</p>
<ol>
<li>CountDownLatch可以阻塞1个或N个线程，CyclicBarrier必须要阻塞N个线程</li>
<li>CountDownLatch用完之后就不能再次使用了，CyclicBarrier用完之后可以再次使用，CyclicBarrier还可以做reset操作</li>
<li>CountDownLatch底层使用的是共享锁，CyclicBarrier底层使用的是ReentrantLock和这个lock的条件对象Condition</li>
</ol>
<a id="more"></a>
<h2 id="例子">例子</h2><p>1个CountDownLatch例子，这个例子阻塞3个线程，分别是主线程，Thread1和Thread2。这3个线程会在调用await方法之后阻塞，直到计数器变成0：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> CountDownLatchTest {

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        System.out.println(<span class="string">"主任务开始，一共需要进行7个子任务。第1和第2个子任务需要进行后续操作 "</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i ++) {
            final <span class="keyword">int</span> index = i;
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    System.out.println(<span class="string">"子任务在线程 "</span> + Thread.currentThread().getName() + <span class="string">" 中运行 "</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
                    <span class="keyword">if</span>(index == <span class="number">1</span> || index == <span class="number">2</span>) {
                        <span class="keyword">try</span> {
                            countDownLatch.await();
                        } <span class="keyword">catch</span> (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(<span class="string">"子任务在线程 "</span> + Thread.currentThread().getName() + <span class="string">" 中进行后续操作 "</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
                    }
                    <span class="keyword">if</span>(index != <span class="number">1</span> &amp;&amp; index != <span class="number">2</span>) {
                        <span class="keyword">try</span> {
                            Thread.sleep(<span class="number">5000l</span>);
                        } <span class="keyword">catch</span> (InterruptedException e) {
                            e.printStackTrace();
                        }
                        countDownLatch.countDown();
                    }
                }
            }, <span class="string">"Thread-"</span> + i).start();
        }
        <span class="keyword">try</span> {
            countDownLatch.await();
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(<span class="string">"主任务结束 "</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
    }

}
</code></pre><p>输出：</p>
<pre><code>主任务开始，一共需要进行<span class="number">7</span>个子任务。第<span class="number">1</span>和第<span class="number">2</span>个子任务需要进行后续操作 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">57</span>
子任务在线程 Thread-<span class="number">1</span> 中运行 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">57</span>
子任务在线程 Thread-<span class="number">2</span> 中运行 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">57</span>
子任务在线程 Thread-<span class="number">0</span> 中运行 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">57</span>
子任务在线程 Thread-<span class="number">3</span> 中运行 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">57</span>
子任务在线程 Thread-<span class="number">4</span> 中运行 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">57</span>
子任务在线程 Thread-<span class="number">5</span> 中运行 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">57</span>
子任务在线程 Thread-<span class="number">6</span> 中运行 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">57</span>
子任务在线程 Thread-<span class="number">2</span> 中进行后续操作 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">42</span>:<span class="number">02</span>
主任务结束 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">42</span>:<span class="number">02</span>
子任务在线程 Thread-<span class="number">1</span> 中进行后续操作 <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">42</span>:<span class="number">02</span>
</code></pre><p>1个CyclicBarrier例子，模拟抽奖，每个用户都可以抽奖，当所有的用户抽完奖之后才能开始颁发奖项：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> CyclicBarrierTest {

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws InterruptedException </span>{
        System.out.println(<span class="string">"5个用户开始抽奖"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) {
            final <span class="keyword">int</span> index = i;
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    System.out.println(Thread.currentThread().getName() + <span class="string">" 用户开始抽奖，持续"</span>+(index+<span class="number">1</span>)+<span class="string">"秒"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
                    <span class="keyword">try</span> {
                        Thread.sleep((index + <span class="number">1</span>) * <span class="number">1000</span>);
                        cyclicBarrier.await();
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    } <span class="keyword">catch</span> (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                    System.out.println(<span class="string">"所有用户抽奖完毕，颁发奖项。为用户"</span> + Thread.currentThread().getName() + <span class="string">"颁奖。"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
                }
            }, <span class="string">"Thread-"</span> + i).start();
        }
    }

}
</code></pre><p>输出：</p>
<pre><code><span class="number">5</span>个用户开始抽奖<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">16</span>
Thread-<span class="number">1</span> 用户开始抽奖，持续<span class="number">2</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">16</span>
Thread-<span class="number">2</span> 用户开始抽奖，持续<span class="number">3</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">16</span>
Thread-<span class="number">3</span> 用户开始抽奖，持续<span class="number">4</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">16</span>
Thread-<span class="number">4</span> 用户开始抽奖，持续<span class="number">5</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">16</span>
Thread-<span class="number">0</span> 用户开始抽奖，持续<span class="number">1</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">16</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">0</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">21</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">2</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">21</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">1</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">21</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">4</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">21</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">3</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">57</span>:<span class="number">21</span>
</code></pre><p>CyclicBarrier中的计数器到0之后，可以重用：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> CyclicBarrierTest2 {

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws InterruptedException </span>{
        System.out.println(<span class="string">"5个用户开始抽奖"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) {
            final <span class="keyword">int</span> index = i;
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    System.out.println(Thread.currentThread().getName() + <span class="string">" 用户开始抽奖，持续"</span>+(index+<span class="number">1</span>)+<span class="string">"秒"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
                    <span class="keyword">try</span> {
                        Thread.sleep((index + <span class="number">1</span>) * <span class="number">1000</span>);
                        cyclicBarrier.await();
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    } <span class="keyword">catch</span> (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                    System.out.println(<span class="string">"所有用户抽奖完毕，颁发奖项。为用户"</span> + Thread.currentThread().getName() + <span class="string">"颁奖。"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
                }
            }, <span class="string">"Thread-"</span> + i).start();
        }
        Thread.sleep(<span class="number">5000l</span>);
        System.out.println(<span class="string">"下一轮抽奖开始"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) {
            final <span class="keyword">int</span> index = i;
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    System.out.println(Thread.currentThread().getName() + <span class="string">" 用户开始抽奖，持续"</span>+(index+<span class="number">1</span>)+<span class="string">"秒"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
                    <span class="keyword">try</span> {
                        Thread.sleep((index + <span class="number">1</span>) * <span class="number">1000</span>);
                        cyclicBarrier.await();
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    } <span class="keyword">catch</span> (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                    System.out.println(<span class="string">"所有用户抽奖完毕，颁发奖项。为用户"</span> + Thread.currentThread().getName() + <span class="string">"颁奖。"</span> + DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));
                }
            }, <span class="string">"Thread-"</span> + i).start();
        }
    }

}
</code></pre><p>输出：</p>
<pre><code><span class="number">5</span>个用户开始抽奖<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">40</span>
Thread-<span class="number">1</span> 用户开始抽奖，持续<span class="number">2</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">40</span>
Thread-<span class="number">2</span> 用户开始抽奖，持续<span class="number">3</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">40</span>
Thread-<span class="number">3</span> 用户开始抽奖，持续<span class="number">4</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">40</span>
Thread-<span class="number">4</span> 用户开始抽奖，持续<span class="number">5</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">40</span>
Thread-<span class="number">0</span> 用户开始抽奖，持续<span class="number">1</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">40</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">4</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">0</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">1</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
下一轮抽奖开始<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">3</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">2</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
Thread-<span class="number">1</span> 用户开始抽奖，持续<span class="number">2</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
Thread-<span class="number">0</span> 用户开始抽奖，持续<span class="number">1</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
Thread-<span class="number">2</span> 用户开始抽奖，持续<span class="number">3</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
Thread-<span class="number">3</span> 用户开始抽奖，持续<span class="number">4</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
Thread-<span class="number">4</span> 用户开始抽奖，持续<span class="number">5</span>秒<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">45</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">1</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">50</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">2</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">50</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">0</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">50</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">4</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">50</span>
所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">3</span>颁奖。<span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">50</span>
</code></pre><h2 id="底层分析">底层分析</h2><h3 id="CountDownLatch">CountDownLatch</h3><p>CountDownLatch底层使用的是共享锁，它有个内部类Sync，这个Sync继承AQS，实现了共享锁。</p>
<p>简单画了一下共享锁的实现。</p>
<p>比如有4个线程在等待队列里，并且节点类型都是共享锁。 会唤醒head节点的下一节点中的线程Thread1。head节点就变成了之前head节点的下个节点，然后再做重复操作。 这个过程是一个传播过程，会依次唤醒各个共享节点中的线程。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/lockqueue01.jpg" alt=""></p>
<p>并发包下的另外一个工具类Semaphore底层也是使用共享锁实现的。但是它跟CountDownLatch唯一的区别就是它不会唤醒所有的共享节点中的线程，而是唤醒它能唤醒的最大线程数(由信号量可用大小决定)。</p>
<h3 id="CyclicBarrier">CyclicBarrier</h3><p>CyclicBarrier底层使用的是ReentrantLock和这个lock的条件对象Condition。</p>
<p>它拥有的属性如下：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>{
    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;
}

<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 可重入锁</span>
<span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition(); <span class="comment">// 可重入锁的条件对象</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties; <span class="comment">// 计数器原始值，永远不会变</span>
<span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand; <span class="comment">// 计数器到了之后需要执行的Runnable，可为空</span>
<span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation(); <span class="comment">// 一个Generation对象的实例，当计数器为0的时候这个实例将会重新被构造</span>
<span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">count</span>; <span class="comment">// 计数器当前的值</span>
</code></pre><p>await方法：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">int</span> dowait(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)
    throws InterruptedException, BrokenBarrierException,
           TimeoutException {
    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;
    lock.lock(); <span class="comment">// 加锁，确保每次只有1个线程调用</span>
    <span class="keyword">try</span> {
        <span class="keyword">final</span> Generation g = generation;

        <span class="keyword">if</span> (g.broken) <span class="comment">// 查看generation是否已经损坏</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();

        <span class="keyword">if</span> (Thread.interrupted()) {
            breakBarrier();
            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();
        }

        <span class="keyword">int</span> <span class="keyword">index</span> = --<span class="keyword">count</span>; <span class="comment">// 计数器减一</span>
        <span class="keyword">if</span> (<span class="keyword">index</span> == <span class="number">0</span>) {  <span class="comment">// 如果计数器为0</span>
            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;
            <span class="keyword">try</span> {
                <span class="keyword">final</span> Runnable command = barrierCommand;
                <span class="keyword">if</span> (command != <span class="keyword">null</span>) <span class="comment">// 如果Runnable不为空，执行run方法。注意，这里是直接调用run方法，而不是启动1个新的线程</span>
                    command.run();
                ranAction = <span class="keyword">true</span>;
                nextGeneration(); <span class="comment">// 一个过程结束，重新开始</span>
                <span class="keyword">return</span> <span class="number">0</span>;
            } <span class="keyword">finally</span> {
                <span class="keyword">if</span> (!ranAction)
                    breakBarrier();
            }
        }


        <span class="keyword">for</span> (;;) {
            <span class="keyword">try</span> {
                <span class="keyword">if</span> (!timed)
                    trip.await(); <span class="comment">// 放到Conditon的等待队列里，同时释放锁，让其他线程执行await方法</span>
                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>L)
                    nanos = trip.awaitNanos(nanos);
            } <span class="keyword">catch</span> (InterruptedException ie) {
                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) {
                    breakBarrier();
                    <span class="keyword">throw</span> ie;
                } <span class="keyword">else</span> {
                    <span class="comment">// We're about to finish waiting even if we had not</span>
                    <span class="comment">// been interrupted, so this interrupt is deemed to</span>
                    <span class="comment">// "belong" to subsequent execution.</span>
                    Thread.currentThread().interrupt();
                }
            }

            <span class="keyword">if</span> (g.broken)
                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();

            <span class="keyword">if</span> (g != generation) <span class="comment">// 说明执行了nextGeneration方法，计数器到了0</span>
                <span class="keyword">return</span> <span class="keyword">index</span>;

            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>L) {
                breakBarrier();
                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();
            }
        }
    } <span class="keyword">finally</span> {
        lock.unlock(); <span class="comment">// 解锁</span>
    }
}

<span class="keyword">private</span> <span class="keyword">void</span> nextGeneration() {
    <span class="comment">// 唤醒Conditon等待队列上的所有线程</span>
    trip.signalAll();
    <span class="comment">// 计数器值变成原始值，重新开始</span>
    <span class="keyword">count</span> = parties;
    <span class="comment">// generation被重新构造</span>
    generation = <span class="keyword">new</span> Generation();
}
</code></pre><p>执行过程解释：</p>
<p>比如Thread1执行了await方法，这个时候await方法加锁，确保其他线程不能再次调用await方法。</p>
<p>然后在await方法中把计数器数字减一。</p>
<p>如果计数器还没到0：将Thread1加入到Condition的条件队列，同时释放锁。这个时候其他线程就可以获得await方法的锁并执行。</p>
<p>如果计数器到了0：调用Conditon的signalAll方法，把Condition等待队列上的所有线程移除，移到AQS的等待队列里，然后返回index，释放锁，之后AQS等待队列上的节点中的线程就可以被唤醒了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>CountDownLatch和CyclicBarrier都是java并发包下的工具类。</p>
<p>CountDownLatch用于处理一个或多个线程等待其他所有线程完毕之后再继续进行操作。</p>
<p>比如要处理一个非常耗时的任务，处理完之后需要更新这个任务的状态，需要开多线程去分批次处理任务中的各个子任务，当所有的子任务全部执行完毕之后，就可以更新任务状态了。这个时候就需要使用CountDownLatch。</p>
<p>CyclicBarrier用于N个线程相互等待，当到达条件之后所有线程继续执行。</p>
<p>比如一个抽奖活动，每个线程进行抽奖，当奖品全部抽完之后对各个线程中的用户进行后续操作。</p>
<p>个人理解的两者之间的区别有3点：</p>
<ol>
<li>CountDownLatch可以阻塞1个或N个线程，CyclicBarrier必须要阻塞N个线程</li>
<li>CountDownLatch用完之后就不能再次使用了，CyclicBarrier用完之后可以再次使用，CyclicBarrier还可以做reset操作</li>
<li>CountDownLatch底层使用的是共享锁，CyclicBarrier底层使用的是ReentrantLock和这个lock的条件对象Condition</li>
</ol>]]>
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java实现同步的几种方式]]></title>
    <link href="http://fangjian0423.github.io/2016/04/18/java-synchronize-way/"/>
    <id>http://fangjian0423.github.io/2016/04/18/java-synchronize-way/</id>
    <published>2016-04-18T12:57:57.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>Java提供了很多同步操作，比如synchronized关键字、wait/notifyAll、ReentrantLock、Condition、一些并发包下的工具类、Semaphore，ThreadLocal、AbstractQueuedSynchronizer等。</p>
<p>本文简单说明一下这几种方式的使用。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/synchronize-way.jpeg" alt=""></p>
<a id="more"></a>
<h2 id="ReentrantLock可重入锁">ReentrantLock可重入锁</h2><p>ReentrantLock可重入锁是jdk内置的一个锁对象，可以用来实现同步，基本使用方法如下：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReentrantLockTest</span> {

    <span class="keyword">private</span> ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params"></span>) </span>{
        <span class="keyword">lock</span>.<span class="keyword">lock</span>();
        <span class="keyword">try</span> {
            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" do something synchronize"</span>);
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">5000</span>l);
            } <span class="keyword">catch</span> (InterruptedException e) {
                System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
                Thread.currentThread().interrupt();
            }
        } <span class="keyword">finally</span> {
            <span class="keyword">lock</span>.unlock();
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
        ReentrantLockTest reentrantLockTest = <span class="keyword">new</span> ReentrantLockTest();
        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
                reentrantLockTest.execute();
            }
        });
        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
                reentrantLockTest.execute();
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><p>输出：</p>
<pre><code>Thread-<span class="number">0</span> <span class="keyword">do</span> something synchronize
<span class="comment">// 隔了5秒钟 输入下面</span>
Thread-<span class="number">1</span> <span class="keyword">do</span> something synchronize
</code></pre><p>这个例子表示同一时间段只能有1个线程执行execute方法。</p>
<p>可重入锁中可重入表示的意义在于<strong>对于同一个线程，可以继续调用加锁的方法，而不会被挂起</strong>。可重入锁内部维护一个计数器，对于同一个线程调用lock方法，计数器+1，调用unlock方法，计数器-1。</p>
<p>举个例子再次说明一下可重入的意思，在一个加锁方法execute中调用另外一个加锁方法anotherLock并不会被挂起，可以直接调用(调用execute方法时计数器+1，然后内部又调用了anotherLock方法，计数器+1，变成了2)：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params"></span>) </span>{
    <span class="keyword">lock</span>.<span class="keyword">lock</span>();
    <span class="keyword">try</span> {
        System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" do something synchronize"</span>);
        <span class="keyword">try</span> {
            anotherLock();
            Thread.sleep(<span class="number">5000</span>l);
        } <span class="keyword">catch</span> (InterruptedException e) {
            System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
            Thread.currentThread().interrupt();
        }
    } <span class="keyword">finally</span> {
        <span class="keyword">lock</span>.unlock();
    }
}

<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anotherLock</span>(<span class="params"></span>) </span>{
    <span class="keyword">lock</span>.<span class="keyword">lock</span>();
    <span class="keyword">try</span> {
        System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" invoke anotherLock"</span>);
    } <span class="keyword">finally</span> {
        <span class="keyword">lock</span>.unlock();
    }
}
</code></pre><p>输出：</p>
<pre><code>Thread-0 do something synchronize
Thread-0<span class="instruction"> invoke </span>anotherLock
// 隔了5秒钟 输入下面
Thread-1 do something synchronize
Thread-1<span class="instruction"> invoke </span>anotherLock
</code></pre><h2 id="synchronized关键字">synchronized关键字</h2><p>synchronized关键跟ReentrantLock一样，也支持可重入锁。但是它是一个关键字，是一种语法级别的同步方式，称为内置锁：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedKeyWordTest</span> </span>{

    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>{
            System.out.println(Thread.currentThread().getName() + <span class="string">" do something synchronize"</span>);
        <span class="keyword">try</span> {
            anotherLock();
            Thread.sleep(<span class="number">5000l</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
            Thread.currentThread().interrupt();
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">anotherLock</span><span class="params">()</span> </span>{
        System.out.println(Thread.currentThread().getName() + <span class="string">" invoke anotherLock"</span>);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        SynchronizedKeyWordTest reentrantLockTest = <span class="keyword">new</span> SynchronizedKeyWordTest();
        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                reentrantLockTest.execute();
            }
        });
        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                reentrantLockTest.execute();
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><p>输出结果跟ReentrantLock一样，这个例子说明内置锁可以作用在方法上。它还可以作用到变量，静态方法上。</p>
<p>synchronized跟ReentrantLock相比，有几点局限性：</p>
<ol>
<li>加锁的时候不能设置超时。ReentrantLock有提供tryLock方法，可以设置超时时间，如果超过了这个时间并且没有获取到锁，就会放弃，而synchronized却没有这种功能</li>
<li>ReentrantLock可以使用多个Condition，而synchronized却只能有1个</li>
<li>不能中断一个试图获得锁的线程</li>
<li>ReentrantLock可以选择公平锁和非公平锁</li>
<li>ReentrantLock可以获得正在等待线程的个数，计数器等</li>
</ol>
<h2 id="Condition条件对象">Condition条件对象</h2><p>条件对象的意义在于对于一个已经获取锁的线程，如果还需要等待其他条件才能继续执行的情况下，才会使用Condition条件对象。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConditionTest</span> {

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
        ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();
        Condition condition = <span class="keyword">lock</span>.newCondition();
        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
                <span class="keyword">lock</span>.<span class="keyword">lock</span>();
                <span class="keyword">try</span> {
                    System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" run"</span>);
                    System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" wait for condition"</span>);
                    <span class="keyword">try</span> {
                        condition.await();
                        System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" continue"</span>);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
                        Thread.currentThread().interrupt();
                    }
                } <span class="keyword">finally</span> {
                    <span class="keyword">lock</span>.unlock();
                }
            }
        });
        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
                <span class="keyword">lock</span>.<span class="keyword">lock</span>();
                <span class="keyword">try</span> {
                    System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" run"</span>);
                    System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" sleep 5 secs"</span>);
                    <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">5000</span>l);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
                        Thread.currentThread().interrupt();
                    }
                    condition.signalAll();
                } <span class="keyword">finally</span> {
                    <span class="keyword">lock</span>.unlock();
                }
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><p>这个例子中thread1执行到condition.await()时，当前线程会被挂起，直到thread2调用了condition.signalAll()方法之后，thread1才会重新被激活执行。</p>
<p>这里需要注意的是thread1调用Condition的await方法之后，thread1线程释放锁，然后马上加入到Condition的等待队列，由于thread1释放了锁，thread2获得锁并执行，thread2执行signalAll方法之后，Condition中的等待队列thread1被取出并加入到AQS中，接下来thread2执行完毕之后释放锁，由于thread1已经在AQS的等待队列中，所以thread1被唤醒，继续执行。</p>
<h2 id="wait/notifyAll_方式">wait/notifyAll 方式</h2><p>wait/notifyAll方式跟ReentrantLock/Condition方式的原理是一样的。</p>
<p>Java中每个对象都拥有一个内置锁，在内置锁中调用wait，notify方法相当于调用锁的Condition条件对象的await和signalAll方法。</p>
<p>使用wait/notifyAll实现上面的那个Condition例子：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WaitNotifyAllTest</span> {

    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">doWait</span>(<span class="params"></span>) </span>{
        System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" run"</span>);
        System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" wait for condition"</span>);
        <span class="keyword">try</span> {
            <span class="keyword">this</span>.wait();
            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" continue"</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
            Thread.currentThread().interrupt();
        }
    }

    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">doNotify</span>(<span class="params"></span>) </span>{
        <span class="keyword">try</span> {
            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" run"</span>);
            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" sleep 5 secs"</span>);
            Thread.sleep(<span class="number">5000</span>l);
            <span class="keyword">this</span>.notifyAll();
        } <span class="keyword">catch</span> (InterruptedException e) {
            System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
            Thread.currentThread().interrupt();
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
        WaitNotifyAllTest waitNotifyAllTest = <span class="keyword">new</span> WaitNotifyAllTest();
        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
                waitNotifyAllTest.doWait();
            }
        });
        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
                waitNotifyAllTest.doNotify();
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><p>这里需要注意的是由于Condition是由锁创建的，所以调用wait/notifyAll方法的时候需要获得当前线程的锁，否则会发生IllegalMonitorStateException异常。</p>
<h2 id="ThreadLocal">ThreadLocal</h2><p>ThreadLocal是一种把变量放到线程本地的方式来实现线程同步的。</p>
<p>比如SimpleDateFormat不是一个线程安全的类，可以使用ThreadLocal实现同步。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ThreadLocalTest</span> {

    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;() {
        @<span class="function">Override
        <span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span>(<span class="params"></span>) </span>{
            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);
        }
    };

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
                Date date = <span class="keyword">new</span> Date();
                System.<span class="keyword">out</span>.println(dateFormatThreadLocal.<span class="keyword">get</span>().format(date));
            }
        });
        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
                Date date = <span class="keyword">new</span> Date();
                System.<span class="keyword">out</span>.println(dateFormatThreadLocal.<span class="keyword">get</span>().format(date));
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><h2 id="Semaphore信号量">Semaphore信号量</h2><p>Semaphore信号量被用于控制特定资源在同一个时间被访问的个数。类似连接池的概念，保证资源可以被合理的使用。可以使用构造器初始化资源个数：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> SemaphoreTest {

    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) {
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    <span class="keyword">try</span> {
                        semaphore.acquire();
                        System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + <span class="keyword">new</span> Date());
                        Thread.sleep(<span class="number">5000l</span>);
                        semaphore.release();
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
                    }
                }
            }).start();
        }
    }

}
</code></pre><p>输出：</p>
<pre><code>Thread-<span class="number">1</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">03</span>:<span class="number">46</span> CST <span class="number">2016</span>
Thread-<span class="number">0</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">03</span>:<span class="number">46</span> CST <span class="number">2016</span>
Thread-<span class="number">3</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">03</span>:<span class="number">51</span> CST <span class="number">2016</span>
Thread-<span class="number">2</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">03</span>:<span class="number">51</span> CST <span class="number">2016</span>
Thread-<span class="number">4</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">03</span>:<span class="number">56</span> CST <span class="number">2016</span>
</code></pre><h2 id="并发包下的工具类">并发包下的工具类</h2><p>一般情况下，我们不会使用wait/notifyAll或者ReentrantLock这种比较底层的类，而是使用并发包下提供的一些工具类。</p>
<h3 id="CountDownLatch">CountDownLatch</h3><p>CountDownLatch是一个计数器，它的构造方法中需要设置一个数值，用来设定计数的次数。每次调用countDown()方法之后，这个计数器都会减去1，CountDownLatch会一直阻塞着调用await()方法的线程，直到计数器的值变为0。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> CountDownLatchTest {

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) {
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + <span class="keyword">new</span> Date() + <span class="string">" run"</span>);
                    <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">5000l</span>);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                    countDownLatch.countDown();
                }
            }).start();
        }
        <span class="keyword">try</span> {
            countDownLatch.await();
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(<span class="string">"all thread over"</span>);
    }

}
</code></pre><p>输出：</p>
<pre><code>Thread-<span class="number">2</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">18</span>:<span class="number">30</span> CST <span class="number">2016</span> run
Thread-<span class="number">3</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">18</span>:<span class="number">30</span> CST <span class="number">2016</span> run
Thread-<span class="number">4</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">18</span>:<span class="number">30</span> CST <span class="number">2016</span> run
Thread-<span class="number">0</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">18</span>:<span class="number">30</span> CST <span class="number">2016</span> run
Thread-<span class="number">1</span> Mon Apr <span class="number">18</span> <span class="number">18</span>:<span class="number">18</span>:<span class="number">30</span> CST <span class="number">2016</span> run
all thread over
</code></pre><h3 id="CyclicBarrier">CyclicBarrier</h3><p>CyclicBarrier阻塞调用的线程，直到条件满足时，阻塞的线程同时被打开。</p>
<p>调用await()方法的时候，这个线程就会被阻塞，当调用await()的线程数量到达屏障数的时候，主线程就会取消所有被阻塞线程的状态。</p>
<p>在CyclicBarrier的构造方法中，还可以设置一个barrierAction。</p>
<p>在所有的屏障都到达之后，会启动一个线程来运行这里面的代码。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> CyclicBarrierTest {

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        Random random = <span class="keyword">new</span> Random();
        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) {
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    <span class="keyword">int</span> secs = random.nextInt(<span class="number">5</span>);
                    System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + <span class="keyword">new</span> Date() + <span class="string">" run, sleep "</span> + secs + <span class="string">" secs"</span>);
                    <span class="keyword">try</span> {
                        Thread.sleep(secs * <span class="number">1000</span>);
                        cyclicBarrier.await();
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    } <span class="keyword">catch</span> (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + <span class="keyword">new</span> Date() + <span class="string">" runs over"</span>);
                }
            }).start();
        }
    }

}
</code></pre><p>相比CountDownLatch，CyclicBarrier是可以被循环使用的，而且遇到线程中断等情况时，还可以利用reset()方法，重置计数器，从这些方面来说，CyclicBarrier会比CountDownLatch更加灵活一些。        </p>
<h2 id="AbstractQueuedSynchronizer">AbstractQueuedSynchronizer</h2><p>AQS是很多同步工具类的基础，比如ReentrentLock里的公平锁和非公平锁，Semaphore里的公平锁和非公平锁，CountDownLatch里的锁等他们的底层都是使用AbstractQueuedSynchronizer完成的。</p>
<p>基于AbstractQueuedSynchronizer自定义实现一个独占锁：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>{

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{
        <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {
            setExclusiveOwnerThread(Thread.currentThread());
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{
        setState(<span class="number">0</span>);
        setExclusiveOwnerThread(<span class="keyword">null</span>);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{
        acquire(<span class="number">1</span>);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{
        release(<span class="number">1</span>);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        MySynchronizer mySynchronizer = <span class="keyword">new</span> MySynchronizer();
        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                mySynchronizer.lock();
                <span class="keyword">try</span> {
                    System.out.println(Thread.currentThread().getName() + <span class="string">" run"</span>);
                    System.out.println(Thread.currentThread().getName() + <span class="string">" will sleep 5 secs"</span>);
                    <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">5000l</span>);
                        System.out.println(Thread.currentThread().getName() + <span class="string">" continue"</span>);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);
                        Thread.currentThread().interrupt();
                    }
                } <span class="keyword">finally</span> {
                    mySynchronizer.unlock();
                }
            }
        });
        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                mySynchronizer.lock();
                <span class="keyword">try</span> {
                    System.out.println(Thread.currentThread().getName() + <span class="string">" run"</span>);
                } <span class="keyword">finally</span> {
                    mySynchronizer.unlock();
                }
            }
        });
        thread1.start();
        thread2.start();
    }

}
</code></pre><p>MySynchronizer并没有实现可重入功能，只是简单的一个独占锁。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java提供了很多同步操作，比如synchronized关键字、wait/notifyAll、ReentrantLock、Condition、一些并发包下的工具类、Semaphore，ThreadLocal、AbstractQueuedSynchronizer等。</p>
<p>本文简单说明一下这几种方式的使用。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/synchronize-way.jpeg" alt=""></p>]]>
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk ConcurrentSkipListMap工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/04/12/jdk-concurrentskiplistmap/"/>
    <id>http://fangjian0423.github.io/2016/04/12/jdk-concurrentskiplistmap/</id>
    <published>2016-04-12T11:49:11.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>ConcurrentSkipListMap是一个内部使用跳表，并且支持排序和并发的一个Map。</p>
<p>跳表的介绍：</p>
<p>跳表是一种允许在一个有顺序的序列中进行快速查询的数据结构。</p>
<p>如果在普通的顺序链表中查询一个元素，需要从链表头部开始一个一个节点进行遍历，然后找到节点，如下图所示，要查找234元素的话需要从5元素节点开始一个一个节点进行遍历，这样的效率是非常低的。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist01.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>跳表可以解决这种查询时间过长的问题：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist02.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>从上图可以看到，跳表具有以下几种特性：</p>
<ol>
<li>由很多层组成，level越高的层节点越少，最后一层level用有所有的节点数据</li>
<li>每一层的节点数据也都是有顺序的</li>
<li>上面层的节点肯定会在下面层中出现</li>
<li>每个节点都有两个指针，分别是同一层的下一个节点指针和下一层节点的指针</li>
</ol>
<p>使用跳表查询元素的时间复杂度是O(log n)，跟红黑树一样。查询效率还是不错的，</p>
<p>但是跳表的存储容量变大了，本来一共只有7个节点的数据，使用跳表之后变成了14个节点。</p>
<p>所以跳表是一种使用”空间换时间”的概念用来提高查询效率的链表，开源软件Redis、LevelDB都使用到了跳表。跳表相比B树，红黑树，AVL树时间复杂度一样，但是耗费更多存储空间，但是跳表的优势就是它相比树，实现简单，不需要考虑树的一些rebalance问题。</p>
<a id="more"></a>
<p>下图是一个级别更高的跳表：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist03.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<h2 id="跳表的查询">跳表的查询</h2><p>比如要在下面这个跳表中查找93元素，过程如下：</p>
<ol>
<li>从head节点(最上层的第一个节点)开始找，发现5比93小，继续同一层(Level3)的下一个节点150进行比较</li>
<li>发现105比93大，往下一层(Level2)走，然后找Level2的5元素的下一个节点67，发现67比93小，继续同一层(Level2)的下一个节点150进行比较</li>
<li>发现105比93大，往下一层(Level1)走，然后找Level1的67元素的下一个节点93，找到，返回</li>
</ol>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist04.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<h2 id="跳表新增元素">跳表新增元素</h2><p>跳表中新增元素的话首先会确定Level层，在这个Level以及这个Level以下的层中都加入新的元素，具体的Level层数是通过一个通过一种随机算法获取的，比如之前这个跳表在Level2和Level1中插入666元素：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist05.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>如果Level大于目前跳表的层数，那么会添加新的一层。</p>
<h2 id="跳表删除元素">跳表删除元素</h2><p>在各个层中找到对应的元素并删除即可。</p>
<h2 id="ConcurrentSkipListMap分析">ConcurrentSkipListMap分析</h2><p>ConcurrentSkipListMap对跳表中的几个概念做了一层封装，如下：</p>
<pre><code><span class="comment">// 每个节点的封装，跟层数没有关系</span>
static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> {</span>
    <span class="keyword">final</span> <span class="type">K</span> key; <span class="comment">// 节点的关键字</span>
    volatile <span class="type">Object</span> value; <span class="comment">// 节点的值</span>
    volatile <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next; <span class="comment">// 节点的next节点引用</span>
    ...
}

<span class="comment">// 每一层节点的封装，叫做索引</span>
static <span class="class"><span class="keyword">class</span> <span class="title">Index&lt;K</span>,<span class="title">V&gt;</span> {</span>
    <span class="keyword">final</span> <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; node; <span class="comment">// 对应的节点</span>
    <span class="keyword">final</span> <span class="type">Index</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; down; <span class="comment">// 下一层索引</span>
    volatile <span class="type">Index</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right; <span class="comment">// 同一层的下一个索引</span>
    ...
}

<span class="comment">// 每一层的头索引</span>
static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadIndex&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Index&lt;K</span>,<span class="title">V&gt;</span> {</span>
    <span class="keyword">final</span> int level; <span class="comment">// Level 级别</span>
    <span class="type">HeadIndex</span>(<span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; node, <span class="type">Index</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; down, <span class="type">Index</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right, int level) {
        <span class="keyword">super</span>(node, down, right);
        <span class="keyword">this</span>.level = level;
    }
    ...
}
</code></pre><p>简单分析下ConcurrentSkipListMap的get方法：</p>
<pre><code><span class="keyword">private</span> V doGet(<span class="keyword">Object</span> <span class="variable">key</span>) {
    <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;
    outer: <span class="keyword">for</span> (;;) {
        <span class="comment">// findPredecessor方法表示找到最接近要查找节点的节点，并且这个节点在最下面那一层，这样就保证会遍历所有节点</span>
        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(<span class="variable">key</span>, cmp), n = b.next;;) {
            <span class="keyword">Object</span> v; <span class="built_in">int</span> c;
            <span class="keyword">if</span> (n == <span class="keyword">null</span>) <span class="comment">// 已经遍历节点到最后还是没有找到，break，返回null</span>
                <span class="keyword">break</span> outer;
            Node&lt;K,V&gt; f = n.next;
            <span class="keyword">if</span> (n != b.next) <span class="comment">// 判断比较下一个节点是否发生了变化，如果发生变化break重新开始死循环</span>
                <span class="keyword">break</span>;
            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) {    <span class="comment">// 如果下一个节点已经被删除了</span>
                n.helpDelete(b, f);
                <span class="keyword">break</span>;
            }
            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span>
                <span class="keyword">break</span>;
            <span class="keyword">if</span> ((c = cpr(cmp, <span class="variable">key</span>, n.<span class="variable">key</span>)) == <span class="number">0</span>) {  <span class="comment">// 比较并且找到了，直接返回</span>
                @SuppressWarnings(<span class="string">"unchecked"</span>) V vv = (V)v;
                <span class="keyword">return</span> vv;
            }
            <span class="keyword">if</span> (c &lt; <span class="number">0</span>) <span class="comment">// 找过头了，说明没有对应节点了，跳出循环，返回null</span>
                <span class="keyword">break</span> outer;
            b = n; <span class="comment">// 继续遍历</span>
            n = f; <span class="comment">// 继续遍历</span>
        }
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;
}

<span class="keyword">private</span> Node&lt;K,V&gt; findPredecessor(<span class="keyword">Object</span> <span class="variable">key</span>, Comparator&lt;? <span class="keyword">super</span> K&gt; cmp) {
    <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don't postpone errors</span>
    <span class="keyword">for</span> (;;) { <span class="comment">// 一个死循环内部套着另外一个循环</span>
        <span class="keyword">for</span> (Index&lt;K,V&gt; q = head, r = q.right, d;;) { <span class="comment">// head表示最顶层的第一个索引，从这个索引开始找</span>
            <span class="keyword">if</span> (r != <span class="keyword">null</span>) { <span class="comment">// 如果索引的同一层下一个索引不为null</span>
                Node&lt;K,V&gt; n = r.node;
                K k = n.<span class="variable">key</span>;
                <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) { <span class="comment">// 如果是个已删除节点</span>
                    <span class="keyword">if</span> (!q.unlink(r)) <span class="comment">// 使用cas把已删除节点从跳表上删除掉</span>
                        <span class="keyword">break</span>;           <span class="comment">// 已删除节点从跳表上删除失败，跳出重新循环</span>
                    r = q.right;         <span class="comment">// 继续遍历</span>
                    <span class="keyword">continue</span>;
                }
                <span class="keyword">if</span> (cpr(cmp, <span class="variable">key</span>, k) &gt; <span class="number">0</span>) { <span class="comment">// 使用cas比较要找的关键字和索引内节点的关键字，如果满足比较条件</span>
                    q = r; <span class="comment">// 当前所在索引变成同一层下一个索引</span>
                    r = r.right;  <span class="comment">// 当前所在索引的下一个索引变成下下个索引，继续遍历</span>
                    <span class="keyword">continue</span>;
                }
            }
            <span class="comment">// 直到找出上一层满足不了条件的那个索引</span>
            <span class="keyword">if</span> ((d = q.down) == <span class="keyword">null</span>) <span class="comment">// 找到下一层的索引</span>
                <span class="keyword">return</span> q.node; <span class="comment">// 如果下一层没有索引了，返回找到的最接近的节点</span>
            q = d; <span class="comment">// 下一层开始做相同的操作</span>
            r = d.right; <span class="comment">// 下一层开始做相同的操作</span>
        }
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>ConcurrentSkipListMap是一个内部使用跳表，并且支持排序和并发的一个Map。</p>
<p>跳表的介绍：</p>
<p>跳表是一种允许在一个有顺序的序列中进行快速查询的数据结构。</p>
<p>如果在普通的顺序链表中查询一个元素，需要从链表头部开始一个一个节点进行遍历，然后找到节点，如下图所示，要查找234元素的话需要从5元素节点开始一个一个节点进行遍历，这样的效率是非常低的。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist01.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>跳表可以解决这种查询时间过长的问题：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/skiplist02.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/280/fill/IzFBMDBGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>从上图可以看到，跳表具有以下几种特性：</p>
<ol>
<li>由很多层组成，level越高的层节点越少，最后一层level用有所有的节点数据</li>
<li>每一层的节点数据也都是有顺序的</li>
<li>上面层的节点肯定会在下面层中出现</li>
<li>每个节点都有两个指针，分别是同一层的下一个节点指针和下一层节点的指针</li>
</ol>
<p>使用跳表查询元素的时间复杂度是O(log n)，跟红黑树一样。查询效率还是不错的，</p>
<p>但是跳表的存储容量变大了，本来一共只有7个节点的数据，使用跳表之后变成了14个节点。</p>
<p>所以跳表是一种使用”空间换时间”的概念用来提高查询效率的链表，开源软件Redis、LevelDB都使用到了跳表。跳表相比B树，红黑树，AVL树时间复杂度一样，但是耗费更多存储空间，但是跳表的优势就是它相比树，实现简单，不需要考虑树的一些rebalance问题。</p>]]>
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="map" scheme="http://fangjian0423.github.io/tags/map/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk PriorityQueue优先队列工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/04/10/jdk_priorityqueue/"/>
    <id>http://fangjian0423.github.io/2016/04/10/jdk_priorityqueue/</id>
    <published>2016-04-10T13:36:08.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>优先队列跟普通的队列不一样，普通队列是一种遵循FIFO规则的队列，拿数据的时候按照加入队列的顺序拿取。   而优先队列每次拿数据的时候都会拿出优先级最高的数据。</p>
<p>优先队列内部维护着一个堆，每次取数据的时候都从堆顶拿数据，这就是优先队列的原理。</p>
<p>jdk的优先队列使用PriorityQueue这个类，使用者可以自己定义优先级规则。</p>
<a id="more"></a>
<h2 id="一个PriorityQueue例子">一个PriorityQueue例子</h2><p>定义一个Task类，有2个属性name和level。这个类放到PriorityQueue里，level越大优先级越高：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> Task {
    String name;
    <span class="keyword">int</span> level;

    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name, <span class="keyword">int</span> level)</span> </span>{
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.level = level;
    }

    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> name;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{
        <span class="keyword">this</span>.name = name;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLevel</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> level;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLevel</span><span class="params">(<span class="keyword">int</span> level)</span> </span>{
        <span class="keyword">this</span>.level = level;
    }

    @<span class="function">Override
    <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="string">"Task{"</span> +
                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +
                <span class="string">", level="</span> + level +
                <span class="string">'}'</span>;
    }
}

<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
    PriorityQueue&lt;Task&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> PriorityQueue&lt;Task&gt;(<span class="number">6</span>, <span class="keyword">new</span> Comparator&lt;Task&gt;() {
        @<span class="function">Override
        <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Task t1, Task t2)</span> </span>{
            <span class="keyword">return</span> t2.getLevel() - t1.getLevel();
        }
    });
    <span class="built_in">queue</span>.add(<span class="keyword">new</span> Task(<span class="string">"游戏"</span>, <span class="number">20</span>));
    <span class="built_in">queue</span>.add(<span class="keyword">new</span> Task(<span class="string">"吃饭"</span>, <span class="number">100</span>));
    <span class="built_in">queue</span>.add(<span class="keyword">new</span> Task(<span class="string">"睡觉"</span>, <span class="number">90</span>));
    <span class="built_in">queue</span>.add(<span class="keyword">new</span> Task(<span class="string">"看书"</span>, <span class="number">70</span>));
    <span class="built_in">queue</span>.add(<span class="keyword">new</span> Task(<span class="string">"工作"</span>, <span class="number">80</span>));
    <span class="built_in">queue</span>.add(<span class="keyword">new</span> Task(<span class="string">"撩妹"</span>, <span class="number">10</span>));
    <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) {
        System.out.println(<span class="built_in">queue</span>.poll());
    }
}
</code></pre><p>输出结果：</p>
<pre><code><span class="keyword">Task</span>{name=<span class="string">'吃饭'</span>, level=<span class="number">100</span>}
<span class="keyword">Task</span>{name=<span class="string">'睡觉'</span>, level=<span class="number">90</span>}
<span class="keyword">Task</span>{name=<span class="string">'工作'</span>, level=<span class="number">80</span>}
<span class="keyword">Task</span>{name=<span class="string">'看书'</span>, level=<span class="number">70</span>}
<span class="keyword">Task</span>{name=<span class="string">'游戏'</span>, level=<span class="number">20</span>}
<span class="keyword">Task</span>{name=<span class="string">'撩妹'</span>, level=<span class="number">10</span>}
</code></pre><p>add过程其实就是在最大堆里添加新的元素，添加之后再进行调整：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/priorityqueue01.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>出队相当于每次都是堆顶出堆，堆顶出堆之后然后重新调整：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/priorityqueue02.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<h2 id="PriorityQueue原理分析">PriorityQueue原理分析</h2><p>首先看下PriorityQueue的属性：</p>
<pre><code><span class="keyword">transient</span> <span class="keyword">Object</span>[] queue; <span class="comment">// 堆</span>
<span class="keyword">private</span> <span class="built_in">int</span> <span class="built_in">size</span> = <span class="number">0</span>; <span class="comment">// 元素个数</span>
<span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator; <span class="comment">// 比较器，如果是null，使用元素自身的比较器</span>
</code></pre><p>接下来是PriorityQueue的几个方法介绍。</p>
<p>add，添加元素：</p>
<pre><code><span class="function"><span class="keyword">public</span> boolean <span class="title">add</span><span class="params">(E e)</span> </span>{
    <span class="keyword">return</span> offer(e); <span class="comment">// add方法内部调用offer方法</span>
}

<span class="function"><span class="keyword">public</span> boolean <span class="title">offer</span><span class="params">(E e)</span> </span>{
    <span class="keyword">if</span> (e == null) <span class="comment">// 元素为空的话，抛出NullPointerException异常</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    modCount++;
    <span class="keyword">int</span> i = size;
    <span class="keyword">if</span> (i &gt;= <span class="built_in">queue</span>.length) <span class="comment">// 如果当前用堆表示的数组已经满了，调用grow方法扩容</span>
        grow(i + <span class="number">1</span>); <span class="comment">// 扩容</span>
    size = i + <span class="number">1</span>; <span class="comment">// 元素个数+1</span>
    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="comment">// 堆还没有元素的情况</span>
        <span class="built_in">queue</span>[<span class="number">0</span>] = e; <span class="comment">// 直接给堆顶赋值元素</span>
    <span class="keyword">else</span> <span class="comment">// 堆中已有元素的情况</span>
        siftUp(i, e); <span class="comment">// 重新调整堆，从下往上调整，因为新增元素是加到最后一个叶子节点</span>
    <span class="keyword">return</span> <span class="literal">true</span>;
}

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{
    <span class="keyword">if</span> (comparator != null)  <span class="comment">// 比较器存在的情况下</span>
        siftUpUsingComparator(k, x); <span class="comment">// 使用比较器调整</span>
    <span class="keyword">else</span> <span class="comment">// 比较器不存在的情况下</span>
        siftUpComparable(k, x); <span class="comment">// 使用元素自身的比较器调整</span>
}

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{
    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) { <span class="comment">// 一直循环直到父节点还存在</span>
        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 找到父节点索引</span>
        Object e = <span class="built_in">queue</span>[parent]; <span class="comment">// 赋值父节点元素</span>
        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>) <span class="comment">// 新元素与父元素进行比较，如果满足比较器结果，直接跳出，否则进行调整</span>
            <span class="keyword">break</span>;
        <span class="built_in">queue</span>[k] = e; <span class="comment">// 进行调整，新位置的元素变成了父元素</span>
        k = parent; <span class="comment">// 新位置索引变成父元素索引，进行递归操作</span>
    }
    <span class="built_in">queue</span>[k] = x; <span class="comment">// 新添加的元素添加到堆中</span>
}
</code></pre><p>siftUp方法调用过程如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/priorityqueue03.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>poll，出队方法：</p>
<pre><code><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (size == <span class="number">0</span>)
        <span class="keyword">return</span> null;
    <span class="keyword">int</span> s = --size; <span class="comment">// 元素个数-1</span>
    modCount++;
    E result = (E) <span class="built_in">queue</span>[<span class="number">0</span>]; <span class="comment">// 得到堆顶元素</span>
    E x = (E) <span class="built_in">queue</span>[s]; <span class="comment">// 最后一个叶子节点</span>
    <span class="built_in">queue</span>[s] = null; <span class="comment">// 最后1个叶子节点置空</span>
    <span class="keyword">if</span> (s != <span class="number">0</span>)
        siftDown(<span class="number">0</span>, x); <span class="comment">// 从上往下调整，因为删除元素是删除堆顶的元素</span>
    <span class="keyword">return</span> result;
}

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{
    <span class="keyword">if</span> (comparator != null) <span class="comment">// 比较器存在的情况下</span>
        siftDownUsingComparator(k, x); <span class="comment">// 使用比较器调整</span>
    <span class="keyword">else</span> <span class="comment">// 比较器不存在的情况下</span>
        siftDownComparable(k, x); <span class="comment">// 使用元素自身的比较器调整</span>
}

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{
    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 只需循环节点个数的一般即可</span>
    <span class="keyword">while</span> (k &lt; half) {
        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 得到父节点的左子节点索引</span>
        Object c = <span class="built_in">queue</span>[child]; <span class="comment">// 得到左子元素</span>
        <span class="keyword">int</span> right = child + <span class="number">1</span>; <span class="comment">// 得到父节点的右子节点索引</span>
        <span class="keyword">if</span> (right &lt; size &amp;&amp;
            comparator.compare((E) c, (E) <span class="built_in">queue</span>[right]) &gt; <span class="number">0</span>) <span class="comment">// 左子节点跟右子节点比较，取更大的值</span>
            c = <span class="built_in">queue</span>[child = right];
        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)  <span class="comment">// 然后这个更大的值跟最后一个叶子节点比较</span>

            <span class="keyword">break</span>;
        <span class="built_in">queue</span>[k] = c; <span class="comment">// 新位置使用更大的值</span>
        k = child; <span class="comment">// 新位置索引变成子元素索引，进行递归操作</span>
    }
    <span class="built_in">queue</span>[k] = x; <span class="comment">// 最后一个叶子节点添加到合适的位置</span>
}
</code></pre><p>siftDown方法调用过程如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/priorityqueue04.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>grow扩容方法：</p>
<pre><code><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{
    <span class="keyword">int</span> oldCapacity = <span class="built_in">queue</span>.length;
    <span class="comment">// 新容量</span>
    <span class="comment">// 如果老容量小于64 新容量 = 老容量 + 老容量 + 2</span>
    <span class="comment">// 如果老容量大于等于64 老容量 = 老容量 + 老容量/2</span>
    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?
                                     (oldCapacity + <span class="number">2</span>) :
                                     (oldCapacity &gt;&gt; <span class="number">1</span>));
    <span class="comment">// 溢出处理</span>
    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)
        newCapacity = hugeCapacity(minCapacity);
    <span class="comment">// 使用新容量</span>
    <span class="built_in">queue</span> = Arrays.copyOf(<span class="built_in">queue</span>, newCapacity);
}
</code></pre><p>remove，删除队列元素操作：</p>
<pre><code><span class="function"><span class="keyword">public</span> boolean <span class="title">remove</span><span class="params">(Object o)</span> </span>{
    <span class="keyword">int</span> i = indexOf(o); <span class="comment">// 找到数据对应的索引</span>
    <span class="keyword">if</span> (i == -<span class="number">1</span>) <span class="comment">// 不存在的话返回false</span>
        <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">else</span> { <span class="comment">// 存在的话调用removeAt方法，返回true</span>
        removeAt(i);
        <span class="keyword">return</span> <span class="literal">true</span>;
    }
}

<span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{
    modCount++;
    <span class="keyword">int</span> s = --size; <span class="comment">// 元素个数-1</span>
    <span class="keyword">if</span> (s == i) <span class="comment">// 如果是删除最后一个叶子节点</span>
        <span class="built_in">queue</span>[i] = null; <span class="comment">// 直接置空，删除即可，堆还是保持特质，不需要调整</span>
    <span class="keyword">else</span> { <span class="comment">// 如果是删除的不是最后一个叶子节点</span>
        E moved = (E) <span class="built_in">queue</span>[s]; <span class="comment">// 获得最后1个叶子节点元素</span>
        <span class="built_in">queue</span>[s] = null; <span class="comment">// 最后1个叶子节点置空</span>
        siftDown(i, moved); <span class="comment">// 从上往下调整</span>
        <span class="keyword">if</span> (<span class="built_in">queue</span>[i] == moved) { <span class="comment">// 如果从上往下调整完毕之后发现元素位置没变，从下往上调整</span>
            siftUp(i, moved); <span class="comment">// 从下往上调整</span>
            <span class="keyword">if</span> (<span class="built_in">queue</span>[i] != moved)
                <span class="keyword">return</span> moved;
        }
    }
    <span class="keyword">return</span> null;
}
</code></pre><p>下图这个堆如果删除红色节点100的时候，siftDown之后元素位置没变，所以还得siftUp：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/priorityqueue05.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<h2 id="总结">总结</h2><ol>
<li>jdk内置的优先队列PriorityQueue内部使用一个堆维护数据，每当有数据add进来或者poll出去的时候会对堆做从下往上的调整和从上往下的调整</li>
<li>PriorityQueue不是一个线程安全的类，如果要在多线程环境下使用，可以使用PriorityBlockingQueue这个优先阻塞队列</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>优先队列跟普通的队列不一样，普通队列是一种遵循FIFO规则的队列，拿数据的时候按照加入队列的顺序拿取。   而优先队列每次拿数据的时候都会拿出优先级最高的数据。</p>
<p>优先队列内部维护着一个堆，每次取数据的时候都从堆顶拿数据，这就是优先队列的原理。</p>
<p>jdk的优先队列使用PriorityQueue这个类，使用者可以自己定义优先级规则。</p>]]>
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="queue" scheme="http://fangjian0423.github.io/tags/queue/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[堆、二叉堆、堆排序]]></title>
    <link href="http://fangjian0423.github.io/2016/04/09/heap-heapsort/"/>
    <id>http://fangjian0423.github.io/2016/04/09/heap-heapsort/</id>
    <published>2016-04-09T09:42:18.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>堆的概念：</p>
<p>n个元素序列 { k1, k2, k3, k4, k5, k6 …. kn } 当且仅当满足以下关系时才会被称为堆：</p>
<pre><code>ki &lt;= k2i,ki &lt;= k2i+<span class="number">1</span> 或者 ki &gt;= k2i,ki &gt;= k2i+<span class="number">1</span> (i = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> .. n/<span class="number">2</span>)
</code></pre><p>如果数组的下表是从0开始，那么需要满足 </p>
<pre><code>ki &lt;= k2i+<span class="number">1</span>,ki &lt;= k2i+<span class="number">2</span> 或者 ki &gt;= k2i+<span class="number">1</span>,ki &gt;= k2i+<span class="number">2</span> (i = <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> .. n/<span class="number">2</span>)
</code></pre><p>比如 { 1,3,5,10,15,9 } 这个序列就满足 [1 &lt;= 3; 1 &lt;= 5],  [3 &lt;= 10; 3 &lt;= 15], [5 &lt;= 9] 这3个条件，这个序列就是一个堆。</p>
<p>所以堆其实是一个序列(数组)，如果这个序列满足上述条件，那么就把这个序列看成堆。</p>
<p>堆的实现通常是通过构造二叉堆，因为二叉堆应用很普遍，当不加限定时，堆通常指的就是二叉堆。</p>
<a id="more"></a>
<p>二叉堆的概念：</p>
<p>二叉堆是一种特殊的堆，是一棵完全二叉树或者是近似完全二叉树，同时二叉堆还满足堆的特性：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。</p>
<p>当父节点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父节点的键值总是小于或等于任何一个子节点的键值时为最小堆。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/heap01.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>上图中的最小堆对应的序列是： [1,3,5,9,10,15]  满足最小堆的特性(父节点的键值小于或等于任何一个子节点的键值，并且也满足堆的性质 [1 &lt;= 3; 1 &lt;= 5], [3 &lt;= 9; 3 &lt;= 10], [5 &lt;= 15])</p>
<p>上图中的最大堆对应的序列是： [15,10,9,7,5,3]  满足最大堆的特性(父节点的键值大于或等于任何一个子节点的键值，并且也满足堆的性质 [15 &gt;= 10; 15 &gt;= 9], [10 &gt;= 7; 10 &gt;= 5], [9 &gt;= 3])</p>
<h2 id="堆的操作">堆的操作</h2><h3 id="堆排序">堆排序</h3><p>堆排序指的是对堆这种数据结构进行排序的一种算法。其基本思想如下，以最大堆为例：</p>
<ol>
<li>将数组序列构建成最大堆[ A1, A2, A3 .. An]，这个堆是一个刚初始化无序区，同时有序区为空</li>
<li>堆顶元素A1与最后一个元素An进行交换，得到新的有序区[An]，无序区变成[A1 … An-1]</li>
<li>交换之后可能导致[A1 … An-1]这个无序区不是一个最大堆，[A1 … An-1]无序区重新调整成最大堆。重复步骤2，A1与An-1进行交换，得到新的有序区[An,An-1]，无序区变成[A1 … An-2].. 不断重复，直到有序区的个数为n-1才结束排序过程</li>
</ol>
<p>构造堆的过程如下(以最大堆为例)：</p>
<p>从最后一个非叶子节点开始调整，遍历节点和2个子节点，选择键值最大的节点的键值代替父节点的键值，如果进行了调整，调整之后的两个子节点可能不符合堆特性，递归调整。一直直到调整完根节点。</p>
<p>以序列[3,5,15,9,10,1]为例进行的堆排序：</p>
<p>首先第1步先把数组转换成完全二叉树：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/heap02.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>接下来是第2、3步构造有序区和无序区：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/heap03.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>构造完之后有序区的元素依次是：1，3，5，9，10，15</p>
<p>简单地使用java写一下堆排序：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> HeapSort {

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size, <span class="keyword">int</span> index)</span> </span>{
        <span class="keyword">int</span> leftSonIndex = <span class="number">2</span> * index + <span class="number">1</span>;
        <span class="keyword">int</span> rightSonIndex = <span class="number">2</span> * index + <span class="number">2</span>;
        <span class="keyword">int</span> temp = index;
        <span class="keyword">if</span>(index &lt;= size / <span class="number">2</span>) {
            <span class="keyword">if</span>(leftSonIndex &lt; size &amp;&amp; arr[temp] &lt; arr[leftSonIndex]) {
                temp = leftSonIndex;
            }
            <span class="keyword">if</span>(rightSonIndex &lt; size &amp;&amp; arr[temp] &lt; arr[rightSonIndex]) {
                temp = rightSonIndex;
            }
            <span class="comment">// 左右子节点的值存在比父节点的值更大</span>
            <span class="keyword">if</span>(temp != index) {
                swap(arr, index, temp); <span class="comment">// 交换值</span>
                maxHeapify(arr, size, temp); <span class="comment">// 递归调整</span>
            }
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size)</span> </span>{
        <span class="comment">// 构造成最大堆</span>
        buildMaxHeap(arr, arr.length);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i --) {
            <span class="comment">// 先交换堆顶元素和无序区最后一个元素</span>
            swap(arr, <span class="number">0</span>, i);
            <span class="comment">// 重新调整无序区</span>
            buildMaxHeap(arr, i - <span class="number">1</span>);
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size)</span> </span>{
        <span class="keyword">for</span>(<span class="keyword">int</span> i = size / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --) { <span class="comment">// 最后一个非叶子节点开始调整</span>
            maxHeapify(arr, size, i);
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{
        <span class="keyword">int</span> temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        <span class="keyword">int</span>[] arr = { <span class="number">3</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">1</span>};
        System.out.println(<span class="string">"before build: "</span> + Arrays.toString(arr)); <span class="comment">// before build: [3, 5, 15, 9, 10, 1]</span>
        buildMaxHeap(arr, arr.length);
        System.out.println(<span class="string">"after build: "</span> + Arrays.toString(arr)); <span class="comment">// after build: [15, 10, 3, 9, 5, 1]</span>
        heapSort(arr, arr.length);
        System.out.println(<span class="string">"after sort: "</span> + Arrays.toString(arr)); <span class="comment">// after sort: [1, 3, 5, 9, 10, 15]</span>
    }

}
</code></pre><h3 id="添加">添加</h3><p>在最大堆[ 15,10,9,7,5,3 ]上添加一个新的元素 11 ，执行的步骤如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/heap04.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<h3 id="删除">删除</h3><p>在最大堆[ 15,10,9,7,5,3 ]上删除元素 10 ，执行的步骤如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/heap05.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>堆的概念：</p>
<p>n个元素序列 { k1, k2, k3, k4, k5, k6 …. kn } 当且仅当满足以下关系时才会被称为堆：</p>
<pre><code>ki &lt;= k2i,ki &lt;= k2i+<span class="number">1</span> 或者 ki &gt;= k2i,ki &gt;= k2i+<span class="number">1</span> (i = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> .. n/<span class="number">2</span>)
</code></pre><p>如果数组的下表是从0开始，那么需要满足 </p>
<pre><code>ki &lt;= k2i+<span class="number">1</span>,ki &lt;= k2i+<span class="number">2</span> 或者 ki &gt;= k2i+<span class="number">1</span>,ki &gt;= k2i+<span class="number">2</span> (i = <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> .. n/<span class="number">2</span>)
</code></pre><p>比如 { 1,3,5,10,15,9 } 这个序列就满足 [1 &lt;= 3; 1 &lt;= 5],  [3 &lt;= 10; 3 &lt;= 15], [5 &lt;= 9] 这3个条件，这个序列就是一个堆。</p>
<p>所以堆其实是一个序列(数组)，如果这个序列满足上述条件，那么就把这个序列看成堆。</p>
<p>堆的实现通常是通过构造二叉堆，因为二叉堆应用很普遍，当不加限定时，堆通常指的就是二叉堆。</p>]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://fangjian0423.github.io/tags/algorithm/"/>
    
      <category term="algorithm" scheme="http://fangjian0423.github.io/categories/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk TreeSet工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/04/08/jdk_treeset/"/>
    <id>http://fangjian0423.github.io/2016/04/08/jdk_treeset/</id>
    <published>2016-04-07T16:20:23.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>TreeSet跟HashSet，LinkedHashSet一样，都是Set接口的实现类。</p>
<p>HashSet内部使用的HashMap，LinkedHashSet继承HashSet，内部使用的是LinkedHashMap。</p>
<p>TreeSet实现的是NavigableSet接口，而不是HashSet和LinkedHashSet实现的Set接口。</p>
<p>NavigableSet接口继承自SortedSet接口，SortedSet接口继承自Set接口。</p>
<p>NavigableSet接口比Set更方便，可以使用firstKey[最小关键字]，lastKey[最大关键字]，pollFirstEntry[最小键值对]，pollLastEntry[最大键值对]，higherEntry[比参数关键字要大的键值对]，lowerEntry[比参数关键字要小的键值对]等等方便方法，可以使用这些方法方便地获取期望位置上的键值对。</p>
<a id="more"></a>
<h2 id="TreeSet原理分析">TreeSet原理分析</h2><p>TreeSet跟HashSet一样，内部都使用Map，HashSet内部使用的是HashMap，但是TreeSet使用的是NavigableMap。</p>
<p>TreeSet的几个构造方法会构造NavigableMap，如果使用没有参数的构造函数，NavigableMap是TreeMap：</p>
<pre><code>TreeSet(NavigableMap&lt;E,Object&gt; m) {
    <span class="keyword">this</span>.m = m;
}

<span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>{
    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());
}

<span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>{
    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));
}
</code></pre><p>add方法调用Map的put方法：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{
    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;
}
</code></pre><p>remove方法调用Map的remove方法：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>{
    <span class="keyword">return</span> m.remove(o)==PRESENT;
}
</code></pre><p>原理基本跟HashSet一样。</p>
<pre><code><span class="comment">// 最小的关键字</span>
public <span class="keyword">E</span> first() {
    <span class="keyword">return</span> <span class="keyword">m</span>.firstKey();
}

<span class="comment">// 最大的关键字</span>
public <span class="keyword">E</span> last() {
    <span class="keyword">return</span> <span class="keyword">m</span>.lastKey();
}

<span class="comment">// 比参数小的关键字</span>
public <span class="keyword">E</span> <span class="literal">lower</span>(<span class="keyword">E</span> <span class="keyword">e</span>) {
    <span class="keyword">return</span> <span class="keyword">m</span>.lowerKey(<span class="keyword">e</span>);
}
</code></pre><h2 id="一个TreeSet例子">一个TreeSet例子</h2><p>使用没有参数的TreeMap构造函数，内部的Map使用TreeMap红黑树：</p>
<pre><code>TreeSet&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> TreeSet&lt;<span class="keyword">String</span>&gt;();
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"1:语文"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"2:数学"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"3:英语"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"4:政治"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"5:物理"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"6:化学"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"7:生物"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"8:体育"</span>);
</code></pre><p>内部红黑树结构如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treeset01.jpg" alt=""></p>
<p>还可以调用TreeSet的其他方法：</p>
<pre><code><span class="built_in">set</span>.<span class="keyword">first</span>();<span class="comment"> // 1:语文</span>
<span class="built_in">set</span>.<span class="keyword">last</span>();<span class="comment"> // 8:体育</span>
<span class="built_in">set</span>.higher(<span class="string">"5:物理"</span>);<span class="comment"> // 6:化学</span>
<span class="built_in">set</span>.<span class="built_in">lower</span>(<span class="string">"5:物理"</span>);<span class="comment"> // 4:政治</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>TreeSet跟HashSet，LinkedHashSet一样，都是Set接口的实现类。</p>
<p>HashSet内部使用的HashMap，LinkedHashSet继承HashSet，内部使用的是LinkedHashMap。</p>
<p>TreeSet实现的是NavigableSet接口，而不是HashSet和LinkedHashSet实现的Set接口。</p>
<p>NavigableSet接口继承自SortedSet接口，SortedSet接口继承自Set接口。</p>
<p>NavigableSet接口比Set更方便，可以使用firstKey[最小关键字]，lastKey[最大关键字]，pollFirstEntry[最小键值对]，pollLastEntry[最大键值对]，higherEntry[比参数关键字要大的键值对]，lowerEntry[比参数关键字要小的键值对]等等方便方法，可以使用这些方法方便地获取期望位置上的键值对。</p>]]>
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="set" scheme="http://fangjian0423.github.io/tags/set/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk TreeMap工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/04/07/jdk_treemap/"/>
    <id>http://fangjian0423.github.io/2016/04/07/jdk_treemap/</id>
    <published>2016-04-06T16:55:31.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>TreeMap是jdk中基于红黑树的一种map实现。HashMap底层是使用链表法解决冲突的哈希表，LinkedHashMap继承自HashMap，内部同样也是使用链表法解决冲突的哈希表，但是额外添加了一个双向链表用于处理元素的插入顺序或访问访问。</p>
<p>既然TreeMap底层使用的是红黑树，首先先来简单了解一下红黑树的定义。</p>
<p>红黑树是一棵平衡二叉查找树，同时还需要满足以下5个规则：</p>
<ol>
<li>每个节点只能是红色或者黑点</li>
<li>根节点是黑点</li>
<li>叶子节点(Nil节点，空节点)是黑色节点</li>
<li>如果一个节点是红色节点，那么它的两个子节点必须是黑色节点(一条路径上不能出现相邻的两个红色节点)</li>
<li>从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点</li>
</ol>
<p>红黑树的这些特性决定了它的查询、插入、删除操作的时间复杂度均为O(log n)。</p>
<a id="more"></a>
<h2 id="一个TreeMap例子">一个TreeMap例子</h2><p>一段TreeMap代码：</p>
<pre><code>TreeMap&lt;Integer, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();
treeMap.put(<span class="number">1</span>, <span class="string">"语文"</span>);
treeMap.put(<span class="number">2</span>, <span class="string">"数学"</span>);
treeMap.put(<span class="number">3</span>, <span class="string">"英语"</span>);
treeMap.put(<span class="number">4</span>, <span class="string">"政治"</span>);
treeMap.put(<span class="number">5</span>, <span class="string">"物理"</span>);
treeMap.put(<span class="number">6</span>, <span class="string">"化学"</span>);
treeMap.put(<span class="number">7</span>, <span class="string">"生物"</span>);
treeMap.put(<span class="number">8</span>, <span class="string">"体育"</span>);
</code></pre><p>执行过程：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap01.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>从上面这个例子看到，红黑树添加新节点的时候可能会对节点进行旋转，以保证树的局部平衡。</p>
<h2 id="TreeMap原理分析">TreeMap原理分析</h2><p>TreeMap内部类Entry表示红黑树中的节点：</p>
<pre><code><span class="keyword">static</span> <span class="keyword">final</span> class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    K <span class="variable">key</span>; <span class="comment">// 关键字</span>
    V value; <span class="comment">// 值</span>
    Entry&lt;K,V&gt; left; <span class="comment">// 左节点</span>
    Entry&lt;K,V&gt; right; <span class="comment">// 右节点</span>
    Entry&lt;K,V&gt; parent; <span class="comment">// 父节点</span>
    <span class="built_in">boolean</span> <span class="built_in">color</span> = BLACK; <span class="comment">// 颜色，默认为黑色</span>

    Entry(K <span class="variable">key</span>, V value, Entry&lt;K,V&gt; parent) {
        <span class="keyword">this</span>.<span class="variable">key</span> = <span class="variable">key</span>;
        <span class="keyword">this</span>.value = value;
        <span class="keyword">this</span>.parent = parent;
    }

    ...
}
</code></pre><p>TreeMap的属性：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root; <span class="comment">// 根节点</span>

<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> <span class="keyword">size</span> = <span class="number">0</span>; <span class="comment">// 节点个数</span>
</code></pre><h3 id="put操作">put操作</h3><p>红黑树新节点的添加一定是红色节点，添加完新的节点之后会进行旋转操作以保持红黑树的特性。</p>
<p>为什么新添加的节点一定是红色节点，如果添加的是黑色节点，那么就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的；但是如果插入的是红色节点，只需要解决其父节点也为红色节点的这个冲突即可。</p>
<p>以N为新插入节点，P为其父节点，U为其父节点的兄弟节点，R为P和U的父亲节点进行分析。如果N的父节点为黑色节点，那直接添加新节点即可，没有产生冲突。如果出现P节点是红色节点，那便产生冲突，可以分为以下几种冲突：</p>
<p>(1) P为红色节点，且U也为红色节点，P不论是R的左节点还是右节点</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap04.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>将P和U接口变成黑色节点，R节点变成红色节点。修改之后如果R节点的父节点也是红色节点，那么在R节点上执行相同操作，形成了一个递归过程。如果R节点是根节点的话，那么直接把R节点修改成黑色节点。</p>
<p>(2) P为红色节点，U为黑色节点或缺少，且N是P的右节点、P是R的左节点 或者 P为红色节点，U为黑色节点或缺少，且N是P的左节点、P是R的右节点</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap07.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>这两种情况分别对P进行左旋和右旋操作。操作结果就变成了冲突3。 (总结起来就是左右变左左，右左变右右)</p>
<p>(3) P为红色节点，U为黑色节点或缺少，且N是P的左节点、P是R的左节点 或者 P为红色节点，U为黑色节点或缺少，且N是P的右节点、P是R的右节点</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap08.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>这两种情况分别对祖父R进行右旋和左旋操作。完美解决冲突。(总结起来就是左左祖右，右右祖左)</p>
<p>这3个新增节点的冲突处理方法了解之后，我们回过头来看本文一开始的例子中添加最后一个[8:体育]节点是如何处理冲突的：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap09.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>接下来我们看TreeMap是如何实现新增节点并处理冲突的。</p>
<p>TreeMap对应的put方法：</p>
<pre><code><span class="keyword">public</span> V put(K <span class="variable">key</span>, V value) {
    Entry&lt;K,V&gt; t = root;
    <span class="keyword">if</span> (t == <span class="keyword">null</span>) { <span class="comment">// 如果根节点是空的，说明是第一次插入数据</span>
        compare(<span class="variable">key</span>, <span class="variable">key</span>);

        root = <span class="keyword">new</span> Entry&lt;&gt;(<span class="variable">key</span>, value, <span class="keyword">null</span>); <span class="comment">// 构造根节点，并赋值给属性root，默认颜色是黑色</span>
        <span class="built_in">size</span> = <span class="number">1</span>; <span class="comment">// 节点数 = 1</span>
        modCount++;
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
    <span class="built_in">int</span> cmp;
    Entry&lt;K,V&gt; parent;
    <span class="comment">// split comparator and comparable paths</span>
    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;
    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) { <span class="comment">// 比较器存在</span>
        do { <span class="comment">// 遍历寻找节点，关键字比节点小找左节点，比节点大的找右节点，直到找到那个叶子节点，会保存需要新构造节点的父节点到parent变量里</span>
            parent = t;
            cmp = cpr.compare(<span class="variable">key</span>, t.<span class="variable">key</span>);
            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)
                t = t.left;
            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)
                t = t.right;
            <span class="keyword">else</span>
                <span class="keyword">return</span> t.setValue(value); <span class="comment">// 关键字存在的话，直接用值覆盖原节点的关键字的值，并返回</span>
        } <span class="keyword">while</span> (t != <span class="keyword">null</span>);
    }
    <span class="keyword">else</span> { <span class="comment">// 比较器不存在</span>
        <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>)
            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
        @SuppressWarnings(<span class="string">"unchecked"</span>)
            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) <span class="variable">key</span>; <span class="comment">// 比较器不存在直接将关键字转换成比较器，如果关键字不是一个Comparable接口实现类，将会报错</span>
        do { <span class="comment">// 遍历寻找节点，关键字比节点小找左节点，比节点大的找右节点，直到找到那个叶子节点，会保存需要新构造节点的父节点到parent变量里</span>
            parent = t;
            cmp = k.compareTo(t.<span class="variable">key</span>);
            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)
                t = t.left;
            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)
                t = t.right;
            <span class="keyword">else</span>
                <span class="keyword">return</span> t.setValue(value); <span class="comment">// 关键字存在的话，直接用值覆盖原节点的关键字的值，并返回</span>
        } <span class="keyword">while</span> (t != <span class="keyword">null</span>);
    }
    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(<span class="variable">key</span>, value, parent); <span class="comment">// 构造新的关键字节点</span>
    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="comment">// 需要在左节点构造</span>
        parent.left = e;
    <span class="keyword">else</span> <span class="comment">// 需要在右节点构造</span>
        parent.right = e;
    fixAfterInsertion(e); <span class="comment">// 插入节点之后，处理冲突以保持树符合红黑树的特性</span>
    <span class="built_in">size</span>++;
    modCount++;
    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</code></pre><p>fixAfterInsertion方法处理红黑树冲突实现如下：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">void</span> fixAfterInsertion(Entry&lt;K,V&gt; x) {
    x.<span class="built_in">color</span> = RED; <span class="comment">// 新增的节点一定是红色节点</span>

    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.<span class="built_in">color</span> == RED) { <span class="comment">// P节点是红色节点并且N节点不是根节点的话一直循环</span>
        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) { <span class="comment">// P节点是R节点的左节点</span>
            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); <span class="comment">// y就是U节点</span>
            <span class="keyword">if</span> (colorOf(y) == RED) { <span class="comment">// 如果U节点是红色节点，说明P和U这两个节点都是红色节点，满足冲突(1)</span>
                setColor(parentOf(x), BLACK); <span class="comment">// 冲突(1)解决方案 把P设置为黑色</span>
                setColor(y, BLACK); <span class="comment">// 冲突(1)解决方案 把U设置为黑色</span>
                setColor(parentOf(parentOf(x)), RED); <span class="comment">// 冲突(1)解决方案 把R设置为红色</span>
                x = parentOf(parentOf(x)); <span class="comment">// 递归处理R节点</span>
            } <span class="keyword">else</span> { <span class="comment">// 如果U节点是黑色节点，满足冲突(2)或(3)</span>
                <span class="keyword">if</span> (x == rightOf(parentOf(x))) { <span class="comment">// 如果N节点是P节点的右节点，满足冲突(2)的第一种情况</span>
                    x = parentOf(x);
                    rotateLeft(x); <span class="comment">// P节点进行左旋操作</span>
                }
                <span class="comment">// P节点左旋操作之后，满足了冲突(3)的第一种情况或者N一开始就是P节点的左节点，这本来就是冲突(3)的第一种情况</span>
                setColor(parentOf(x), BLACK);  <span class="comment">// P节点和R节点交换颜色，P节点变成黑色</span>
                setColor(parentOf(parentOf(x)), RED); <span class="comment">// P节点和R节点交换颜色，R节点变成红色</span>
                rotateRight(parentOf(parentOf(x))); <span class="comment">// R节点右旋操作</span>
            }
        } <span class="keyword">else</span> { <span class="comment">// P节点是R节点的右节点</span>
            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); <span class="comment">// y就是U节点</span>
            <span class="keyword">if</span> (colorOf(y) == RED) { <span class="comment">// 如果U节点是红色节点，说明P和U这两个节点都是红色节点，满足冲突(1)</span>
                setColor(parentOf(x), BLACK); <span class="comment">// 冲突(1)解决方案 把P设置为黑色</span>
                setColor(y, BLACK); <span class="comment">// 冲突(1)解决方案 把U设置为黑色</span>
                setColor(parentOf(parentOf(x)), RED); <span class="comment">// 冲突(1)解决方案 把R设置为红色</span>
                x = parentOf(parentOf(x)); <span class="comment">// 递归处理R节点</span>
            } <span class="keyword">else</span> { <span class="comment">// 如果U节点是黑色节点，满足冲突(2)或(3)</span>
                <span class="keyword">if</span> (x == leftOf(parentOf(x))) { <span class="comment">// 如果N节点是P节点的左节点，满足冲突(2)的第二种情况</span>
                    x = parentOf(x);
                    rotateRight(x); <span class="comment">// P节点右旋</span>
                }
                <span class="comment">// P节点右旋操作之后，满足了冲突(3)的第二种情况或者N一开始就是P节点的右节点，这本来就是冲突(3)的第二种情况</span>
                setColor(parentOf(x), BLACK); <span class="comment">// P节点和R节点交换颜色，P节点变成黑色</span>
                setColor(parentOf(parentOf(x)), RED); <span class="comment">// P节点和R节点交换颜色，R节点变成红色</span>
                rotateLeft(parentOf(parentOf(x))); <span class="comment">// R节点左旋操作</span>
            }
        }
    }
    root.<span class="built_in">color</span> = BLACK; <span class="comment">// 根节点是黑色节点</span>
}
</code></pre><p>fixAfterInsertion方法的代码跟之前分析的冲突解决方案一模一样。</p>
<h3 id="get操作">get操作</h3><p>红黑树的get操作相比add操作简单不少，只需要比较关键字即可，要查找的关键字比节点关键字要小的话找左节点，否则找右节点，一直递归操作，直到找到或找不到。代码如下：</p>
<pre><code><span class="keyword">final</span> Entry&lt;K,V&gt; getEntry(<span class="keyword">Object</span> <span class="variable">key</span>) {
    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)
        <span class="keyword">return</span> getEntryUsingComparator(<span class="variable">key</span>);
    <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    @SuppressWarnings(<span class="string">"unchecked"</span>)
        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) <span class="variable">key</span>;
    Entry&lt;K,V&gt; p = root;
    <span class="keyword">while</span> (p != <span class="keyword">null</span>) {
        <span class="built_in">int</span> cmp = k.compareTo(p.<span class="variable">key</span>); <span class="comment">// 得到比较值</span>
        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="comment">// 小的话找左节点</span>
            p = p.left;
        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="comment">// 大的话找右节点</span>
            p = p.right;
        <span class="keyword">else</span>
            <span class="keyword">return</span> p;
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</code></pre><h3 id="remove操作">remove操作</h3><p>红黑树的删除节点跟添加节点一样，比较复杂，删除节点也会让树不符合红黑树的特性，也需要解决这些冲突。</p>
<p>删除操作分为2个步骤：</p>
<ol>
<li>将红黑树当作一颗二叉查找树，将节点删除</li>
<li>通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树</li>
</ol>
<p>步骤1的删除操作可分为几种情况：</p>
<ol>
<li>删除节点没有儿子：直接删除该节点</li>
<li>删除节点有1个儿子：删除该节点，并用该节点的儿子节点顶替它的位置</li>
<li>删除节点有2个儿子：可以转成成删除节点只有1个儿子的情况，跟二叉查找树一样，找出节点的右子树的最小元素(或者左子树的最大元素，这种节点称为后继节点)，并把它的值转移到删除节点，然后删除这个后继节点。这个后继节点最多只有1个子节点(如果有2个子节点，说明还能找出右子树更小的值)，所以这样删除2个儿子的节点就演变成了删除没有儿子的节点和删除只有1个儿子的节点的情况</li>
</ol>
<p>删除节点之后要考虑的问题就是红黑树失衡的调整问题。</p>
<p>步骤2遇到的调整问题只有2种情况：</p>
<ol>
<li>删除节点没有儿子节点</li>
<li>删除节点只有1个儿子节点</li>
</ol>
<p>删除节点没有儿子节点的话，直接把节点删除即可。如果节点是黑色节点，需要进行平衡性调整，否则，不用调整平衡性。这里的平衡性调整跟删除只有1个儿子节点一样，删除只有1个儿子的调整会先把节点删除，然后儿子节点顶上来，顶上来之后再进行平衡性调整。而删除没有儿子节点的节点的话，先进行调整，调整之后再把这个节点删除。他们的调整策略是一样的，只不过没有儿子节点的情况下先进行调整，然后再删除节点，而有儿子节点的情况下，先把节点删除，删除之后儿子节点顶上来，然后再做平衡性调整。</p>
<p>删除节点只有1个儿子节点还分几种情况：</p>
<ol>
<li>如果被删除的节点是红色节点，那说明它的父节点是黑色节点，儿子节点也是黑色节点，那么删除这个节点就不会影响红黑树的属性，直接使用它的黑色子节点代替它即可</li>
<li>如果被删除的节点是黑色节点，而它的儿子节点是红色节点。删除这个黑色节点之后，它的红色儿子节点顶替之后，会破坏性质5，只需要把儿子节点重绘为黑色节点即可，这样原先通过黑色删除节点的所有路径被现在的重绘后的儿子节点所代替</li>
<li>如果被删除的节点是黑色节点，而它的儿子节点也是黑色节点。这是一种复杂的情况，因为路径路过被删除节点的黑色节点路径少了1个，导致违反了性质5，所以需要对红黑树进行平衡调整。可分为以下几种情况进行调整：</li>
</ol>
<p>以N为删除节点的儿子节点(删除之后，处于新的位置上)，它的兄弟节点为S，它们的父节点为P，Sl和Sr为S节点的左右子节点为例，进行讲解，其中<strong>N是父节点P的左子节点</strong>，如果N是父节点P的右子节点，做对称处理。</p>
<p>3.1：N是新的根节点。这种情况下不用做任何处理，因为原先的节点也是一个根节点，相当于所有的路径都需要经过这个根节点，删除之后没有什么影响，而且新根也是黑色节点，符合所有特性，不需要进行调整</p>
<p>3.2: S节点是红色节点，那么P节点，Sl，Sr节点是黑色节点。在这种情况下，对P节点进行左选操作并且交换P和S的颜色。完成这2个操作之后，所有路径上的黑色节点没有变化，但是N节点有了一个黑色兄弟节点Sl和一个红色的父亲节点P，左子树删除节点后还有存在着少1个黑色节点路径的问题。接下来按照N节点新的位置(兄弟节点S是个黑色节点，父节点P是个红色节点)进行3.4、3.5或3.6情况处理<br><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap10.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>3.3：N的父亲节点P、兄弟节点S，还有S的两个子节点Sl，Sr均为黑色节点。在这种情况下，重绘S为红色。重绘之后路过S节点这边的路径跟N节点一样也少了一个黑色节点，但是出现了另外一个问题：不经过P节点的路径还是少了一个黑色节点。 接下来，要调整以P作为N递归调整树</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap11.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>3.4：S和S的儿子节点Sl、Sr为黑色节点，但是N的父亲节点P为红色节点。在这种情况下，交换N的兄弟S与父亲P的颜色，颜色交换之后左子树多了1个黑色节点路径，刚好填补了左子树删除节点的少一个黑色节点路径的问题，而右子树的黑色路径没有改变，解决平衡问题</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap12.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>3.5：S是黑色节点，S的左儿子节点Sl是红色，S的右儿子节点Sr是黑色节点。在这种情况下，在S上做右旋操作交换S和它新父亲的颜色。操作之后，左子树的黑色节点路径和右子树的黑色节点路径没有改变。但是现在N节点有了一个黑色的兄弟节点，黑色的兄弟节点有个红色的右儿子节点，满足了3.6的情况，按照3.6处理</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap13.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>3.6：S是黑色节点，S的右儿子节点Sr为红色节点，S的左儿子Sl是黑色节点，P是红色或黑色节点。在这种情况下，N的父亲P做左旋操作，交换N父亲P和S的颜色，S的右子节点Sr变成黑色。这样操作以后，左子树的黑色路径+1，补了删除节点的黑色路径，右子树黑色路径不变，解决平衡问题</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap14.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>了解了删除节点之后的平衡性调整之后，我们回过头来看本文一开始的例子进行节点删除的操作过程：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/treemap15.jpg?imageView2/1/w/10000/h/10000/q/100|watermark/2/text/ZmFuZ2ppYW4wNDIzLmdpdGh1Yi5pbw==/font/5a6L5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>TreeMap删除方法如下：</p>
<pre><code><span class="keyword">private</span> <span class="literal">void</span> deleteEntry(Entry&lt;K,V&gt; p) {
    modCount++;
    size--; <span class="comment">// 节点个数 -1</span>

    <span class="keyword">if</span> (p<span class="built_in">.</span>left != <span class="built_in">null</span> <span class="subst">&amp;&amp;</span> p<span class="built_in">.</span>right != <span class="built_in">null</span>) { <span class="comment">// 如果要删除的节点有2个子节点，去找后继节点</span>
        Entry&lt;K,V&gt; s = success<span class="subst">or</span>(p); <span class="comment">// 找出后继节点</span>
        p<span class="built_in">.</span>key = s<span class="built_in">.</span>key; <span class="comment">// 后继节点的关键字赋值给删除节点</span>
        p<span class="built_in">.</span>value = s<span class="built_in">.</span>value; <span class="comment">// 后继节点的值赋值给删除节点</span>
        p = s; <span class="comment">// 改为删除后继节点</span>
    }

    Entry&lt;K,V&gt; replacement = (p<span class="built_in">.</span>left != <span class="built_in">null</span> ? p<span class="built_in">.</span>left : p<span class="built_in">.</span>right); <span class="comment">// 找出替代节点，左子树存在的话使用左子树，否则使用右子树。这个替代节点就是被删除节点的左子节点或右子节点</span>

    <span class="keyword">if</span> (replacement != <span class="built_in">null</span>) { <span class="comment">// 替代节点如果存在的话</span>
        replacement<span class="built_in">.</span><span class="keyword">parent</span> = p<span class="built_in">.</span><span class="keyword">parent</span>; <span class="comment">// 删除要删除的节点</span>
        <span class="comment">// 有子节点的删除节点先删除节点，然后再做平衡性调整</span>
        <span class="keyword">if</span> (p<span class="built_in">.</span><span class="keyword">parent</span> == <span class="built_in">null</span>) <span class="comment">// 如果被删除节点的父节点为空，说明被删除节点是根节点</span>
            root = replacement; <span class="comment">// 用替代节点替代根节点</span>
        <span class="keyword">else</span> <span class="keyword">if</span> (p == p<span class="built_in">.</span><span class="keyword">parent</span><span class="built_in">.</span>left)
            p<span class="built_in">.</span><span class="keyword">parent</span><span class="built_in">.</span>left  = replacement; <span class="comment">// 用替代节点替代原先被删除的节点</span>
        <span class="keyword">else</span>
            p<span class="built_in">.</span><span class="keyword">parent</span><span class="built_in">.</span>right = replacement; <span class="comment">// 用替代节点替代原先被删除的节点</span>

        p<span class="built_in">.</span>left = p<span class="built_in">.</span>right = p<span class="built_in">.</span><span class="keyword">parent</span> = <span class="built_in">null</span>;

        <span class="keyword">if</span> (p<span class="built_in">.</span>col<span class="subst">or</span> == BLACK) <span class="comment">// 被删除节点如果是黑色节点，需要进行平衡性调整</span>
            fixAfterDeletion(replacement);
    } <span class="keyword">else</span> <span class="keyword">if</span> (p<span class="built_in">.</span><span class="keyword">parent</span> == <span class="built_in">null</span>) { <span class="comment">// 如果被删除节点的父节点为空，说明被删除节点是根节点</span>
        root = <span class="built_in">null</span>; <span class="comment">// 根节点的删除直接把根节点置空即可</span>
    } <span class="keyword">else</span> { <span class="comment">//   如果要删除的节点没有子节点</span>
        <span class="keyword">if</span> (p<span class="built_in">.</span>col<span class="subst">or</span> == BLACK) <span class="comment">// 如果要删除的节点是个黑色节点，需要进行平衡性调整</span>
            fixAfterDeletion(p); <span class="comment">// 调整平衡性，没有子节点的删除节点先进行平衡性调整</span>

        <span class="keyword">if</span> (p<span class="built_in">.</span><span class="keyword">parent</span> != <span class="built_in">null</span>) { <span class="comment">// 没有子节点的删除节点平衡性调整完毕之后再进行节点删除</span>
            <span class="keyword">if</span> (p == p<span class="built_in">.</span><span class="keyword">parent</span><span class="built_in">.</span>left)
                p<span class="built_in">.</span><span class="keyword">parent</span><span class="built_in">.</span>left = <span class="built_in">null</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (p == p<span class="built_in">.</span><span class="keyword">parent</span><span class="built_in">.</span>right)
                p<span class="built_in">.</span><span class="keyword">parent</span><span class="built_in">.</span>right = <span class="built_in">null</span>;
            p<span class="built_in">.</span><span class="keyword">parent</span> = <span class="built_in">null</span>;
        }
    }
}

<span class="comment">// 删除节点后的平衡性调整，对应之前分析的节点昵称，N、S、P、Sl、Sr</span>
<span class="keyword">private</span> <span class="literal">void</span> fixAfterDeletion(Entry&lt;K,V&gt; x) {
    <span class="keyword">while</span> (x != root <span class="subst">&amp;&amp;</span> colorOf(x) == BLACK) { <span class="comment">// N节点是黑色节点并且不是根节点就一直循环</span>
        <span class="keyword">if</span> (x == leftOf(parentOf(x))) { <span class="comment">// 如果N是P的左子节点</span>
            Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); <span class="comment">// sib就是N节点的兄弟节点S</span>

            <span class="keyword">if</span> (colorOf(sib) == RED) { <span class="comment">// 如果S节点是红色节点，满足删除冲突3.2，对P节点进行左旋操作并交换P和S的颜色</span>
                <span class="comment">// 交换P和S的颜色，S原先为红色，P原先为黑色(2个红色节点不能相连)</span>
                setCol<span class="subst">or</span>(sib, BLACK); <span class="comment">// S节点从红色变成黑色</span>
                setCol<span class="subst">or</span>(parentOf(x), RED); <span class="comment">// P节点从黑色变成红色</span>
                rotateLeft(parentOf(x)); <span class="comment">// 删除冲突3.2中P节点进行左旋</span>
                sib = rightOf(parentOf(x)); <span class="comment">// 左旋之后N节点有了一个黑色的兄弟节点和红色的父亲节点，S节点重新赋值成N节点现在的兄弟节点。接下来按照删除冲突3.4、3.5、3.6处理</span>
            }

            <span class="comment">// 执行到这里S节点一定是黑色节点，如果是红色节点，会按照冲突3.2交换成黑色节点</span>
            <span class="comment">// 如果S节点的左右子节点Sl、Sr均为黑色节点并且S节点也为黑色节点</span>
            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK <span class="subst">&amp;&amp;</span>
                colorOf(rightOf(sib)) == BLACK) {
                <span class="comment">// 按照删除冲突3.3和3.4进行处理</span>
                <span class="comment">// 如果是冲突3.3，说明P节点也是黑色节点</span>
                <span class="comment">// 如果是冲突3.4，说明P节点是红色节点，P节点和S节点需要交换颜色</span>
                <span class="comment">// 3.3和3.4冲突的处理结果S节点都为红色节点，但是3.4冲突处理完毕之后直接结束，而3.3冲突处理完毕之后继续调整</span>
                setCol<span class="subst">or</span>(sib, RED); <span class="comment">// S节点变成红色节点，如果是3.4冲突需要交换颜色，N节点的颜色交换在跳出循环进行</span>
                x = parentOf(x); <span class="comment">// N节点重新赋值成N节点的父节点P之后继续递归处理</span>
            } <span class="keyword">else</span> { <span class="comment">// S节点的2个子节点Sl，Sr中存在红色节点</span>
                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) { <span class="comment">// 如果S节点的右子节点Sr为黑色节点，Sl为红色节点[Sl如果为黑色节点的话就在上一个if逻辑里处理了]，满足删除冲突3.5</span>
                    <span class="comment">// 删除冲突3.5，对S节点做右旋操作，交换S和Sl的颜色，S变成红色节点，Sl变成黑色节点</span>
                    setCol<span class="subst">or</span>(leftOf(sib), BLACK); <span class="comment">// Sl节点变成黑色节点</span>
                    setCol<span class="subst">or</span>(sib, RED); <span class="comment">// S节点变成红色节点</span>
                    rotateRight(sib); <span class="comment">// S节点进行右旋操作</span>
                    sib = rightOf(parentOf(x)); <span class="comment">// S节点赋值现在N节点的兄弟节点</span>
                }
                <span class="comment">// 删除冲突3.5处理之后变成了删除冲突3.6或者一开始就是删除冲突3.6</span>
                <span class="comment">// 删除冲突3.6，P节点做左旋操作，P节点和S接口交换颜色，Sr节点变成黑色</span>
                setCol<span class="subst">or</span>(sib, colorOf(parentOf(x))); <span class="comment">// S节点颜色变成P节点颜色，红色</span>
                setCol<span class="subst">or</span>(parentOf(x), BLACK); <span class="comment">// P节点变成S节点颜色，也就是黑色</span>
                setCol<span class="subst">or</span>(rightOf(sib), BLACK); <span class="comment">// Sr节点变成黑色</span>
                rotateLeft(parentOf(x)); <span class="comment">// P节点做左旋操作</span>
                x = root; <span class="comment">// 准备跳出循环</span>
            }
        } <span class="keyword">else</span> { <span class="comment">// 如果N是P的右子节点，处理过程跟N是P的左子节点一样，左右对换即可</span>
            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));

            <span class="keyword">if</span> (colorOf(sib) == RED) {
                setCol<span class="subst">or</span>(sib, BLACK);
                setCol<span class="subst">or</span>(parentOf(x), RED);
                rotateRight(parentOf(x));
                sib = leftOf(parentOf(x));
            }

            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK <span class="subst">&amp;&amp;</span>
                colorOf(leftOf(sib)) == BLACK) {
                setCol<span class="subst">or</span>(sib, RED);
                x = parentOf(x);
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) {
                    setCol<span class="subst">or</span>(rightOf(sib), BLACK);
                    setCol<span class="subst">or</span>(sib, RED);
                    rotateLeft(sib);
                    sib = leftOf(parentOf(x));
                }
                setCol<span class="subst">or</span>(sib, colorOf(parentOf(x)));
                setCol<span class="subst">or</span>(parentOf(x), BLACK);
                setCol<span class="subst">or</span>(leftOf(sib), BLACK);
                rotateRight(parentOf(x));
                x = root;
            }
        }
    }

    setCol<span class="subst">or</span>(x, BLACK); <span class="comment">// 删除冲突3.4循环调出来之后N节点颜色设置为黑色 或者 删除节点只有1个红色子节点的时候，将顶上来的红色节点设置为黑色</span>
}
</code></pre><h2 id="参考资料">参考资料</h2><p><a href="http://dongxicheng.org/structure/red-black-tree/" target="_blank" rel="external">http://dongxicheng.org/structure/red-black-tree/</a></p>
<p><a href="http://blog.csdn.net/chenssy/article/details/26668941" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/26668941</a></p>
<p><a href="http://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91</a></p>
<p><a href="http://www.cnblogs.com/fanzhidongyzby/p/3187912.html" target="_blank" rel="external">http://www.cnblogs.com/fanzhidongyzby/p/3187912.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>TreeMap是jdk中基于红黑树的一种map实现。HashMap底层是使用链表法解决冲突的哈希表，LinkedHashMap继承自HashMap，内部同样也是使用链表法解决冲突的哈希表，但是额外添加了一个双向链表用于处理元素的插入顺序或访问访问。</p>
<p>既然TreeMap底层使用的是红黑树，首先先来简单了解一下红黑树的定义。</p>
<p>红黑树是一棵平衡二叉查找树，同时还需要满足以下5个规则：</p>
<ol>
<li>每个节点只能是红色或者黑点</li>
<li>根节点是黑点</li>
<li>叶子节点(Nil节点，空节点)是黑色节点</li>
<li>如果一个节点是红色节点，那么它的两个子节点必须是黑色节点(一条路径上不能出现相邻的两个红色节点)</li>
<li>从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点</li>
</ol>
<p>红黑树的这些特性决定了它的查询、插入、删除操作的时间复杂度均为O(log n)。</p>]]>
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="map" scheme="http://fangjian0423.github.io/tags/map/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk ArrayDeque工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/04/03/jdk_arraydeque/"/>
    <id>http://fangjian0423.github.io/2016/04/03/jdk_arraydeque/</id>
    <published>2016-04-02T16:43:59.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>ArrayDeque双向队列是jdk中列表的一种实现，支持元素在头和尾这两端进行插入和删除操作。</p>
<p>Deque接口(双向队列)的两个主要实现类是ArrayDeque和LinkedList。</p>
<p>其中ArrayDeque底层使用循环数组实现双向队列，而LinkedList是使用链接实现，之前在<a href="http://fangjian0423.github.io/2016/03/27/jdk_linkedlist/">jdk LinkedList工作原理分析</a>这篇文章中，已经分析过了LinkedList的实现原理，本文分析ArrayDeque的实现原理。</p>
<a id="more"></a>
<h2 id="一个ArrayDeque例子">一个ArrayDeque例子</h2><p>一段ArrayDeque代码：</p>
<pre><code>ArrayDeque&lt;<span class="keyword">String</span>&gt; arrayDeque = <span class="keyword">new</span> ArrayDeque&lt;<span class="keyword">String</span>&gt;(<span class="number">4</span>);
arrayDeque.<span class="built_in">add</span>(<span class="string">"1"</span>);
arrayDeque.<span class="built_in">add</span>(<span class="string">"2"</span>);
arrayDeque.<span class="built_in">add</span>(<span class="string">"3"</span>);
arrayDeque.addFirst(<span class="string">"0.5"</span>);
arrayDeque.<span class="built_in">add</span>(<span class="string">"4"</span>);
</code></pre><p>ArrayDeque内部使用的循环数组的容量，当首次进行初始化的时候，最小容量为8，如果超过8，扩大成2的幂。</p>
<pre><code><span class="comment">// 调用带有容量参数的构造函数后，数组初始化过程</span>
<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>{
    <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY; <span class="comment">// 最小容量为8</span>
    <span class="keyword">if</span> (numElements &gt;= initialCapacity) { <span class="comment">// 如果要分配的容量大于等于8，扩大成2的幂；否则使用最小容量8</span>
        initialCapacity = numElements;
        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);
        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);
        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);
        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);
        initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);
        initialCapacity++;

        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)
            initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;
    }
    elements = <span class="keyword">new</span> Object[initialCapacity]; <span class="comment">// 构造数组</span>
}
</code></pre><p>上面例子构造容量为4的数组，但是由于最小容量为8，所以构造的数组的容量是8。</p>
<p>执行过程如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/arraydeque01.jpg" alt=""></p>
<h2 id="ArrayDeque原理分析">ArrayDeque原理分析</h2><p>ArrayDeque使用的是循环数组，内部有3个属性，分别是：</p>
<pre><code><span class="built_in">Object</span>[] elements; <span class="comment">// 数组</span>
<span class="built_in">int</span> head; <span class="comment">// 头索引</span>
<span class="built_in">int</span> tail; <span class="comment">// 尾索引</span>
</code></pre><h3 id="add操作">add操作</h3><p>上面例子使用的add方法，其实内部使用了addLast方法，addLast也就添加数据到双向队列尾端：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>{
    <span class="keyword">if</span> (e == null)
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    elements[tail] = e; <span class="comment">// 根据尾索引，添加到尾端</span>
    <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head) <span class="comment">// 尾索引+1，如果尾索引和头索引重复了，说明数组满了，进行扩容</span>
        doubleCapacity();
}
</code></pre><p>addFirst方法跟addLast方法相反，添加数据到双向队列头端：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>{
    <span class="keyword">if</span> (e == null)
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e; <span class="comment">// 根据头索引，添加到头端，头索引-1</span>
    <span class="keyword">if</span> (head == tail) <span class="comment">// 如果头索引和尾索引重复了，说明数组满了，进行扩容</span>
        doubleCapacity();            
}
</code></pre><h3 id="remove操作">remove操作</h3><p>remove操作分别removeFirst和removeLast，removeLast代码如下：</p>
<pre><code>public E removeLast() {
    E x = pollLast(); // 调用pollLast方法
    <span class="keyword">if</span> (x == null)
        throw new <span class="type">NoSuchElementException</span>();
    <span class="keyword">return</span> x;
}

public E pollLast() {
    <span class="type">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>); // 尾索引 -<span class="number">1</span>
    @<span class="type">SuppressWarnings</span>(<span class="string">"unchecked"</span>)
    E <span class="literal">result</span> = (E) elements[t]; // 根据尾索引，得到尾元素
    <span class="keyword">if</span> (<span class="literal">result</span> == null)
        <span class="keyword">return</span> null;
    elements[t] = null; // 尾元素置空
    tail = t;
    <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre><p>removeFirst方法原理一样，remove头元素。 头索引 +1</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/arraydeque02.jpg" alt=""></p>
<h3 id="扩容">扩容</h3><p>ArrayDeque的扩容会把数组容量扩大2倍，同时还会重置头索引和尾索引，头索引置为0，尾索引置为原容量的值。</p>
<p>比如容量为8，扩容为16，头索引变成0，尾索引变成8。</p>
<p>扩容代码如下：</p>
<pre><code><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>{
    assert head == tail;
    <span class="keyword">int</span> p = head;
    <span class="keyword">int</span> n = elements.length;
    <span class="keyword">int</span> r = n - p;
    <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;
    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Sorry, deque too big"</span>);
    Object[] a = <span class="keyword">new</span> Object[newCapacity];
    System.arraycopy(elements, p, a, <span class="number">0</span>, r);
    System.arraycopy(elements, <span class="number">0</span>, a, r, p);
    elements = a;
    head = <span class="number">0</span>;  <span class="comment">// 头索引重置</span>
    tail = n;  <span class="comment">// 尾索引重置</span>
}
</code></pre><p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/arraydeque03.jpg" alt=""></p>
<h2 id="其他">其他</h2><p>Deque接口同时还附带了Stack的功能。</p>
<pre><code>ArrayDeque&lt;<span class="built_in">String</span>&gt; <span class="built_in">stack</span> = <span class="literal">new</span> ArrayDeque&lt;<span class="built_in">String</span>&gt;(<span class="number">4</span>);
<span class="built_in">stack</span><span class="built_in">.</span>push(<span class="string">"1"</span>);
<span class="built_in">stack</span><span class="built_in">.</span>push(<span class="string">"2"</span>);
<span class="built_in">stack</span><span class="built_in">.</span>push(<span class="string">"3"</span>);
<span class="built_in">String</span> pop = <span class="built_in">stack</span><span class="built_in">.</span>pop(); <span class="comment">// 3</span>
</code></pre><p>push方法内部调用addFirst方法，pop方法内部调用removeFirst方法。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/arraydeque04.jpg" alt=""></p>
<h2 id="注意点">注意点</h2><ol>
<li>ArrayDeque是一个使用循环数组实现的双向队列，LinkedList也是一个双向队列，不过它的底层实现是使用链表</li>
<li>ArrayDeque的扩容会把数组容量扩大2倍，同时还会重置头索引和尾索引</li>
<li>Deque双向队列接口同时也实现了Stack接口，可以把Deque当成Stack使用，它的速度比java.util.Stack要快，因为Stack底层操作数据会加锁，而Deque不会加锁</li>
<li>ArrayDeque不是一个线程安全的类</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>ArrayDeque双向队列是jdk中列表的一种实现，支持元素在头和尾这两端进行插入和删除操作。</p>
<p>Deque接口(双向队列)的两个主要实现类是ArrayDeque和LinkedList。</p>
<p>其中ArrayDeque底层使用循环数组实现双向队列，而LinkedList是使用链接实现，之前在<a href="http://fangjian0423.github.io/2016/03/27/jdk_linkedlist/">jdk LinkedList工作原理分析</a>这篇文章中，已经分析过了LinkedList的实现原理，本文分析ArrayDeque的实现原理。</p>]]>
    
    </summary>
    
      <category term="collection" scheme="http://fangjian0423.github.io/tags/collection/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk HashSet, LinkedHashSet工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/03/30/jdk_hashset_linkedhashset/"/>
    <id>http://fangjian0423.github.io/2016/03/30/jdk_hashset_linkedhashset/</id>
    <published>2016-03-29T16:46:33.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>Set是一个没有包括重复数据的集合，跟List一样，他们都继承自Collection。</p>
<p>Java中的Set接口最主要的实现类就是HashSet和LinkedHashSet。</p>
<a id="more"></a>
<h2 id="HashSet原理分析">HashSet原理分析</h2><p>首先看下HashSet的属性。</p>
<p>HashSet内部有个HashMap属性和一个对象属性：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">HashMap</span>&lt;E,<span class="keyword">Object</span>&gt; <span class="built_in">map</span>;

<span class="comment">// HashSet内部使用HashMap进行处理，由于Set只需要键值对中的键，而不需要值，所有的值都用这个对象</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span> PRESENT = <span class="keyword">new</span> <span class="keyword">Object</span>();
</code></pre><p>HashSet的构造函数中也提供了HashMap的capacity，loadFactor这些参数。</p>
<h3 id="add方法">add方法</h3><p>调用HashMap的put操作完成Set的add操作。</p>
<pre><code><span class="keyword">public</span> <span class="built_in">boolean</span> <span class="built_in">add</span>(E e) {
    <span class="keyword">return</span> <span class="built_in">map</span>.put(e, PRESENT)==<span class="keyword">null</span>;  <span class="comment">// HashMap put成功返回true，否则false</span>
}
</code></pre><p>HashMap相关的put操作在之前的博客中已经介绍过了，这里就不分析了。</p>
<h3 id="boolean_remove(Object_o)">boolean remove(Object o)</h3><p>调用HashMap的remove操作完成。</p>
<pre><code><span class="keyword">public</span> <span class="built_in">boolean</span> remove(<span class="keyword">Object</span> o) {
    <span class="keyword">return</span> <span class="built_in">map</span>.remove(o)==PRESENT; <span class="comment">// 对应的节点移除成功返回true，否则false</span>
}
</code></pre><h3 id="一个HashSet例子">一个HashSet例子</h3><pre><code>Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;<span class="keyword">String</span>&gt;(<span class="number">5</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"java"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"golang"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"python"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"ruby"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"scala"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"c"</span>);

<span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">str</span> : <span class="built_in">set</span>) {
    System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);
}
</code></pre><p>这个例子中set中的HashMap内部结构如下图所示：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/hashmap03.jpg" alt=""></p>
<h3 id="HashSet总结">HashSet总结</h3><ol>
<li>HashSet内部使用HashMap，HashSet集合内部所有的操作基本上都是基于HashMap完成的</li>
<li>HashSet中的元素是无序的，这是因为它内部使用HashMap进行存储，而HashMap添加键值对的时候是根据hash函数得到数组的下标的</li>
</ol>
<h2 id="LinkedHashSet原理分析">LinkedHashSet原理分析</h2><p>LinkedHashSet继承自HashSet，它的构造函数会调用父类HashSet的构造函数：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>{
    <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);
}

HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) {
    <span class="comment">// map使用LinkedHashMap构造，LinkedHashMap是HashMap的子类，accessOrder为false，即使用插入顺序</span>
    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);
}
</code></pre><h3 id="一个LinkedHashSet例子">一个LinkedHashSet例子</h3><pre><code>Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> LinkedHashSet&lt;<span class="keyword">String</span>&gt;(<span class="number">5</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"java"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"golang"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"python"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"ruby"</span>);
<span class="built_in">set</span>.<span class="built_in">add</span>(<span class="string">"scala"</span>);
<span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">str</span> : <span class="built_in">set</span>) {
    System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);
}
</code></pre><p>这个例子中set中的LinkedHashMap内部结构如下图所示：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/linkedhashmap02.jpg" alt=""></p>
<h3 id="LinkedHashSet总结">LinkedHashSet总结</h3><ol>
<li>LinkedHashSet继自HashSet，但是内部的map是使用LinkedHashMap构造的，并且accessOrder为false，使用查询顺序。所以LinkedHashSet遍历的顺序就是插入顺序。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Set是一个没有包括重复数据的集合，跟List一样，他们都继承自Collection。</p>
<p>Java中的Set接口最主要的实现类就是HashSet和LinkedHashSet。</p>]]>
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="set" scheme="http://fangjian0423.github.io/tags/set/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk LinkedHashMap工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/03/29/jdk_linkedhashmap/"/>
    <id>http://fangjian0423.github.io/2016/03/29/jdk_linkedhashmap/</id>
    <published>2016-03-29T11:23:23.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>LinkedHashMap是一种会记录插入顺序的Map，内部维护着一个accessOrder属性，用于表示map数据的迭代顺序是基于访问顺序还是插入顺序。</p>
<a id="more"></a>
<h2 id="LinkedHashMap原理分析">LinkedHashMap原理分析</h2><p>首先是LinkedHashMap的定义：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;
    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;
        <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>
</code></pre><p>LinkedHashMap继承HashMap，实现Map接口，所以它的结构跟HashMap是一样的，使用链表法解决哈希冲突的哈希表，基本操作跟HashMap也是一样的，就是多了一点额外的步骤用于处理链表。</p>
<p>LinkedHashMap有个内部类Entry，这个Entry就是链表中的节点，继承自HashMap.Node，多出了2个属性before和after，所以LinkedHashMap内部链表的节点是双向的，代码如下：</p>
<pre><code>static <span class="class"><span class="keyword">class</span> <span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">HashMap</span>.<span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> {</span>
    <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; before, after;
    <span class="type">Entry</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> value, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next) {
        <span class="keyword">super</span>(hash, key, value, next);
    }
}
</code></pre><p>另外LinkedHashMap还有两个重要的属性head，tail，这2个属性用于存储插入的节点，形成一个双向链表：</p>
<pre><code><span class="comment">// 首节点</span>
<span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;

<span class="comment">// 尾节点</span>
<span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;
</code></pre><p>跟HashMap一样，下面这个例子对应的LinkedHashMap结构图示如下所示，accessOrder为false，使用插入顺序：</p>
<pre><code>Map&lt;String, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> LinkedHashMap&lt;String, Integer&gt;(<span class="number">5</span>);
<span class="built_in">map</span>.put(<span class="string">"java"</span>, <span class="number">1</span>);
<span class="built_in">map</span>.put(<span class="string">"golang"</span>, <span class="number">2</span>);
<span class="built_in">map</span>.put(<span class="string">"python"</span>, <span class="number">3</span>);
<span class="built_in">map</span>.put(<span class="string">"ruby"</span>, <span class="number">4</span>);
<span class="built_in">map</span>.put(<span class="string">"scala"</span>, <span class="number">5</span>);
</code></pre><p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/linkedhashmap02.jpg" alt=""></p>
<h3 id="put操作">put操作</h3><p>LinkedHashMap没有覆盖HashMap的put方法，所以put操作跟HashMap是一样的。但是它覆盖了newNode方法，也就是说构造新节点的时候，LinkedHashMap跟HashMap是不一样的：</p>
<pre><code><span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; newNode(int hash, K key, V value, <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; e) {
    // 使用Entry双向链表构造节点，而不是HashMap的<span class="keyword">Node</span><span class="identifier"></span><span class="title">单向链表
    LinkedHashMap</span>.Entry<span class="tag">&lt;K,V&gt;</span> p =
        new LinkedHashMap.Entry<span class="tag">&lt;K,V&gt;</span>(hash, key, value, e);
    linkNodeLast(p); // 更新双向链表，这一操作在HashMap里面是没有的
    return p;
}
</code></pre><p>另外，LinkedHashMap重写了afterNodeInsertion这个钩子方法，在put一个关键字不存在的节点之后会调用这个方法：</p>
<pre><code><span class="keyword">void</span> afterNodeInsertion(<span class="built_in">boolean</span> evict) { <span class="comment">// possibly remove eldest</span>
    LinkedHashMap.Entry&lt;K,V&gt; first;
    <span class="comment">// removeEldestEntry方法LinkedHashMap永远返回false，一些使用缓存策略的Map会覆盖这个方法，比如jackson的LRUMap，会移除最老的节点，也就是首节点</span>
    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) {
        K <span class="variable">key</span> = first.<span class="variable">key</span>;
        removeNode(hash(<span class="variable">key</span>), <span class="variable">key</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);
    }
}
</code></pre><p>put操作如果关键字已经存在，会调用afterNodeAccess这个钩子方法：</p>
<pre><code><span class="label">void</span> afterNodeAccess(Node&lt;K,V&gt; e) { // <span class="keyword">move </span>node to last
    LinkedHashMap.Entry&lt;K,V&gt; last<span class="comment">;</span>
    <span class="preprocessor">if</span> (accessOrder &amp;&amp; (last = tail) != e) { // 如果使用访问顺序并且访问的不是尾节点
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, <span class="keyword">b </span>= p.<span class="keyword">before, </span>a = p.after<span class="comment">;</span>
        p.after = null<span class="comment">;</span>
        <span class="preprocessor">if</span> (<span class="keyword">b </span>== null)
            head = a<span class="comment">;</span>
        <span class="preprocessor">else</span>
            <span class="keyword">b.after </span>= a<span class="comment">;</span>
        <span class="preprocessor">if</span> (a != null)
            a.<span class="keyword">before </span>= <span class="keyword">b;
</span>        <span class="preprocessor">else</span>
            last = <span class="keyword">b;
</span>        <span class="preprocessor">if</span> (last == null)
            head = p<span class="comment">;</span>
        <span class="preprocessor">else</span> {
            p.<span class="keyword">before </span>= last<span class="comment">;</span>
            last.after = p<span class="comment">;</span>
        }
        tail = p<span class="comment">;</span>
        ++modCount<span class="comment">;</span>
    }
}
</code></pre><h3 id="get操作">get操作</h3><p>LinkedHashMap复写了get方法：</p>
<pre><code><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="variable">key</span>) {
    Node&lt;K,V&gt; e;
    <span class="keyword">if</span> ((e = getNode(hash(<span class="variable">key</span>), <span class="variable">key</span>)) == <span class="keyword">null</span>)
        <span class="keyword">return</span> <span class="keyword">null</span>;
    <span class="keyword">if</span> (accessOrder) <span class="comment">// 使用访问顺序的话，调用afterNodeAccess方法</span>
        afterNodeAccess(e);
    <span class="keyword">return</span> e.value;
}
</code></pre><h3 id="remove操作">remove操作</h3><p>LinkedHashMap的remove方法没有复写HashMap的remove方法，但是同样实现了afterNodeRemoval这个钩子方法：</p>
<pre><code>// 更新双向链表
<span class="label">void</span> afterNodeRemoval(Node&lt;K,V&gt; e) { // unlink
    LinkedHashMap.Entry&lt;K,V&gt; p =
        (LinkedHashMap.Entry&lt;K,V&gt;)e, <span class="keyword">b </span>= p.<span class="keyword">before, </span>a = p.after<span class="comment">;</span>
    p.<span class="keyword">before </span>= p.after = null<span class="comment">;</span>
    <span class="preprocessor">if</span> (<span class="keyword">b </span>== null)
        head = a<span class="comment">;</span>
    <span class="preprocessor">else</span>
        <span class="keyword">b.after </span>= a<span class="comment">;</span>
    <span class="preprocessor">if</span> (a == null)
        tail = <span class="keyword">b;
</span>    <span class="preprocessor">else</span>
        a.<span class="keyword">before </span>= <span class="keyword">b;
</span>}
</code></pre><h3 id="accessOrder属性分析">accessOrder属性分析</h3><p>LinkedHashMap默认情况下，accessOrder属性为false，也就是使用插入顺序，这个插入顺序是根据LinkedHashMap内部的一个双向链表实现的。如果accessOrder为true，也就是使用访问顺序，那么afterNodeAccess这个钩子方法内部的逻辑会被执行，将会修改双向链表的结构，再来看一下这个方法的具体逻辑：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>{ <span class="comment">// move node to last</span>
    LinkedHashMap.Entry&lt;K,V&gt; last;
    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) { <span class="comment">// 使用访问顺序，把节点移动到双向链表的最后面，如果已经在最后面了，不需要进行移动</span>
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        p.after = <span class="keyword">null</span>;
        <span class="keyword">if</span> (b == <span class="keyword">null</span>)
            head = a; <span class="comment">// 特殊情况，处理头节点</span>
        <span class="keyword">else</span>
            b.after = a; <span class="comment">// 节点处理</span>
        <span class="keyword">if</span> (a != <span class="keyword">null</span>)
            a.before = b; <span class="comment">// 节点处理</span>
        <span class="keyword">else</span>
            last = b; <span class="comment">// 特殊情况，处理尾节点</span>
        <span class="keyword">if</span> (last == <span class="keyword">null</span>)
            head = p;
        <span class="keyword">else</span> {
            p.before = last; <span class="comment">// 尾节点处理</span>
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}
</code></pre><p>afterNodeAccess在使用get方法或者put方法遇到关键字已经存在的情况下，会被触发，一个例子如下：</p>
<pre><code>Map&lt;String, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> LinkedHashMap&lt;String, Integer&gt;(<span class="number">5</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);
<span class="built_in">map</span>.put(<span class="string">"java"</span>, <span class="number">1</span>);
<span class="built_in">map</span>.put(<span class="string">"golang"</span>, <span class="number">2</span>);
<span class="built_in">map</span>.put(<span class="string">"python"</span>, <span class="number">3</span>);
<span class="built_in">map</span>.put(<span class="string">"ruby"</span>, <span class="number">4</span>);
<span class="built_in">map</span>.put(<span class="string">"scala"</span>, <span class="number">5</span>);
System.out.println(<span class="built_in">map</span>.get(<span class="string">"ruby"</span>));
</code></pre><p>上面这段代码，LinkedHashMap的accessOrder属性为true，使用访问顺序，最后调用了get方法，触发afterNodeAccess方法，修改双向链表，效果如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/linkedhashmap03.jpg" alt=""></p>
<h2 id="注意点">注意点</h2><p>LinkedHashMap使用访问顺序并且进行遍历的时候，如果使用如下代码，会发生ConcurrentModificationException异常：</p>
<pre><code><span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">str</span> : <span class="built_in">map</span>.keySet()) {
    System.out.<span class="built_in">println</span>(<span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">str</span>));
}
</code></pre><p>不应该这么使用，而是应该直接读取value：</p>
<pre><code><span class="function">for</span>(Integer it <span class="value">: map.<span class="function">values</span>()) {
    System.out.<span class="function">println</span>(it);</span>
}
</code></pre><p>具体可以参考<a href="http://stackoverflow.com/questions/16180568/concurrentmodificationexception-with-linkedhashmap" target="_blank" rel="external">stackoverflow上的这篇帖子</a>。</p>
<h2 id="总结">总结</h2><ol>
<li><p>LinkedHashMap也是一种使用拉链式哈希表的数据结构，除了哈希表，它内部还维护着一个双向链表，用于处理访问顺序和插入顺序的问题</p>
</li>
<li><p>LinkedHashMap继承自HashMap，大多数的方法都是跟HashMap一样的，不过覆盖了一些方法</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>LinkedHashMap是一种会记录插入顺序的Map，内部维护着一个accessOrder属性，用于表示map数据的迭代顺序是基于访问顺序还是插入顺序。</p>]]>
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="map" scheme="http://fangjian0423.github.io/tags/map/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk HashMap工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/03/29/jdk_hashmap/"/>
    <id>http://fangjian0423.github.io/2016/03/29/jdk_hashmap/</id>
    <published>2016-03-28T17:49:58.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>Map是一个映射键和值的对象。类似于Python中的字典。</p>
<p>HashMap为什么会出现呢?</p>
<p>因为数组这种数据结构，虽然遍历简单，但是插入和删除操作复杂，需要移动数组内部的元素；链表这种数据结构，插入和删除操作简单，但是查找复杂，只能一个一个地遍历。</p>
<p>有没有一种新的数据结构，插入数据简单，同时查找也简单？ 这个时候就出现了哈希表这种数据结构。 这是一种折中的方式，插入没链表快，查询没数组快。</p>
<p>wiki上就是这么定义哈希表的：</p>
<p>散列表（Hash table，也叫哈希表），是根据关键字（Key value）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p>
<a id="more"></a>
<p>有几个概念要解释一下：</p>
<ol>
<li>如果有1个关键字为k，它是通过一种函数f(k)得到散列表的地址，然后把值放到这个地址上。这个函数f就称为散列函数，也叫哈希函数。</li>
<li>对于不同的关键字，得到了同一地址，即k1 != k2，但是f(k1) = f(k2)。这种现象称为冲突，</li>
<li>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数</li>
</ol>
<p>散列函数有好几种实现，分别有直接定址法、随机数法、除留余数法等，在<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="external">wiki散列表</a>上都有介绍。</p>
<p>散列表的冲突解决方法，也有好几种，有开放定址法、单独链表法、再散列等。</p>
<p>Java中的HashMap采用的冲突解决方法是使用单独链表法，如下图所示：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/hashmap01.png" alt=""></p>
<h2 id="HashMap原理分析">HashMap原理分析</h2><p>HashMap是jdk中Map接口的实现类之一，是一个散列表的实现。</p>
<p>HashMap中的key和value都可以为null，且它的方法都没有synchronized。 其他方法的实现大部分跟HashTable一致。HashTable的相关源码不在这里介绍，基本上跟HashTable一致。</p>
<p>HashMap有个内部静态类Node，这个Node就是为了解决冲突而设计的链表中的节点的概念。它有4个属性，hash表示哈希地址，key表示关键字，value表示值, next表示这个节点的下一个节点，是一个单项链表：</p>
<pre><code>static class <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; implements Map.Entry<span class="tag">&lt;K,V&gt;</span> {
    final int hash;
    final K key;
    V value;
    <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; next;

    <span class="keyword">Node</span><span class="identifier"></span><span class="title">(int</span> hash, K key, V value, <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }

    ...
}
</code></pre><h3 id="在分析HashMap源码之前，先看一个HashMap使用例子">在分析HashMap源码之前，先看一个HashMap使用例子</h3><pre><code>Map&lt;String, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;(<span class="number">5</span>);
<span class="built_in">map</span>.put(<span class="string">"java"</span>, <span class="number">1</span>);
<span class="built_in">map</span>.put(<span class="string">"golang"</span>, <span class="number">2</span>);
<span class="built_in">map</span>.put(<span class="string">"python"</span>, <span class="number">3</span>);
<span class="built_in">map</span>.put(<span class="string">"ruby"</span>, <span class="number">4</span>);
<span class="built_in">map</span>.put(<span class="string">"scala"</span>, <span class="number">5</span>);
</code></pre><p>上面这段代码执行之后会生成下面这张哈希表。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/hashmap05.jpg" alt=""></p>
<p>至于为什么会生成这样的哈希表，会在后面分析源码中讲解。</p>
<h3 id="HashMap的属性">HashMap的属性</h3><p>HashMap的几个重要的属性:</p>
<pre><code><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">// 哈希表数组</span>

<span class="keyword">transient</span> <span class="keyword">int</span> <span class="keyword">size</span>; <span class="comment">// 键值对个数</span>

<span class="keyword">int</span> threshold; <span class="comment">// 阀值。 值 = 容量 * 加载因子。默认值为12(16(默认容量) * 0.75(默认加载因子))。当哈希表中的键值对个数超过该值时，会进行扩容</span>

<span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">// 加载因子，默认是0.75</span>
</code></pre><p>有2个重要的特性影响着HashMap的性能，分别是capacity(容量)和load factor(加载因子)。</p>
<p>其中capacity表示哈希表bucket的数量，HashMap的默认值是16。load factor加载因子表示当一个map填满了达到这个比例之后的bucket时候，和ArrayList一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程也叫做重哈希。默认的load factor为0.75 。</p>
<h3 id="HashMap的操作">HashMap的操作</h3><p>分析一下HashMapput键值对的过程，是如何找到bucket的，遇到哈希冲突的时候是如何使用链表法的。</p>
<h4 id="put操作">put操作</h4><pre><code><span class="keyword">public</span> V put(K <span class="variable">key</span>, V value) {
    <span class="comment">// 第一个参数就是关键字key的哈希值</span>
    <span class="keyword">return</span> putVal(hash(<span class="variable">key</span>), <span class="variable">key</span>, value, <span class="keyword">false</span>, <span class="keyword">true</span>);
}

<span class="keyword">final</span> V putVal(<span class="built_in">int</span> hash, K <span class="variable">key</span>, V value, <span class="built_in">boolean</span> onlyIfAbsent,
               <span class="built_in">boolean</span> evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="built_in">int</span> n, i;
    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)
        n = (tab = resize()).length; <span class="comment">// 哈希表是空的话，重新构建，进行扩容</span>
    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)
        tab[i] = newNode(hash, <span class="variable">key</span>, value, <span class="keyword">null</span>); <span class="comment">// 没有hash冲突的话，直接在对应位置上构造一个新的节点即可</span>
    <span class="keyword">else</span> { <span class="comment">// 如果哈希表当前位置上已经有节点的话，说明有hash冲突</span>
        Node&lt;K,V&gt; e; K k;
        <span class="comment">// 关键字跟哈希表上的首个节点济宁比较</span>
        <span class="keyword">if</span> (p.hash == hash &amp;&amp;
            ((k = p.<span class="variable">key</span>) == <span class="variable">key</span> || (<span class="variable">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="variable">key</span>.equals(k))))
            e = p;
        <span class="comment">// 如果使用的是红黑树，用红黑树的方式进行处理</span>
        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, <span class="variable">key</span>, value);
        <span class="keyword">else</span> { <span class="comment">// 跟链表进行比较</span>
            <span class="keyword">for</span> (<span class="built_in">int</span> binCount = <span class="number">0</span>; ; ++binCount) {
                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) { <span class="comment">// 一直遍历链表，直到找到最后一个</span>
                    p.next = newNode(hash, <span class="variable">key</span>, value, <span class="keyword">null</span>); <span class="comment">// 构造链表上的新节点</span>
                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span>
                        treeifyBin(tab, hash);
                    <span class="keyword">break</span>;
                }
                <span class="keyword">if</span> (e.hash == hash &amp;&amp;
                    ((k = e.<span class="variable">key</span>) == <span class="variable">key</span> || (<span class="variable">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="variable">key</span>.equals(k))))
                    <span class="keyword">break</span>;
                p = e;
            }
        }
        <span class="keyword">if</span> (e != <span class="keyword">null</span>) { <span class="comment">// 如果找到了节点，说明关键字相同，进行覆盖操作，直接返回旧的关键字的值</span>
            V oldValue = e.value;
            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)
                e.value = value;
            afterNodeAccess(e);
            <span class="keyword">return</span> oldValue;
        }
    }
    ++modCount;
    <span class="keyword">if</span> (++<span class="built_in">size</span> &gt; threshold) <span class="comment">// 如果目前键值对个数已经超过阀值，重新构建</span>
        resize();
    afterNodeInsertion(evict); <span class="comment">// 节点插入以后的钩子方法</span>
    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</code></pre><h4 id="get操作">get操作</h4><p>get操作关键点就是怎么在哈希表上取数据，理解了put操作之后，get方法很容易理解了：</p>
<pre><code><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="variable">key</span>) {
    Node&lt;K,V&gt; e;
    <span class="keyword">return</span> (e = getNode(hash(<span class="variable">key</span>), <span class="variable">key</span>)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;
}
</code></pre><p>getNode方法就说明了如何取数据：</p>
<pre><code><span class="keyword">final</span> Node&lt;K,V&gt; getNode(<span class="built_in">int</span> hash, <span class="keyword">Object</span> <span class="variable">key</span>) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="built_in">int</span> n; K k;
    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;
        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) { <span class="comment">// 如果哈希表容量为0或者关键字没有命中，直接返回null</span>
        <span class="keyword">if</span> (first.hash == hash &amp;&amp;  <span class="comment">// 关键字命中的话比较第一个节点</span>
            ((k = first.<span class="variable">key</span>) == <span class="variable">key</span> || (<span class="variable">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="variable">key</span>.equals(k)))) 
            <span class="keyword">return</span> first;
        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) {
            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 以红黑树的方式查找</span>
                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, <span class="variable">key</span>);
            do { <span class="comment">// 遍历链表查找</span>
                <span class="keyword">if</span> (e.hash == hash &amp;&amp;
                    ((k = e.<span class="variable">key</span>) == <span class="variable">key</span> || (<span class="variable">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="variable">key</span>.equals(k))))
                    <span class="keyword">return</span> e;
            } <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);
        }
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</code></pre><h4 id="hash过程和resize过程分析">hash过程和resize过程分析</h4><p>hash过程在HashMap里就是一个hash方法：</p>
<pre><code><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> hash(<span class="keyword">Object</span> <span class="variable">key</span>) {
    <span class="built_in">int</span> h;
    <span class="comment">// 使用hashCode的值和hashCode的值无符号右移16位做异或操作</span>
    <span class="keyword">return</span> (<span class="variable">key</span> == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = <span class="variable">key</span>.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);
}
</code></pre><p>这段代码是什么意思呢？ 我们以文中的那个demo为例，说明”java”这个关键字是如何找到对应bucket的过程。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/hashmap06.jpg" alt=""></p>
<p>从上图可以看到，hash方法得到的hash值是根据关键字的hashCode的高16位和低16位进行异或操作得到的一个值。</p>
<p>这个值再与哈希表容量-1值进行与操作得到最终的bucket索引值。</p>
<pre><code><span class="list">(<span class="keyword">n</span> - <span class="number">1</span>)</span> &amp; hash
</code></pre><p>hashCode的高16位与低16位进行异或操作主要是设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)来做的。</p>
<p>如果链表的数量大了，HashMap会把哈希表转换成红黑树来进行处理，本文不讨论这部分内容。</p>
<p>现在回过头来看例子，为什么初始化了一个容量为5的HashMap，但是哈希表的容量为8，而且阀值为6？</p>
<p>因为HashMap的构造函数初始化threshold的时候调用了tableSizeFor方法，这个方法会把容量改成2的幂的整数，主要是为了哈希表散列更均匀。</p>
<pre><code><span class="comment">// 定位bucket索引的最后操作。如果n为奇数，n-1就是偶数，偶数的话转成二进制最后一位是0，相反如果是奇数，最后一位是1，这样产生的索引值将更均匀</span>
(n - <span class="number">1</span>) &amp; hash
</code></pre><p>tableSizeFor方法如下：</p>
<pre><code>this.threshold = tableSizeFor(initialCapacity);

<span class="comment">// 保证thresold为2的幂</span>
static final int tableSizeFor(int <span class="keyword">cap</span>) {
    int <span class="keyword">n</span> = <span class="keyword">cap</span> - 1;
    <span class="keyword">n</span> |= <span class="keyword">n</span> &gt;&gt;&gt; 1;
    <span class="keyword">n</span> |= <span class="keyword">n</span> &gt;&gt;&gt; 2;
    <span class="keyword">n</span> |= <span class="keyword">n</span> &gt;&gt;&gt; 4;
    <span class="keyword">n</span> |= <span class="keyword">n</span> &gt;&gt;&gt; 8;
    <span class="keyword">n</span> |= <span class="keyword">n</span> &gt;&gt;&gt; 16;
    <span class="keyword">return</span> (<span class="keyword">n</span> &lt; 0) ? 1 : (<span class="keyword">n</span> &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : <span class="keyword">n</span> + 1;
}
</code></pre><p>阀值为6是因为之后进行resize操作的时候更新了阀值</p>
<pre><code>阀值 = 容量 * 加载因子 = <span class="number">8</span> * <span class="number">0.75</span> = <span class="number">6</span>
</code></pre><p>HashMap的扩容会把原先哈希表的容量扩大两倍。扩大之后，会对节点重新进行处理。</p>
<p>哈希表上的节点的状态有3种，分别是单节点，无节点，链表，扩容对于这3种状态的处理方式如下：</p>
<p>以8节点为原先容量，扩容为16容量讲解。</p>
<ol>
<li>单节点：由于容量扩大两倍，相当于左移1位。扩容前与00000111[7，n - 1 = 8 - 1]进行与操作。扩容后与00001111[15, n - 1 = 16 - 1]进行与操作。所以最终的结果要是还是在原位置，要么在原位置 +8(+old capacity) 位置</li>
<li>无节点：不处理</li>
<li>链表：遍历各个节点，每个节点的处理方式跟单节点一样，结果分成2种，还在原位置和原位置 +8 位置</li>
</ol>
<p>单节点处理示意图如下，这么设计的原因就是不需要再次计算hash值，只需要移动位置(+old capacity)即可：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/hashmap07.jpg" alt="">   </p>
<p>下图是一个HashMap扩容之后的效果图（省去了索引为7橙色链表的虚线，太多线条了）：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/hashmap08.jpg" alt="">   </p>
<p>哈希表扩容是使用resize方法完成：</p>
<pre><code><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() {
    Node&lt;K,V&gt;[] oldTab = table;
    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;
    <span class="keyword">int</span> oldThr = threshold;
    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;
    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) { <span class="comment">// 如果老容量大于0，说明哈希表中已经有数据了，然后进行扩容</span>
        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) { <span class="comment">// 超过最大容量的话，不扩容</span>
            threshold = Integer.MAX_VALUE;
            <span class="keyword">return</span> oldTab;
        }
        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; <span class="comment">// 容量加倍</span>
                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) <span class="comment">// 如果老的容量超过默认容量的话</span>
            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 阀值加倍</span>
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 根据thresold初始化数组</span>
        newCap = oldThr;
    <span class="keyword">else</span> {               <span class="comment">// 使用默认配置</span>
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    <span class="keyword">if</span> (newThr == <span class="number">0</span>) {
        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?
                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>})
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];
    table = newTab;
    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) {
        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) { <span class="comment">// 扩容之后进行rehash操作</span>
            Node&lt;K,V&gt; e;
            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) {
                oldTab[j] = <span class="keyword">null</span>;
                <span class="keyword">if</span> (e.<span class="keyword">next</span> == <span class="keyword">null</span>)
                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">// 单节点扩容</span>
                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap); <span class="comment">// 红黑树方式处理</span>
                <span class="keyword">else</span> { <span class="comment">// 链表扩容</span>
                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;
                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;
                    Node&lt;K,V&gt; <span class="keyword">next</span>;
                    <span class="keyword">do</span> {
                        <span class="keyword">next</span> = e.<span class="keyword">next</span>;
                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) {
                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)
                                loHead = e;
                            <span class="keyword">else</span>
                                loTail.<span class="keyword">next</span> = e;
                            loTail = e;
                        } 
                        <span class="keyword">else</span> {
                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)
                                hiHead = e;
                            <span class="keyword">else</span>
                                hiTail.<span class="keyword">next</span> = e;
                            hiTail = e;
                        }
                    } <span class="keyword">while</span> ((e = <span class="keyword">next</span>) != <span class="keyword">null</span>);
                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) {
                        loTail.<span class="keyword">next</span> = <span class="keyword">null</span>;
                        newTab[j] = loHead;
                    }
                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) {
                        hiTail.<span class="keyword">next</span> = <span class="keyword">null</span>;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    <span class="keyword">return</span> newTab;
}
</code></pre><h2 id="HashMap注意的地方">HashMap注意的地方</h2><ol>
<li>HashMap底层是个哈希表，使用拉链法解决冲突</li>
<li>HashMap内部存储的数据是无序的，这是因为HashMap内部的数组的下表是根据hash值算出来的</li>
<li>HashMap允许key为null</li>
<li>HashMap不是一个线程安全的类</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Map是一个映射键和值的对象。类似于Python中的字典。</p>
<p>HashMap为什么会出现呢?</p>
<p>因为数组这种数据结构，虽然遍历简单，但是插入和删除操作复杂，需要移动数组内部的元素；链表这种数据结构，插入和删除操作简单，但是查找复杂，只能一个一个地遍历。</p>
<p>有没有一种新的数据结构，插入数据简单，同时查找也简单？ 这个时候就出现了哈希表这种数据结构。 这是一种折中的方式，插入没链表快，查询没数组快。</p>
<p>wiki上就是这么定义哈希表的：</p>
<p>散列表（Hash table，也叫哈希表），是根据关键字（Key value）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p>]]>
    
    </summary>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="map" scheme="http://fangjian0423.github.io/tags/map/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk LinkedList工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/03/27/jdk_linkedlist/"/>
    <id>http://fangjian0423.github.io/2016/03/27/jdk_linkedlist/</id>
    <published>2016-03-27T09:35:27.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>List接口的实现类之一ArrayList的内部实现是一个数组，而另外一个实现LinkedList内部实现是使用双向链表。</p>
<p>LinkedList在内部定义了一个叫做Node类型的内部类，这个Node就是一个节点，链表中的节点，这个节点有3个属性，分别是元素item(当前节点要表示的值), 前节点prev(当前节点之前位置上的一个节点)，后节点next(当前节点后面位置的一个节点)。 </p>
<p>LinkedList关于数据的插入，删除操作都会处理这些节点的前后关系。而不像ArrayList那样只需要移动元素的位置即可。</p>
<a id="more"></a>
<h2 id="源码分析">源码分析</h2><p>在分析LinkedList之前，我们先看下它里面的内部类Node，也就是节点的定义：</p>
<pre><code>private static class <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; {
    E item; // 节点所表示的值
    <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; next; // 后节点
    <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; prev; // 前节点

    <span class="keyword">Node</span><span class="identifier"></span><span class="title">(Node</span><span class="tag">&lt;E&gt;</span> prev, E element, <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
</code></pre><p>LinkedList的3个属性：</p>
<pre><code>transient int size = <span class="number">0</span>; // 集合链表内节点数量

transient <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; first; // 集合链表的首节点

transient <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; last; // 集合链表的尾节点
</code></pre><h3 id="add(E_e)">add(E e)</h3><p><strong> 添加元素到链表的最后一个位置 </strong></p>
<pre><code>public boolean add(<span class="keyword">E</span> <span class="keyword">e</span>) {
    linkLast(<span class="keyword">e</span>);
    <span class="keyword">return</span> true;
}

void linkLast(<span class="keyword">E</span> <span class="keyword">e</span>) {
    final Node&lt;<span class="keyword">E</span>&gt; <span class="keyword">l</span> = last;
    final Node&lt;<span class="keyword">E</span>&gt; newNode = new Node&lt;&gt;(<span class="keyword">l</span>, <span class="keyword">e</span>, null); <span class="comment">// 由于是添加元素的链表尾部，所以也就是这个新的节点是最后1个节点，它的前节点肯定是目前链表的尾节点，它的后节点为null</span>
    last = newNode; <span class="comment">// 尾节点变成新的节点</span>
    <span class="keyword">if</span> (<span class="keyword">l</span> == null) <span class="comment">// 如果一开始尾节点还没设置，那么说明这个新的节点是第一个节点，那么首节点也就是这个第一个节点</span>
        first = newNode;
    <span class="keyword">else</span> <span class="comment">// 否则，说明新节点不是第一个节点，处理节点前后关系</span>
        <span class="keyword">l</span>.next = newNode;
    size++; <span class="comment">// 节点数量+1</span>
    modCount++;
}
</code></pre><p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/linkedlist01.jpg" alt=""></p>
<p>上图第一个图就表示一个已经有1，2这2个节点的LinkedList调用add方法，第二个图表示添加一个值为3的元素后的情况。原先的尾节点2的后节点变成的新节点3，新节点3的前节点是原先的尾节点2，新节点3的后节点为null。同时链表的尾节点变成了3.</p>
<h3 id="add(int_index,_E_element)">add(int index, E element)</h3><p><strong> 添加元素到列表中的指定位置 </strong></p>
<pre><code><span class="keyword">public</span> <span class="keyword">void</span> add(<span class="keyword">int</span> <span class="keyword">index</span>, E element) {
    checkPositionIndex(<span class="keyword">index</span>); <span class="comment">// 检查索引的合法性，不能超过链表个数，不能小于0</span>

    <span class="keyword">if</span> (<span class="keyword">index</span> == size) <span class="comment">// 如果是在链表尾部插入节点，那么直接调用linkLast方法，上面已经分析过</span>
        linkLast(element);
    <span class="keyword">else</span> <span class="comment">// 不在链表尾部插入节点的话，调用linkBefore方法，参数为要插入的元素值和节点对象</span>
        linkBefore(element, node(<span class="keyword">index</span>));
}
</code></pre><p>先看一下node方法是如何根据索引找到对应的节点的：</p>
<pre><code>Node&lt;E&gt; node(<span class="keyword">int</span> index) {
    <span class="comment">// 用了一个小算法，如果索引比链表数量的一半还要小，从前往后找，这样只需要花O(n/2)的时间获取节点</span>
    <span class="keyword">if</span> (index &lt; (<span class="keyword">size</span> &gt;&gt; <span class="number">1</span>)) {
        Node&lt;E&gt; x = first;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)
            x = x.<span class="keyword">next</span>;
        <span class="keyword">return</span> x;
    } <span class="keyword">else</span> { <span class="comment">// 否则从后往前找</span>
        Node&lt;E&gt; x = last;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">size</span> - <span class="number">1</span>; i &gt; index; i--)
            x = x.prev;
        <span class="keyword">return</span> x;
    }
}

<span class="keyword">void</span> linkBefore(E e, Node&lt;E&gt; succ) { <span class="comment">// succ节点表示要新插入节点应该在的位置</span>
    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;
    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ); <span class="comment">// 1：新节点的前节点就是succ节点的前节点，新节点的后节点是succ节点</span>
    succ.prev = newNode; <span class="comment">// 2：succ的前节点就是新节点</span>
    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)    <span class="comment">// prev=null表示succ节点就是head首节点，这样的话只需要重新set一下首节点即可，首节点的后节点在步骤1以及设置过了</span>
        first = newNode;
    <span class="keyword">else</span> <span class="comment">// succ不是首节点的话执行步骤3</span>
        pred.<span class="keyword">next</span> = newNode; <span class="comment">// 3：succ节点的前节点的后节点就是新节点</span>
    <span class="keyword">size</span>++; <span class="comment">// 节点数量+1</span>
    modCount++;
} 
</code></pre><p>上面代码中注释的1，2，3点就在下图中表示：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/linkedlist02.jpg" alt=""></p>
<p>LinkedList还提供了2种特殊的add方法，分别是addFirst和addLast方法，处理添加首节点和尾节点，原理都是差不多的，处理链表之间的关联关系即可。</p>
<h3 id="remove(int_index)">remove(int index)</h3><p><strong> 移除指定位置上的节点 </strong></p>
<pre><code><span class="keyword">public</span> E remove(<span class="keyword">int</span> index) {
    checkElementIndex(index); <span class="comment">// 检查索引的合法性，不能超过链表个数，不能小于0 </span>
    <span class="keyword">return</span> unlink(node(index));
}

E unlink(Node&lt;E&gt; x) {
    <span class="keyword">final</span> E element = x.item;
    <span class="keyword">final</span> Node&lt;E&gt; <span class="keyword">next</span> = x.<span class="keyword">next</span>;
    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;

    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) { <span class="comment">// 特殊情况，删除的是头节点</span>
        first = <span class="keyword">next</span>;
    } <span class="keyword">else</span> {
        prev.<span class="keyword">next</span> = <span class="keyword">next</span>; <span class="comment">// 1</span>
        x.prev = <span class="keyword">null</span>; <span class="comment">// 1</span>
    }

    <span class="keyword">if</span> (<span class="keyword">next</span> == <span class="keyword">null</span>) { <span class="comment">// 特殊情况，删除的是尾节点</span>
        last = prev;
    } <span class="keyword">else</span> {
        <span class="keyword">next</span>.prev = prev; <span class="comment">// 2</span>
        x.<span class="keyword">next</span> = <span class="keyword">null</span>; <span class="comment">// 2</span>
    }

    x.item = <span class="keyword">null</span>; <span class="comment">// 3</span>
    <span class="keyword">size</span>--; <span class="comment">// 链表数量减一</span>
    modCount++;
    <span class="keyword">return</span> element;
}
</code></pre><p>上面代码中注释的1，2，3点就在下图中表示：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/linkedlist03.jpg" alt=""></p>
<h3 id="get(int_index)">get(int index)</h3><p><strong> 得到索引位置上的元素 </strong></p>
<pre><code><span class="keyword">public</span> E get(<span class="keyword">int</span> <span class="keyword">index</span>) {
    checkElementIndex(<span class="keyword">index</span>); <span class="comment">// 检查索引的合法性，不能超过链表个数，不能小于0 </span>
    <span class="keyword">return</span> node(<span class="keyword">index</span>).item; <span class="comment">// 直接找到节点，返回节点的元素值即可</span>
}
</code></pre><h2 id="LinkedList和ArrayList的比较">LinkedList和ArrayList的比较</h2><ol>
<li>LinkedList和ArrayList的设计理念完全不一样，ArrayList基于数组，而LinkedList基于节点，也就是链表。所以LinkedList内部没有容量这个概念，因为是链表，链表是无界的</li>
<li>两者的使用场景不同，ArrayList适用于读多写少的场合。LinkedList适用于写多读少的场合。 刚好相反。 那是因为LinkedList要找节点的话必须要遍历一个一个节点，直到找到为止。而ArrayList完全不需要，因为ArrayList内部维护着一个数组，直接根据索引拿到需要的元素即可。</li>
<li>两个都是List接口的实现类，都是一种集合</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>List接口的实现类之一ArrayList的内部实现是一个数组，而另外一个实现LinkedList内部实现是使用双向链表。</p>
<p>LinkedList在内部定义了一个叫做Node类型的内部类，这个Node就是一个节点，链表中的节点，这个节点有3个属性，分别是元素item(当前节点要表示的值), 前节点prev(当前节点之前位置上的一个节点)，后节点next(当前节点后面位置的一个节点)。 </p>
<p>LinkedList关于数据的插入，删除操作都会处理这些节点的前后关系。而不像ArrayList那样只需要移动元素的位置即可。</p>]]>
    
    </summary>
    
      <category term="collection" scheme="http://fangjian0423.github.io/tags/collection/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk ArrayList工作原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/03/27/jdk_arraylist/"/>
    <id>http://fangjian0423.github.io/2016/03/27/jdk_arraylist/</id>
    <published>2016-03-27T05:33:17.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>list是一种有序的集合(an ordered collection), 通常也会被称为序列(sequence)，使用list可以精确地控制每个元素的插入，可以通过索引值找到对应list中的各个项，也可以在list中查询元素。</p>
<p>以前的几段话摘自jdk文档的说明。</p>
<p>其实list就相当于一个动态的数组，也就是链表，普通的数组长度大小都是固定的，而list是一个动态的数组，当list的长度满了，再次插入数据到list当中的时候，list会自动地扩展它的长度。</p>
<a id="more"></a>
<h2 id="ArrayList源码分析">ArrayList源码分析</h2><p>首先我们先分析一个List接口的实现类之一，也是最常用的ArrayList的源码。</p>
<p>ArrayList底层使用一个数组完成数据的添加，查询，删除，修改。这个数组就是下面提到的elementData。</p>
<p>这里分析的代码是基于jdk1.7的。</p>
<p>ArrayList类的属性如下：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> DEFAULT_CAPACITY = <span class="number">10</span>; <span class="comment">// 集合的默认容量</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span>[] EMPTY_ELEMENTDATA = {}; <span class="comment">// 一个空集合数组，容量为0</span>
<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">Object</span>[] elementData; <span class="comment">// 存储集合数据的数组，默认值为null</span>
<span class="keyword">private</span> <span class="built_in">int</span> <span class="built_in">size</span>; <span class="comment">// ArrayList集合中数组的当前有效长度，比如数组的容量是5，size是1 表示容量为5的数组目前已经有1条记录了，其余4条记录还是为空</span>
</code></pre><p>接下来看一下ArrayList的构造函数：</p>
<p>ArrayList有3个构造函数，分别是</p>
<pre><code><span class="keyword">public</span> ArrayList(<span class="keyword">int</span> initialCapacity) { <span class="comment">// 带有集合容量参数的构造函数</span>
    <span class="comment">// 调用父类AbstractList的方法构造函数</span>
    <span class="keyword">super</span>();
    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>) <span class="comment">// 如果集合的容量小于0，这明显是个错误数值，直接抛出异常</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+
                                           initialCapacity);
    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity]; <span class="comment">// 初始化elementData属性，确定容量</span>
}

<span class="keyword">public</span> ArrayList() { <span class="comment">// 没有参数的构造函数</span>
    <span class="keyword">super</span>(); <span class="comment">// 调用父类AbstractList的方法构造函数</span>
    <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA; <span class="comment">// 让elementData和ArrayList的EMPTY_ELEMENTDATA这个空数组使用同一个引用</span>
}

<span class="keyword">public</span> ArrayList(Collection&lt;? <span class="keyword">extends</span> E&gt; c) { <span class="comment">// 参数是一个集合的构造函数</span>
    elementData = c.toArray(); <span class="comment">// elementData直接使用参数集合内部的数组</span>
    <span class="keyword">size</span> = elementData.length; <span class="comment">// 初始化数组当前有效长度</span>
    <span class="comment">// c.toArray方法可能不会返回一个Object[]结果，需要做一层判断。这个一个Java的bug，可以在http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652查看</span>
    <span class="keyword">if</span> (elementData.getClass() != Object[].<span class="keyword">class</span>)
        elementData = Arrays.copyOf(elementData, <span class="keyword">size</span>, Object[].<span class="keyword">class</span>);
}
</code></pre><p>接下来挑几个重要的方法讲解一下：</p>
<h3 id="add(E_e)_方法">add(E e) 方法</h3><p>这个方法的作用就是把 <strong>元素添加到集合的最后面</strong> </p>
<p>源码：</p>
<pre><code><span class="function"><span class="keyword">public</span> boolean <span class="title">add</span><span class="params">(E e)</span> </span>{
    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// 调用ensureCapacityInternal，参数是集合当前的长度。确保集合容量够大，不够的话需要扩容</span>
    elementData[size++] = e; <span class="comment">// 数组容量够的话，直接添加元素到数组最后一个位置即可，同时修改集合当前有效长度</span>
    <span class="keyword">return</span> <span class="literal">true</span>;
}

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{
    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) { <span class="comment">// 如果数组是个空数组，说明调用的是无参的构造函数</span>
        <span class="comment">// 如果调用的是无参构造函数，说明数组容量为0，那就需要使用默认容量</span>
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }

    ensureExplicitCapacity(minCapacity);
}    

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{
    modCount++;

    <span class="comment">// 如果集合需要的最小长度比数组容量要大，那么就需要扩容，已经放不下了</span>
    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)
        grow(minCapacity);
}

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{ <span class="comment">// 扩容的实现</span>
    <span class="keyword">int</span> oldCapacity = elementData.length;
    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// 长度扩大1.5倍</span>
    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)
        newCapacity = minCapacity;
    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)
        newCapacity = hugeCapacity(minCapacity);
    <span class="comment">// 将数组拷贝到新长度的数组中</span>
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre><p>以下面这段代码讲解一下扩容的机制：</p>
<pre><code><span class="comment">// 初始化一个容量为5的数组</span>
ArrayList&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">5</span>);
<span class="built_in">list</span>.add(<span class="number">1</span>);
<span class="built_in">list</span>.add(<span class="number">2</span>);
<span class="built_in">list</span>.add(<span class="number">3</span>);
<span class="built_in">list</span>.add(<span class="number">4</span>);
<span class="built_in">list</span>.add(<span class="number">5</span>);
<span class="comment">// 当添加第6个元素的时候，数组进行了扩容，扩容1.5倍(5+5/2=7)</span>
<span class="built_in">list</span>.add(<span class="number">6</span>);
</code></pre><p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/arraylist01.jpg" alt=""></p>
<p>上图2个白色的空间就是扩容出来的，添加第6个元素之后，最后一个元素没被设置。</p>
<h3 id="add(int_index,_E_element)_方法">add(int index, E element) 方法</h3><p>这个方法的作用是 <strong>在指定位置插入数据</strong>，该方法的缺点就是如果集合数据量很大，移动元素位置将会话费不少时间：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">void</span> add(<span class="keyword">int</span> <span class="keyword">index</span>, E element) {
    rangeCheckForAdd(<span class="keyword">index</span>); <span class="comment">// 检查索引位置的正确的，不能小于0也不能大于数组有效长度</span>

    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// 扩容检测</span>
    System.arraycopy(elementData, <span class="keyword">index</span>, elementData, <span class="keyword">index</span> + <span class="number">1</span>,
                     size - <span class="keyword">index</span>); <span class="comment">// 移动数组位置，数据量很大的话，性能变差</span>
    elementData[<span class="keyword">index</span>] = element; <span class="comment">// 指定的位置插入数据</span>
    size++; <span class="comment">// 数组有效长度+1</span>
}
</code></pre><p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/arraylist03.jpg" alt=""></p>
<p>上图就表示要在容量为5的数组中的第4个位置插入6这个元素，会进行3个步骤：</p>
<ol>
<li>容量为5，再次加入元素，需要扩容，扩容出2个白色的空间</li>
<li>扩容之后，5和4这2个元素都移到后面那个位置上</li>
<li>移动完毕之后空出了第4个位置，插入元素6</li>
</ol>
<h3 id="remove(int_index)">remove(int index)</h3><p>remove方法就是 <strong>移除对应坐标值上的数据</strong></p>
<pre><code><span class="keyword">public</span> E remove(<span class="keyword">int</span> <span class="keyword">index</span>) {
  rangeCheck(<span class="keyword">index</span>); <span class="comment">// 检查索引值是否合法</span>

  modCount++;
  E oldValue = elementData(<span class="keyword">index</span>); <span class="comment">// 得到对应索引位置上的元素</span>

  <span class="keyword">int</span> numMoved = size - <span class="keyword">index</span> - <span class="number">1</span>; <span class="comment">// 需要移动的数量</span>
  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)
      System.arraycopy(elementData, <span class="keyword">index</span>+<span class="number">1</span>, elementData, <span class="keyword">index</span>,
                       numMoved); <span class="comment">// 从后往前移，留出最后一个元素</span>
  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// 清楚对应位置上的对象，让gc回收</span>

  <span class="keyword">return</span> oldValue;
}
</code></pre><p>比如要移除5个元素中的第3个元素，首先要把4和5这2个位置的元素分别set到3和4这2个位置上，set完之后最后一个位置也就是第5个位置set为null。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/arraylist02.jpg" alt=""></p>
<h3 id="remove(Object_o)">remove(Object o)</h3><p> <strong>找出数组中的元素，然后移除</strong></p>
<pre><code><span class="comment">// 跟remove索引元素一样，这个方法是根据equals比较</span>
<span class="keyword">public</span> <span class="keyword">boolean</span> remove(Object o) {
    <span class="keyword">if</span> (o == <span class="keyword">null</span>) {
        <span class="comment">// ArrayList允许元素为null，所以对null值的删除在这个分支里进行</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> <span class="keyword">index</span> = <span class="number">0</span>; <span class="keyword">index</span> &lt; size; <span class="keyword">index</span>++)
            <span class="keyword">if</span> (elementData[<span class="keyword">index</span>] == <span class="keyword">null</span>) {
                fastRemove(<span class="keyword">index</span>);
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
    } <span class="keyword">else</span> {
        <span class="comment">// 效率比较低，需要从第1个元素开始遍历直到找到equals相等的元素后才进行删除，删除同样需要移动元素</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> <span class="keyword">index</span> = <span class="number">0</span>; <span class="keyword">index</span> &lt; size; <span class="keyword">index</span>++)
            <span class="keyword">if</span> (o.equals(elementData[<span class="keyword">index</span>])) {
                fastRemove(<span class="keyword">index</span>);
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><h3 id="clear">clear</h3><p><strong>清除list中的所有数据</strong></p>
<pre><code><span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">clear</span>() {
  modCount++;

  <span class="comment">// 遍历集合数据，全部set为null</span>
  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)
      elementData[i] = <span class="keyword">null</span>;

  <span class="built_in">size</span> = <span class="number">0</span>; <span class="comment">// 数组有效长度变成0</span>
}
</code></pre><h3 id="set(int_index,_E_element)">set(int index, E element)</h3><p><strong>用element值替换下标值为index的值</strong></p>
<pre><code><span class="keyword">public</span> E set(<span class="keyword">int</span> <span class="keyword">index</span>, E element) {
  rangeCheck(<span class="keyword">index</span>); <span class="comment">// 检查索引值是否合法</span>

  E oldValue = elementData(<span class="keyword">index</span>); 
  elementData[<span class="keyword">index</span>] = element; <span class="comment">// 直接替换</span>
  <span class="keyword">return</span> oldValue;
}
</code></pre><h3 id="get(int_index)">get(int index)</h3><p><strong>得到下标值为index的元素</strong></p>
<pre><code><span class="keyword">public</span> E get(<span class="keyword">int</span> <span class="keyword">index</span>) {
    rangeCheck(<span class="keyword">index</span>); <span class="comment">// 检查索引值是否合法</span>

    <span class="keyword">return</span> elementData(<span class="keyword">index</span>); <span class="comment">// 直接返回下标值</span>
}
</code></pre><h3 id="addAll">addAll</h3><p><strong>在列表的结尾添加一个Collection集合</strong></p>
<pre><code><span class="keyword">public</span> <span class="keyword">boolean</span> addAll(Collection&lt;? <span class="keyword">extends</span> E&gt; c) {
    Object[] a = c.toArray();
    <span class="keyword">int</span> numNew = a.length;
    ensureCapacityInternal(<span class="keyword">size</span> + numNew);  <span class="comment">// 扩容检测</span>
    System.arraycopy(a, <span class="number">0</span>, elementData, <span class="keyword">size</span>, numNew); <span class="comment">// 直接在数组后面添加新的数组中的所有元素</span>
    <span class="keyword">size</span> += numNew; <span class="comment">// 更新有效长度</span>
    <span class="keyword">return</span> numNew != <span class="number">0</span>;
}
</code></pre><h3 id="toArray">toArray</h3><p><strong>根据elementData数组拷贝一份新的数组</strong></p>
<pre><code><span class="keyword">public</span> <span class="keyword">Object</span>[] toArray() {
    <span class="keyword">return</span> Arrays.copyOf(elementData, <span class="built_in">size</span>);
}
</code></pre><h2 id="ArrayList的注意点">ArrayList的注意点</h2><ol>
<li>当数据量很大的时候，ArrayList内部操作元素的时候会移动位置，很耗性能</li>
<li>ArrayList虽然可以自动扩展长度，但是数据量一大，扩展的也多，会造成很多空间的浪费</li>
<li>ArrayList有一个内部私有类，SubList。ArrayList提供一个subList方法用于构造这个SubList。这里需要注意的是SubList和ArrayList使用的数据引用是同一个对象，在SubList中操作数据和在ArrayList中操作数据都会影响双方。</li>
<li>ArrayList允许加入null元素</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>list是一种有序的集合(an ordered collection), 通常也会被称为序列(sequence)，使用list可以精确地控制每个元素的插入，可以通过索引值找到对应list中的各个项，也可以在list中查询元素。</p>
<p>以前的几段话摘自jdk文档的说明。</p>
<p>其实list就相当于一个动态的数组，也就是链表，普通的数组长度大小都是固定的，而list是一个动态的数组，当list的长度满了，再次插入数据到list当中的时候，list会自动地扩展它的长度。</p>]]>
    
    </summary>
    
      <category term="collection" scheme="http://fangjian0423.github.io/tags/collection/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/categories/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java线程池ThreadPoolExecutor源码分析]]></title>
    <link href="http://fangjian0423.github.io/2016/03/22/java-threadpool-analysis/"/>
    <id>http://fangjian0423.github.io/2016/03/22/java-threadpool-analysis/</id>
    <published>2016-03-22T12:56:11.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>ThreadPoolExecutor是jdk内置线程池的一个实现，基本上大部分情况都会使用这个线程池完成各项操作。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/thread-pool.jpeg" alt=""></p>
<a id="more"></a>
<p>本文分析ThreadPoolExecutor的实现原理。</p>
<h2 id="ThreadPoolExecutor的状态和属性">ThreadPoolExecutor的状态和属性</h2><p>ThreadPoolExecutor的属性在之前的一篇<a href="http://fangjian0423.github.io/2015/07/24/java-poolthread/">java内置的线程池笔记</a>文章中解释过了，本文不再解释。</p>
<p>ThreadPoolExecutor线程池有5个状态，分别是：</p>
<ol>
<li>RUNNING：可以接受新的任务，也可以处理阻塞队列里的任务</li>
<li>SHUTDOWN：不接受新的任务，但是可以处理阻塞队列里的任务</li>
<li>STOP：不接受新的任务，不处理阻塞队列里的任务，中断正在处理的任务</li>
<li>TIDYING：过渡状态，也就是说所有的任务都执行完了，当前线程池已经没有有效的线程，这个时候线程池的状态将会TIDYING，并且将要调用terminated方法</li>
<li>TERMINATED：终止状态。terminated方法调用完成以后的状态</li>
</ol>
<p>状态之间可以进行转换：</p>
<p>RUNNING -&gt; SHUTDOWN：手动调用shutdown方法，或者ThreadPoolExecutor要被GC回收的时候调用finalize方法，finalize方法内部也会调用shutdown方法</p>
<p>(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow方法</p>
<p>SHUTDOWN -&gt; TIDYING：当队列和线程池都为空的时候</p>
<p>STOP -&gt; TIDYING：当线程池为空的时候</p>
<p>TIDYING -&gt; TERMINATED：terminated方法调用完成之后</p>
<p>ThreadPoolExecutor内部还保存着线程池的有效线程个数。</p>
<p>状态和线程数在ThreadPoolExecutor内部使用一个整型变量保存，没错，一个变量表示两种含义。</p>
<p>为什么一个整型变量既可以保存状态，又可以保存数量？ 分析一下：</p>
<p>首先，我们知道java中1个整型占4个字节，也就是32位，所以1个整型有32位。</p>
<p>所以整型1用二进制表示就是：00000000000000000000000000000001</p>
<p>整型-1用二进制表示就是：11111111111111111111111111111111(这个是补码，不懂的同学可以看下原码，反码，补码的知识)</p>
<p>在ThreadPoolExecutor，整型中32位的前3位用来表示线程池状态，后3位表示线程池中有效的线程数。</p>
<pre><code><span class="comment">// 前3位表示状态，所有线程数占29位</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.<span class="keyword">SIZE</span> - <span class="number">3</span>;
</code></pre><p>线程池容量大小为 1 &lt;&lt; 29 - 1 = 00011111111111111111111111111111(二进制)，代码如下</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;
</code></pre><p>RUNNING状态 -1 &lt;&lt; 29 = 11111111111111111111111111111111 &lt;&lt; 29 = 11100000000000000000000000000000(前3位为111)：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;
</code></pre><p>SHUTDOWN状态 0 &lt;&lt; 29 = 00000000000000000000000000000000 &lt;&lt; 29 = 00000000000000000000000000000000(前3位为000)</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;
</code></pre><p>STOP状态 1 &lt;&lt; 29 = 00000000000000000000000000000001 &lt;&lt; 29 = 00100000000000000000000000000000(前3位为001)：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;
</code></pre><p>TIDYING状态 2 &lt;&lt; 29 = 00000000000000000000000000000010 &lt;&lt; 29 = 01000000000000000000000000000000(前3位为010)：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;
</code></pre><p>TERMINATED状态 3 &lt;&lt; 29 = 00000000000000000000000000000011 &lt;&lt; 29 = 01100000000000000000000000000000(前3位为011)：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;    
</code></pre><p>清楚状态位之后，下面是获得状态和线程数的内部方法：</p>
<pre><code><span class="comment">// 得到线程数，也就是后29位的数字。 直接跟CAPACITY做一个与操作即可，CAPACITY就是的值就 1 &lt;&lt; 29 - 1 = 00011111111111111111111111111111。 与操作的话前面3位肯定为0，相当于直接取后29位的值</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>{ <span class="keyword">return</span> c &amp; CAPACITY; }

<span class="comment">// 得到状态，CAPACITY的非操作得到的二进制位11100000000000000000000000000000，然后做在一个与操作，相当于直接取前3位的的值</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>{ <span class="keyword">return</span> c &amp; ~CAPACITY; }

<span class="comment">// 或操作。相当于更新数量和状态两个操作</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>{ <span class="keyword">return</span> rs | wc; }
</code></pre><p>线程池初始化状态线程数变量：</p>
<pre><code><span class="comment">// 初始化状态和数量，状态为RUNNING，线程数为0</span>
<span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));
</code></pre><h2 id="ThreadPoolExecutor执行任务">ThreadPoolExecutor执行任务</h2><p>使用ThreadPoolExecutor执行任务的时候，可以使用execute或submit方法，submit方法如下：</p>
<pre><code><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable <span class="keyword">task</span>) {
    <span class="keyword">if</span> (<span class="keyword">task</span> == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    RunnableFuture&lt;<span class="keyword">Void</span>&gt; ftask = newTaskFor(<span class="keyword">task</span>, <span class="keyword">null</span>);
    execute(ftask);
    <span class="keyword">return</span> ftask;
}
</code></pre><p>很明显地看到，submit方法内部使用了execute方法，而且submit方法是有返回值的。在调用execute方法之前，使用FutureTask包装一个Runnable，这个FutureTask就是返回值。</p>
<p>由于submit方法内部调用execute方法，所以execute方法就是执行任务的方法，来看一下execute方法，execute方法内部分3个步骤进行处理。</p>
<ol>
<li>如果当前正在执行的Worker数量比corePoolSize(基本大小)要小。直接创建一个新的Worker执行任务，会调用addWorker方法</li>
<li>如果当前正在执行的Worker数量大于等于corePoolSize(基本大小)。将任务放到阻塞队列里，如果阻塞队列没满并且状态是RUNNING的话，直接丢到阻塞队列，否则执行第3步。丢到阻塞队列之后，还需要再做一次验证(丢到阻塞队列之后可能另外一个线程关闭了线程池或者刚刚加入到队列的线程死了)。如果这个时候线程池不在RUNNING状态，把刚刚丢入队列的任务remove掉，调用reject方法，否则查看Worker数量，如果Worker数量为0，起一个新的Worker去阻塞队列里拿任务执行</li>
<li>丢到阻塞失败的话，会调用addWorker方法尝试起一个新的Worker去阻塞队列拿任务并执行任务，如果这个新的Worker创建失败，调用reject方法</li>
</ol>
<p>上面说的Worker可以暂时理解为一个执行任务的线程。</p>
<p>execute方法源码如下，上面提到的3个步骤对应源码中的3个注释：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params">Runnable command</span>) </span>{
    <span class="keyword">if</span> (command == <span class="keyword">null</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    <span class="keyword">int</span> c = ctl.<span class="keyword">get</span>();
    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) {   <span class="comment">// 第一个步骤，满足线程池中的线程大小比基本大小要小</span>
        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) <span class="comment">// addWorker方法第二个参数true表示使用基本大小</span>
            <span class="keyword">return</span>;
        c = ctl.<span class="keyword">get</span>();
    }
    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) { <span class="comment">// 第二个步骤，线程池的线程大小比基本大小要大，并且线程池还在RUNNING状态，阻塞队列也没满的情况，加到阻塞队列里</span>
        <span class="keyword">int</span> recheck = ctl.<span class="keyword">get</span>();
        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="comment">// 虽然满足了第二个步骤，但是这个时候可能突然线程池关闭了，所以再做一层判断</span>
            reject(command);
        <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">workerCountOf(recheck</span>) </span>== <span class="number">0</span>)
            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);
    }
    <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">!addWorker(command, <span class="keyword">false</span></span>)) <span class="comment">// 第三个步骤，直接使用线程池最大大小。addWorker方法第二个参数false表示使用最大大小</span>
        <span class="title">reject</span>(<span class="params">command</span>)</span>;
}
</code></pre><p>addWorker关系着如何起一个线程，再看addWorker方法之前，先看一下ThreadPoolExecutor的一个内部类Worker, Worker是一个AQS的实现类(为何设计成一个AQS在闲置Worker里会说明)，同时也是一个实现Runnable的类，使用独占锁，它的构造函数只接受一个Runnable参数，内部保存着这个Runnable属性，还有一个thread线程属性用于包装这个Runnable(这个thread属性使用ThreadFactory构造，在构造函数内完成thread线程的构造)，另外还有一个completedTasks计数器表示这个Worker完成的任务数。Worker类复写了run方法，使用ThreadPoolExecutor的runWorker方法(在addWorker方法里调用)，直接启动Worker的话，会调用ThreadPoolExecutor的runWork方法。<strong>需要特别注意的是这个Worker是实现了Runnable接口的，thread线程属性使用ThreadFactory构造Thread的时候，构造的Thread中使用的Runnable其实就是Worker。</strong>下面的Worker的源码：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span>    
    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span>
    <span class="keyword">implements</span> <span class="title">Runnable</span>
</span>{
    <span class="comment">/**
     * This class will never be serialized, but we provide a
     * serialVersionUID to suppress a javac warning.
     */</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833</span>L;

    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span>
    <span class="keyword">final</span> Thread thread;
    <span class="comment">/** Initial task to run.  Possibly null. */</span>
    Runnable firstTask;
    <span class="comment">/** Per-thread task counter */</span>
    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;

    <span class="comment">/**
     * Creates with given first task and thread from ThreadFactory.
     * <span class="doctag">@param</span> firstTask the first task (null if none)
     */</span>
    Worker(Runnable firstTask) {
        <span class="comment">// 使用ThreadFactory构造Thread，这个构造的Thread内部的Runnable就是本身，也就是Worker。所以得到Worker的thread并start的时候，会执行Worker的run方法，也就是执行ThreadPoolExecutor的runWorker方法</span>
        setState(-<span class="number">1</span>); 把状态位设置成-<span class="number">1</span>，这样任何线程都不能得到Worker的锁，除非调用了unlock方法。这个unlock方法会在runWorker方法中一开始就调用，这是为了确保Worker构造出来之后，没有任何线程能够得到它的锁，除非调用了runWorker之后，其他线程才能获得Worker的锁
        <span class="keyword">this</span>.firstTask = firstTask;
        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);
    }

    <span class="comment">/** Delegates main run loop to outer runWorker  */</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        runWorker(<span class="keyword">this</span>);
    }

    <span class="comment">// Lock methods</span>
    <span class="comment">//</span>
    <span class="comment">// The value 0 represents the unlocked state.</span>
    <span class="comment">// The value 1 represents the locked state.</span>

    <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> getState() != <span class="number">0</span>;
    }

    <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>{
        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {
            setExclusiveOwnerThread(Thread.currentThread());
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>{
        setExclusiveOwnerThread(<span class="keyword">null</span>);
        setState(<span class="number">0</span>);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>{ acquire(<span class="number">1</span>); }
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>{ <span class="function"><span class="keyword">return</span> <span class="title">tryAcquire</span><span class="params">(<span class="number">1</span>)</span></span>; }
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>{ release(<span class="number">1</span>); }
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>{ <span class="function"><span class="keyword">return</span> <span class="title">isHeldExclusively</span><span class="params">()</span></span>; }

    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>{
        Thread t;
        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) {
            <span class="keyword">try</span> {
                t.interrupt();
            } <span class="keyword">catch</span> (SecurityException ignore) {
            }
        }
    }
}
</code></pre><p>接下来看一下addWorker源码：</p>
<pre><code><span class="comment">// 两个参数，firstTask表示需要跑的任务。boolean类型的core参数为true的话表示使用线程池的基本大小，为false使用线程池最大大小</span>
<span class="comment">// 返回值是boolean类型，true表示新任务被接收了，并且执行了。否则是false</span>
<span class="keyword">private</span> <span class="built_in">boolean</span> addWorker(Runnable firstTask, <span class="built_in">boolean</span> core) {
    retry:
    <span class="keyword">for</span> (;;) {
        <span class="built_in">int</span> c = ctl.<span class="built_in">get</span>();
        <span class="built_in">int</span> rs = runStateOf(c); <span class="comment">// 线程池当前状态</span>

        <span class="comment">// 这个判断转换成 rs &gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != null || workQueue.isEmpty)。 </span>
        <span class="comment">// 概括为3个条件：</span>
        <span class="comment">// 1. 线程池不在RUNNING状态并且状态是STOP、TIDYING或TERMINATED中的任意一种状态</span>

        <span class="comment">// 2. 线程池不在RUNNING状态，线程池接受了新的任务 </span>

        <span class="comment">// 3. 线程池不在RUNNING状态，阻塞队列为空。  满足这3个条件中的任意一个的话，拒绝执行任务</span>

        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;
            ! (rs == SHUTDOWN &amp;&amp;
               firstTask == <span class="keyword">null</span> &amp;&amp;
               ! workQueue.isEmpty()))
            <span class="keyword">return</span> <span class="keyword">false</span>;

        <span class="keyword">for</span> (;;) {
            <span class="built_in">int</span> wc = workerCountOf(c); <span class="comment">// 线程池线程个数</span>
            <span class="keyword">if</span> (wc &gt;= CAPACITY ||
                wc &gt;= (core ? corePoolSize : maximumPoolSize)) <span class="comment">// 如果线程池线程数量超过线程池最大容量或者线程数量超过了基本大小(core参数为true，core参数为false的话判断超过最大大小)</span>
                <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 超过直接返回false</span>
            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c)) <span class="comment">// 没有超过各种大小的话，cas操作线程池线程数量+1，cas成功的话跳出循环</span>
                <span class="keyword">break</span> retry;
            c = ctl.<span class="built_in">get</span>();  <span class="comment">// 重新检查状态</span>
            <span class="keyword">if</span> (runStateOf(c) != rs) <span class="comment">// 如果状态改变了，重新循环操作</span>
                <span class="keyword">continue</span> retry;
            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span>
        }
    }
    <span class="comment">// 走到这一步说明cas操作成功了，线程池线程数量+1</span>
    <span class="built_in">boolean</span> workerStarted = <span class="keyword">false</span>; <span class="comment">// 任务是否成功启动标识</span>
    <span class="built_in">boolean</span> workerAdded = <span class="keyword">false</span>; <span class="comment">// 任务是否添加成功标识</span>
    Worker w = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock; <span class="comment">// 得到线程池的可重入锁</span>
        w = <span class="keyword">new</span> Worker(firstTask); <span class="comment">// 基于任务firstTask构造worker</span>
        <span class="keyword">final</span> Thread t = w.thread; <span class="comment">// 使用Worker的属性thread，这个thread是使用ThreadFactory构造出来的</span>
        <span class="keyword">if</span> (t != <span class="keyword">null</span>) { <span class="comment">// ThreadFactory构造出的Thread有可能是null，做个判断</span>
            mainLock.lock(); <span class="comment">// 锁住，防止并发</span>
            <span class="keyword">try</span> {
                <span class="comment">// 在锁住之后再重新检测一下状态</span>
                <span class="built_in">int</span> c = ctl.<span class="built_in">get</span>();
                <span class="built_in">int</span> rs = runStateOf(c);

                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||
                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) { <span class="comment">// 如果线程池在RUNNING状态或者线程池在SHUTDOWN状态并且任务是个null</span>
                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// 判断线程是否还活着，也就是说线程已经启动并且还没死掉</span>
                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException(); <span class="comment">// 如果存在已经启动并且还没死的线程，抛出异常</span>
                    workers.<span class="built_in">add</span>(w); <span class="comment">// worker添加到线程池的workers属性中，是个HashSet</span>
                    <span class="built_in">int</span> s = workers.<span class="built_in">size</span>(); <span class="comment">// 得到目前线程池中的线程个数</span>
                    <span class="keyword">if</span> (s &gt; largestPoolSize) <span class="comment">// 如果线程池中的线程个数超过了线程池中的最大线程数时，更新一下这个最大线程数</span>
                        largestPoolSize = s;
                    workerAdded = <span class="keyword">true</span>; <span class="comment">// 标识一下任务已经添加成功</span>
                }
            } <span class="keyword">finally</span> {
                mainLock.unlock(); <span class="comment">// 解锁</span>
            }
            <span class="keyword">if</span> (workerAdded) { <span class="comment">// 如果任务添加成功，运行任务，改变一下任务成功启动标识</span>
                t.start(); <span class="comment">// 启动线程，这里的t是Worker中的thread属性，所以相当于就是调用了Worker的run方法</span>
                workerStarted = <span class="keyword">true</span>;
            }
        }
    } <span class="keyword">finally</span> {
        <span class="keyword">if</span> (! workerStarted) <span class="comment">// 如果任务启动失败，调用addWorkerFailed方法</span>
            addWorkerFailed(w);
    }
    <span class="keyword">return</span> workerStarted;
}
</code></pre><p>Worker中的线程start的时候，调用Worker本身run方法，这个run方法之前分析过，调用外部类ThreadPoolExecutor的runWorker方法，直接看runWorker方法：</p>
<pre><code><span class="keyword">final</span> <span class="keyword">void</span> runWorker(Worker w) {
    Thread wt = Thread.currentThread(); <span class="comment">// 得到当前线程</span>
    Runnable <span class="keyword">task</span> = w.firstTask; <span class="comment">// 得到Worker中的任务task，也就是用户传入的task</span>
    w.firstTask = <span class="keyword">null</span>; <span class="comment">// 将Worker中的任务置空</span>
    w.unlock(); <span class="comment">// allow interrupts。 </span>
    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;
    <span class="keyword">try</span> {
        <span class="comment">// 如果worker中的任务不为空，继续知否，否则使用getTask获得任务。一直死循环，除非得到的任务为空才退出</span>
        <span class="keyword">while</span> (<span class="keyword">task</span> != <span class="keyword">null</span> || (<span class="keyword">task</span> = getTask()) != <span class="keyword">null</span>) {
            w.lock();  <span class="comment">// 如果拿到了任务，给自己上锁，表示当前Worker已经要开始执行任务了，已经不是闲置Worker(闲置Worker的解释请看下面的线程池关闭)</span>
            <span class="comment">// 在执行任务之前先做一些处理。 1. 如果线程池已经处于STOP状态并且当前线程没有被中断，中断线程 2. 如果线程池还处于RUNNING或SHUTDOWN状态，并且当前线程已经被中断了，重新检查一下线程池状态，如果处于STOP状态并且没有被中断，那么中断线程</span>
            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &amp;&amp;
                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
                !wt.isInterrupted())
                wt.interrupt();
            <span class="keyword">try</span> {
                beforeExecute(wt, <span class="keyword">task</span>); <span class="comment">// 任务执行前需要做什么，ThreadPoolExecutor是个空实现</span>
                Throwable thrown = <span class="keyword">null</span>;
                <span class="keyword">try</span> {
                    <span class="keyword">task</span>.run(); <span class="comment">// 真正的开始执行任务，调用的是run方法，而不是start方法。这里run的时候可能会被中断，比如线程池调用了shutdownNow方法</span>
                } <span class="keyword">catch</span> (RuntimeException x) { <span class="comment">// 任务执行发生的异常全部抛出，不在runWorker中处理</span>
                    thrown = x; <span class="keyword">throw</span> x;
                } <span class="keyword">catch</span> (Error x) {
                    thrown = x; <span class="keyword">throw</span> x;
                } <span class="keyword">catch</span> (Throwable x) {
                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);
                } <span class="keyword">finally</span> {
                    afterExecute(<span class="keyword">task</span>, thrown); <span class="comment">// 任务执行结束需要做什么，ThreadPoolExecutor是个空实现</span>
                }
            } <span class="keyword">finally</span> {
                <span class="keyword">task</span> = <span class="keyword">null</span>;
                w.completedTasks++; <span class="comment">// 记录执行任务的个数</span>
                w.unlock(); <span class="comment">// 执行完任务之后，解锁，Worker变成闲置Worker</span>
            }
        }
        completedAbruptly = <span class="keyword">false</span>;
    } <span class="keyword">finally</span> {
        processWorkerExit(w, completedAbruptly); <span class="comment">// 回收Worker方法</span>
    }
}
</code></pre><p>我们看一下getTask方法是如何获得任务的：</p>
<pre><code><span class="comment">// 如果发生了以下四件事中的任意一件，那么Worker需要被回收：</span>
<span class="comment">// 1. Worker个数比线程池最大大小要大</span>
<span class="comment">// 2. 线程池处于STOP状态</span>
<span class="comment">// 3. 线程池处于SHUTDOWN状态并且阻塞队列为空</span>
<span class="comment">// 4. 使用超时时间从阻塞队列里拿数据，并且超时之后没有拿到数据(allowCoreThreadTimeOut || workerCount &gt; corePoolSize)</span>
<span class="keyword">private</span> <span class="function">Runnable <span class="title">getTask</span><span class="params">()</span> </span>{
    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// 如果使用超时时间并且也没有拿到任务的标识</span>

    retry:
    <span class="keyword">for</span> (;;) {
        <span class="keyword">int</span> c = ctl.get();
        <span class="keyword">int</span> rs = runStateOf(c);

        <span class="comment">// 如果线程池是SHUTDOWN状态并且阻塞队列为空的话，worker数量减一，直接返回null(SHUTDOWN状态还会处理阻塞队列任务，但是阻塞队列为空的话就结束了)，如果线程池是STOP状态的话，worker数量建议，直接返回null(STOP状态不处理阻塞队列任务)[方法一开始注释的2，3两点，返回null，开始Worker回收]</span>
        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            <span class="keyword">return</span> <span class="keyword">null</span>;
        }

        <span class="keyword">boolean</span> timed;      <span class="comment">// 标记从队列中取任务时是否设置超时时间，如果为true说明这个worker可能需要回收，为false的话这个worker会一直存在，并且阻塞当前线程等待阻塞队列中有数据</span>

        <span class="keyword">for</span> (;;) {
            <span class="keyword">int</span> wc = workerCountOf(c); <span class="comment">// 得到当前线程池Worker个数</span>
            <span class="comment">// allowCoreThreadTimeOut属性默认为false，表示线程池中的核心线程在闲置状态下还保留在池中；如果是true表示核心线程使用keepAliveTime这个参数来作为超时时间</span>
            <span class="comment">// 如果worker数量比基本大小要大的话，timed就为true，需要进行回收worker</span>
            timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; 

            <span class="keyword">if</span> (wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed)) <span class="comment">// 方法一开始注释的1，4两点，会进行下一步worker数量减一</span>
                <span class="keyword">break</span>;
            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c)) <span class="comment">// worker数量减一，返回null，之后会进行Worker回收工作</span>
                <span class="keyword">return</span> <span class="keyword">null</span>;
            c = ctl.get();  <span class="comment">// 重新检查线程池状态</span>
            <span class="keyword">if</span> (runStateOf(c) != rs) <span class="comment">// 线程池状态改变的话重新开始外部循环，否则继续内部循环</span>
                <span class="keyword">continue</span> retry;
            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span>
        }

        <span class="keyword">try</span> {
            <span class="comment">// 如果需要设置超时时间，使用poll方法，否则使用take方法一直阻塞等待阻塞队列新进数据</span>
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            <span class="keyword">if</span> (r != <span class="keyword">null</span>)
                <span class="keyword">return</span> r;
            timedOut = <span class="keyword">true</span>;
        } <span class="keyword">catch</span> (InterruptedException retry) {
            timedOut = <span class="keyword">false</span>; <span class="comment">// 闲置Worker被中断</span>
        }
    }
}
</code></pre><p>如果getTask返回的是null，那说明阻塞队列已经没有任务并且当前调用getTask的Worker需要被回收，那么会调用processWorkerExit方法进行回收：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">void</span> processWorkerExit(Worker w, <span class="built_in">boolean</span> completedAbruptly) {
    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// 如果Worker没有正常结束流程调用processWorkerExit方法，worker数量减一。如果是正常结束的话，在getTask方法里worker数量已经减一了</span>
        decrementWorkerCount();

    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;
    mainLock.lock(); <span class="comment">// 加锁，防止并发问题</span>
    <span class="keyword">try</span> {
        completedTaskCount += w.completedTasks; <span class="comment">// 记录总的完成任务数</span>
        workers.remove(w); <span class="comment">// 线程池的worker集合删除掉需要回收的Worker</span>
    } <span class="keyword">finally</span> {
        mainLock.unlock(); <span class="comment">// 解锁</span>
    }

    tryTerminate(); <span class="comment">// 尝试结束线程池</span>

    <span class="built_in">int</span> c = ctl.<span class="built_in">get</span>();
    <span class="keyword">if</span> (runStateLessThan(c, STOP)) {  <span class="comment">// 如果线程池还处于RUNNING或者SHUTDOWN状态</span>
        <span class="keyword">if</span> (!completedAbruptly) { <span class="comment">// Worker是正常结束流程的话</span>
            <span class="built_in">int</span> <span class="built_in">min</span> = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;
            <span class="keyword">if</span> (<span class="built_in">min</span> == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())
                <span class="built_in">min</span> = <span class="number">1</span>;
            <span class="keyword">if</span> (workerCountOf(c) &gt;= <span class="built_in">min</span>)
                <span class="keyword">return</span>; <span class="comment">// 不需要新开一个Worker</span>
        }
        <span class="comment">// 新开一个Worker代替原先的Worker</span>
        <span class="comment">// 新开一个Worker需要满足以下3个条件中的任意一个：</span>
        <span class="comment">// 1. 用户执行的任务发生了异常</span>
        <span class="comment">// 2. Worker数量比线程池基本大小要小</span>
        <span class="comment">// 3. 阻塞队列不空但是没有任何Worker在工作</span>
        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);
    }
}
</code></pre><p>在回收Worker的时候线程池会尝试结束自己的运行，tryTerminate方法：</p>
<pre><code><span class="keyword">final</span> void tryTerminate() {
    <span class="keyword">for</span> (;;) {
        int <span class="built_in">c</span> = ctl.<span class="keyword">get</span>();
        <span class="comment">// 满足3个条件中的任意一个，不终止线程池</span>
        <span class="comment">// 1. 线程池还在运行，不能终止</span>
        <span class="comment">// 2. 线程池处于TIDYING或TERMINATED状态，说明已经在关闭了，不允许继续处理</span>
        <span class="comment">// 3. 线程池处于SHUTDOWN状态并且阻塞队列不为空，这时候还需要处理阻塞队列的任务，不能终止线程池</span>
        <span class="keyword">if</span> (isRunning(<span class="built_in">c</span>) ||
            runStateAtLeast(<span class="built_in">c</span>, <span class="type">TIDYING</span>) ||
            (runStateOf(<span class="built_in">c</span>) == <span class="type">SHUTDOWN</span> &amp;&amp; ! workQueue.isEmpty()))
            <span class="keyword">return</span>;
        <span class="comment">// 走到这一步说明线程池已经不在运行，阻塞队列已经没有任务，但是还要回收正在工作的Worker</span>
        <span class="keyword">if</span> (workerCountOf(<span class="built_in">c</span>) != <span class="number">0</span>) {
             <span class="comment">// 由于线程池不运行了，调用了线程池的关闭方法，在解释线程池的关闭原理的时候会说道这个方法</span>
            interruptIdleWorkers(<span class="type">ONLY_ONE</span>); <span class="comment">// 中断闲置Worker，直到回收全部的Worker。这里没有那么暴力，只中断一个，中断之后退出方法，中断了Worker之后，Worker会回收，然后还是会调用tryTerminate方法，如果还有闲置线程，那么继续中断</span>
            <span class="keyword">return</span>;
        }
        <span class="comment">// 走到这里说明worker已经全部回收了，并且线程池已经不在运行，阻塞队列已经没有任务。可以准备结束线程池了</span>
        <span class="keyword">final</span> <span class="type">ReentrantLock</span> mainLock = this.mainLock;
        mainLock.lock(); <span class="comment">// 加锁，防止并发</span>
        <span class="keyword">try</span> {
            <span class="keyword">if</span> (ctl.compareAndSet(<span class="built_in">c</span>, ctlOf(<span class="type">TIDYING</span>, <span class="number">0</span>))) { <span class="comment">// cas操作，将线程池状态改成TIDYING</span>
                <span class="keyword">try</span> {
                    terminated(); <span class="comment">// 调用terminated方法</span>
                } finally {
                    ctl.<span class="keyword">set</span>(ctlOf(<span class="type">TERMINATED</span>, <span class="number">0</span>)); <span class="comment">// terminated方法调用完毕之后，状态变为TERMINATED</span>
                    termination.signalAll();
                }
                <span class="keyword">return</span>;
            }
        } finally {
            mainLock.unlock(); <span class="comment">// 解锁</span>
        }
        <span class="comment">// else retry on failed CAS</span>
    }
}
</code></pre><p>解释了这么多，对线程池的启动并且执行任务做一个总结：</p>
<p>首先，构造线程池的时候，需要一些参数。一些重要的参数解释在 <a href="http://fangjian0423.github.io/2015/07/24/java-poolthread/">java内置的线程池笔记</a> 文章中的结尾已经说明了一下重要参数的意义。</p>
<p>线程池构造完毕之后，如果用户调用了execute或者submit方法的时候，最后都会使用execute方法执行。</p>
<p>execute方法内部分3种情况处理任务：</p>
<ol>
<li>如果当前正在执行的Worker数量比corePoolSize(基本大小)要小。直接创建一个新的Worker执行任务，会调用addWorker方法</li>
<li>如果当前正在执行的Worker数量大于等于corePoolSize(基本大小)。将任务放到阻塞队列里，如果阻塞队列没满并且状态是RUNNING的话，直接丢到阻塞队列，否则执行第3步</li>
<li>丢到阻塞失败的话，会调用addWorker方法尝试起一个新的Worker去阻塞队列拿任务并执行任务，如果这个新的Worker创建失败，调用reject方法</li>
</ol>
<p>线程池中的这个基本大小指的是Worker的数量。一个Worker是一个Runnable的实现类，会被当做一个线程进行启动。Worker内部带有一个Runnable属性firstTask，这个firstTask可以为null，为null的话Worker会去阻塞队列拿任务执行，否则会先执行这个任务，执行完毕之后再去阻塞队列继续拿任务执行。</p>
<p>所以说如果Worker数量超过了基本大小，那么任务都会在阻塞队列里，当Worker执行完了它的第一个任务之后，就会去阻塞队列里拿其他任务继续执行。</p>
<p>Worker在执行的时候会根据一些参数进行调节，比如Worker数量超过了线程池基本大小或者超时时间到了等因素，这个时候Worker会被线程池回收，线程池会尽量保持内部的Worker数量不超过基本大小。</p>
<p>另外Worker执行任务的时候调用的是Runnable的run方法，而不是start方法，调用了start方法就相当于另外再起一个线程了。</p>
<p>Worker在回收的时候会尝试终止线程池。尝试关闭线程池的时候，会检查是否还有Worker在工作，检查线程池的状态，没问题的话会将状态过度到TIDYING状态，之后调用terminated方法，terminated方法调用完成之后将线程池状态更新到TERMINATED。</p>
<h2 id="ThreadPoolExecutor的关闭">ThreadPoolExecutor的关闭</h2><p>线程池的启动过程分析好了之后，接下来看线程池的关闭操作：</p>
<p>shutdown方法，关闭线程池，关闭之后阻塞队列里的任务不受影响，会继续被Worker处理，但是新的任务不会被接受：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>{
    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;
    mainLock.lock(); <span class="comment">// 关闭的时候需要加锁，防止并发</span>
    <span class="keyword">try</span> {
        checkShutdownAccess(); <span class="comment">// 检查关闭线程池的权限</span>
        advanceRunState(SHUTDOWN); <span class="comment">// 把线程池状态更新到SHUTDOWN</span>
        interruptIdleWorkers(); <span class="comment">// 中断闲置的Worker</span>
        onShutdown(); <span class="comment">// 钩子方法，默认不处理。ScheduledThreadPoolExecutor会做一些处理</span>
    } <span class="keyword">finally</span> {
        mainLock.unlock(); <span class="comment">// 解锁</span>
    }
    tryTerminate(); <span class="comment">// 尝试结束线程池，上面已经分析过了</span>
}
</code></pre><p>interruptIdleWorkers方法，注意，这个方法打断的是闲置Worker，打断闲置Worker之后，getTask方法会返回null，然后Worker会被回收。那什么是闲置Worker呢？</p>
<p>闲置Worker是这样解释的：Worker运行的时候会去阻塞队列拿数据(getTask方法)，拿的时候如果没有设置超时时间，那么会一直阻塞等待阻塞队列进数据，这样的Worker就被称为闲置Worker。由于Worker也是一个AQS，在runWorker方法里会有一对lock和unlock操作，这对lock操作是为了确保Worker不是一个闲置Worker。</p>
<p>所以Worker被设计成一个AQS是为了根据Worker的锁来判断是否是闲置线程，是否可以被强制中断。</p>
<p>下面我们看下interruptIdleWorkers方法：</p>
<pre><code><span class="comment">// 调用他的一个重载方法，传入了参数false，表示要中断所有的正在运行的闲置Worker，如果为true表示只打断一个闲置Worker</span>
<span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>{
    interruptIdleWorkers(<span class="keyword">false</span>);
}

<span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>{
    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;
    mainLock.lock(); <span class="comment">// 中断闲置Worker需要加锁，防止并发</span>
    <span class="keyword">try</span> {
        <span class="keyword">for</span> (Worker w : workers) { 
            Thread t = w.thread; <span class="comment">// 拿到worker中的线程</span>
            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) { <span class="comment">// Worker中的线程没有被打断并且Worker可以获取锁，这里Worker能获取锁说明Worker是个闲置Worker，在阻塞队列里拿数据一直被阻塞，没有数据进来。如果没有获取到Worker锁，说明Worker还在执行任务，不进行中断(shutdown方法不会中断正在执行的任务)</span>
                <span class="keyword">try</span> {
                    t.interrupt();  <span class="comment">// 中断Worker线程</span>
                } <span class="keyword">catch</span> (SecurityException ignore) {
                } <span class="keyword">finally</span> {
                    w.unlock(); <span class="comment">// 释放Worker锁</span>
                }
            }
            <span class="keyword">if</span> (onlyOne) <span class="comment">// 如果只打断1个Worker的话，直接break退出，否则，遍历所有的Worker</span>
                <span class="keyword">break</span>;
        }
    } <span class="keyword">finally</span> {
        mainLock.unlock(); <span class="comment">// 解锁</span>
    }
}
</code></pre><p>shutdown方法将线程池状态改成SHUTDOWN，线程池还能继续处理阻塞队列里的任务，并且会回收一些闲置的Worker。但是shutdownNow方法不一样，它会把线程池状态改成STOP状态，这样不会处理阻塞队列里的任务，也不会处理新的任务：</p>
<pre><code><span class="comment">// shutdownNow方法会有返回值的，返回的是一个任务列表，而shutdown方法没有返回值</span>
<span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span>(<span class="params"></span>) </span>{
    List&lt;Runnable&gt; tasks;
    final ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;
    mainLock.<span class="keyword">lock</span>(); <span class="comment">// shutdownNow操作也需要加锁，防止并发</span>
    <span class="keyword">try</span> {
        checkShutdownAccess(); <span class="comment">// 检查关闭线程池的权限</span>
        advanceRunState(STOP); <span class="comment">// 把线程池状态更新到STOP</span>
        interruptWorkers(); <span class="comment">// 中断Worker的运行</span>
        tasks = drainQueue();
    } <span class="keyword">finally</span> {
        mainLock.unlock(); <span class="comment">// 解锁</span>
    }
    tryTerminate(); <span class="comment">// 尝试结束线程池，上面已经分析过了</span>
    <span class="keyword">return</span> tasks;
}
</code></pre><p>shutdownNow的中断和shutdown方法不一样，调用的是interruptWorkers方法：</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>{
    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;
    mainLock.lock(); <span class="comment">// 中断Worker需要加锁，防止并发</span>
    <span class="keyword">try</span> {
        <span class="keyword">for</span> (Worker w : workers)
            w.interruptIfStarted(); <span class="comment">// 中断Worker的执行</span>
    } <span class="keyword">finally</span> {
        mainLock.unlock(); <span class="comment">// 解锁</span>
    }
}
</code></pre><p>Worker的interruptIfStarted方法中断Worker的执行：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>{
   Thread t;
   <span class="comment">// Worker无论是否被持有锁，只要还没被中断，那就中断Worker</span>
   <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) {
       <span class="keyword">try</span> {
           t.interrupt(); <span class="comment">// 强行中断Worker的执行</span>
       } <span class="keyword">catch</span> (SecurityException ignore) {
       }
   }
}
</code></pre><p>线程池关闭总结：    </p>
<p>线程池的关闭主要是两个方法，shutdown和shutdownNow方法。</p>
<p>shutdown方法会更新状态到SHUTDOWN，不会影响阻塞队列里任务的执行，但是不会执行新进来的任务。同时也会回收闲置的Worker，闲置Worker的定义上面已经说过了。</p>
<p>shutdownNow方法会更新状态到STOP，会影响阻塞队列的任务执行，也不会执行新进来的任务。同时会回收所有的Worker。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ThreadPoolExecutor是jdk内置线程池的一个实现，基本上大部分情况都会使用这个线程池完成各项操作。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/thread-pool.jpeg" alt=""></p>]]>
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="thread" scheme="http://fangjian0423.github.io/tags/thread/"/>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java可重入锁ReentrantLock分析]]></title>
    <link href="http://fangjian0423.github.io/2016/03/19/java-ReentrantLock-analysis/"/>
    <id>http://fangjian0423.github.io/2016/03/19/java-ReentrantLock-analysis/</id>
    <published>2016-03-19T06:31:58.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/ReentrantLock.png" alt=""><br>Java中的可重入锁ReentrantLock很常见，可以用它来代替内置锁synchronized，ReentrantLock是语法级别的锁，所以比内置锁更加灵活。</p>
<a id="more"></a>
<p>下面这段代码是ReentrantLock的一个例子：</p>
<pre><code><span class="keyword">class</span> <span class="title">Context</span> {
    <span class="keyword">private</span> ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span>(<span class="params"></span>) </span>{
        <span class="keyword">lock</span>.<span class="keyword">lock</span>();
        System.<span class="keyword">out</span>.println(<span class="string">"do atomic operation"</span>);
        <span class="keyword">try</span> {
            Thread.sleep(<span class="number">3000</span>l);
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        } <span class="keyword">finally</span> {
            <span class="keyword">lock</span>.unlock();
        }
    }
}

<span class="keyword">class</span> <span class="title">MyThread</span> <span class="title">implements</span> <span class="title">Runnable</span> {
    <span class="keyword">private</span> Context context;
    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span>(<span class="params">Context context</span>) </span>{
        <span class="keyword">this</span>.context = context;
    }
    @<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>{
        context.method();
    }
}
</code></pre><p>main方法：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
    Context context = <span class="keyword">new</span> Context();
    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ ) {
        executorService.submit(<span class="keyword">new</span> MyThread(context));
    }
}
</code></pre><p>输出结果，每隔3秒输出：</p>
<pre><code><span class="keyword">do</span> atomic operation   
</code></pre><p>如果没有使用可重入锁的话，那么一次性输出5条 do atomic operation。</p>
<p>ReentrantLock中有3个内部类，分别是Sync、FairSync和NonfairSync。</p>
<p>Sync是一个继承AQS的抽象类，使用独占锁，复写了tryRelease方法。tryAcquire方法由它的两个FairSync(公平锁)和NonfairSync(非公平锁)实现。</p>
<p>AQS相关的内容可以参考文章末尾的参考资料，这篇文章写得非常棒。</p>
<p>ReentrantLock的lock方法使用sync的lock方法，Sync的lock方法是个抽象方法，由公平锁和非公平锁去实现。unlock方法直接使用AQS的release方法。所以说公平锁和非公平锁的释放锁过程是一样的，不一样的是获取锁过程。</p>
<p>先来看一下unlock方法，unlock方法调用的AQS的release方法，也就是调用了tryRelease方法，tryRelease方法调完之后恢复第一个挂起的线程：</p>
<pre><code><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>{
    <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 释放</span>
    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">// 如果当前线程不是独占线程，直接抛出异常</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();
    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;
    <span class="keyword">if</span> (c == <span class="number">0</span>) { <span class="comment">// 由于是可重入锁，需要判断是否全部释放了</span>
        free = <span class="keyword">true</span>;
        setExclusiveOwnerThread(<span class="keyword">null</span>); <span class="comment">// 全部释放的话直接把独占线程设置为null</span>
    }
    setState(c);
    <span class="keyword">return</span> free;
}

<span class="comment">// 恢复线程</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{
    <span class="keyword">if</span> (tryRelease(arg)) {
        Node h = head;  <span class="comment">// 恢复第一个挂起的线程</span>
        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)
            unparkSuccessor(h);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><p>ReentrantLock的lock方法就是获取锁的方法，AQS中线程对锁的的竞争结果只有两种，要么获取到了锁；要么没有获取到锁，没有获取的锁线程被挂起等待被唤醒。</p>
<p>公平锁FairSync的lock方法：</p>
<pre><code><span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{
    <span class="comment">// acquire方法内部调用tryAcquire方法</span>
    <span class="comment">// 公平锁的获取锁方法，对于没有获取到的线程，会按照队列的方式挂起线程</span>
    acquire(<span class="number">1</span>);
}

<span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{
    <span class="keyword">final</span> Thread current = Thread.currentThread();
    <span class="keyword">int</span> c = getState();
    <span class="keyword">if</span> (c == <span class="number">0</span>) {
        <span class="comment">// 公平锁这里多了一个!hasQueuedPredecessors()判断，表示是否有线程在队列里等待的时间比当前线程要长，如果有等待时间更长的线程，那么放弃获取锁</span>
        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;
            compareAndSetState(<span class="number">0</span>, acquires)) {
            setExclusiveOwnerThread(current);
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {
        <span class="keyword">int</span> nextc = c + acquires;
        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);
        setState(nextc);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><p>非公平锁NonfairSync的lock方法：</p>
<pre><code><span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{
    <span class="comment">// 非公平锁的获取锁</span>
    <span class="comment">// 跟公平锁的区别就在这里。直接对状态位state进行cas操作，成功就获取锁，这是一种抢占式的方式。不成功跟公平锁一样进入队列挂起线程</span>
    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))
        setExclusiveOwnerThread(Thread.currentThread());
    <span class="keyword">else</span>
        acquire(<span class="number">1</span>);
}

<span class="comment">// 调用Sync的nonfairTryAcquire方法</span>
<span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{
    <span class="function"><span class="keyword">return</span> <span class="title">nonfairTryAcquire</span><span class="params">(acquires)</span></span>;
}

<span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{
    <span class="keyword">final</span> Thread current = Thread.currentThread();
    <span class="keyword">int</span> c = getState();
    <span class="keyword">if</span> (c == <span class="number">0</span>) {
        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) {
            setExclusiveOwnerThread(current);
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {
        <span class="keyword">int</span> nextc = c + acquires;
        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);
        setState(nextc);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><p>如上述源码和注释所说，公平锁和非公平锁的最主要区别就是获取锁的方式不一样。</p>
<p>公平锁获取锁的时候，首先先读取状态位state，然后再做判断，之后使用cas设置状态位。能获取锁的线程就获取锁，不能获取锁的线程被挂起进入队列。之后再来的线程的等待时间没有已经在队列里的线程等待时间长，所以会一直进入等待队列。 公平锁类似于排队买火车票一样，后面来的人没有前面来的人等待时间长，会一直在队尾被加入到队列里。</p>
<p>非公平锁获取锁的时候，立马就使用cas判断设置状态位，是一种抢占式的方式。同时非公平锁也没有等待时间长的线程会优先获取锁这个概念。非公平锁类似吃饭排队，但是总会有那么几个人试图插队。</p>
<p>公平锁和非公平锁的还有另外一个差别，前面已经分析过了。就是公平锁获取锁多了一个判断条件，当前线程的等待时间没有队列里的线程等待时间长的话，不能获取锁；而非公平锁没有这个条件。</p>
<p>ReentrantLock的默认构造函数使用的是NonfairSync，如果想使用FairSync，使用带有boolean参数的构造函数，传入true表示FairSync，否则是NonfairSync。</p>
<p>ReentrantLock内部还提供了一些有用的方法：</p>
<p>hasQueuedThreads： 查询是否有线程在等待队列里<br>hasQueuedThread(Thread thread)：查询线程是否在等待队列里<br>isHeldByCurrentThread：当前线程是否持有锁<br>getQueueLength：队列中的挂起线程个数</p>
<p>等等还有其他的一些有用方法。</p>
<p>总结：</p>
<p>ReentrantLock可重入锁内部有3个类，Sync、FairSync和NonfairSync。</p>
<p>Sync是一个继承AQS的抽象类，并发的控制就是通过Sync实现的(当然是使用AQS实现的，AQS是Java并发包的一个同步基础类)，它复写了tryRelease方法，它有2个子类FairSync和NonfairSync，也就是公平锁和非公平锁。</p>
<p>由于Sync复写了tryRelease方法，它的2个子类公平锁和非公平锁没有再次复写这个方法，所以公平锁和非公平锁的释放锁操作是一样的，释放锁也就是唤醒等待队列中的第一个被挂起的线程。</p>
<p>虽然公平锁和非公平锁的释放锁方式一样，但是它们的获取锁方式不一样，公平锁获取锁的时候，如果1个线程获取到了锁，其他线程都会被挂起并且进入等待队列，后面来的线程的等待时间没有队列里的线程等待时间长的话，那么就放弃获取锁，进入等待队列。非公平锁获取锁的方式是一种抢占式的方式，不考虑等待时间的问题，无论哪个线程获取到了锁，其他线程就进入等待队列。</p>
<p>参考资料：</p>
<p><a href="http://ifeve.com/jdk1-8-abstractqueuedsynchronizer/" target="_blank" rel="external">http://ifeve.com/jdk1-8-abstractqueuedsynchronizer/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/ReentrantLock.png" alt=""><br>Java中的可重入锁ReentrantLock很常见，可以用它来代替内置锁synchronized，ReentrantLock是语法级别的锁，所以比内置锁更加灵活。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="thread" scheme="http://fangjian0423.github.io/tags/thread/"/>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java AtomicInteger原理分析]]></title>
    <link href="http://fangjian0423.github.io/2016/03/16/java-AtomicInteger-analysis/"/>
    <id>http://fangjian0423.github.io/2016/03/16/java-AtomicInteger-analysis/</id>
    <published>2016-03-16T12:32:35.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>Java中的AtomicInteger大家应该很熟悉，它是为了解决多线程访问Integer变量导致结果不正确所设计的一个基于多线程并且支持原子操作的Integer类。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/java-AtomicInteger-analysis.jpeg" alt=""></p>
<a id="more"></a>
<p>它的使用也非常简单：</p>
<pre><code>AtomicInteger ai = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);
ai.addAndGet(<span class="number">5</span>); <span class="comment">// 5</span>
ai.getAndAdd(<span class="number">1</span>); <span class="comment">// 5</span>
ai.get(); <span class="comment">// 6</span>
</code></pre><p>AtomicInteger内部有一个变量UnSafe：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Unsafe</span> <span class="keyword">unsafe</span> = <span class="keyword">Unsafe</span>.getUnsafe();
</code></pre><p>Unsafe类是一个可以执行不安全、容易犯错的操作的一个特殊类。虽然Unsafe类中所有方法都是public的，但是这个类只能在一些被信任的代码中使用。Unsafe的源码可以在这里看 -&gt; <a href="http://www.docjar.com/html/api/sun/misc/Unsafe.java.html" target="_blank" rel="external">UnSafe源码</a>。</p>
<p>Unsafe类可以执行以下几种操作：</p>
<ol>
<li>分配内存，释放内存：在方法allocateMemory，reallocateMemory，freeMemory中，有点类似c中的malloc，free方法</li>
<li>可以定位对象的属性在内存中的位置，可以修改对象的属性值。使用objectFieldOffset方法</li>
<li>挂起和恢复线程，被封装在LockSupport类中供使用</li>
<li>CAS操作(CompareAndSwap，比较并交换，是一个原子操作)</li>
</ol>
<p>AtomicInteger中用的就是Unsafe的CAS操作。</p>
<p>Unsafe中的int类型的CAS操作方法：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,
                                                <span class="keyword">int</span> expected,
                                                <span class="keyword">int</span> x)</span></span>;
</code></pre><p>参数o就是要进行cas操作的对象，offset参数是内存位置，expected参数就是期望的值，x参数是需要更新到的值。</p>
<p>也就是说，如果我把1这个数字属性更新到2的话，需要这样调用：</p>
<pre><code>compareAndSwapInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>, <span class="number">2</span>)
</code></pre><p>valueOffset字段表示内存位置，可以在AtomicInteger对象中使用unsafe得到：</p>
<pre><code><span class="keyword">static</span> {
  <span class="keyword">try</span> {
    valueOffset = unsafe.objectFieldOffset
        (AtomicInteger.<span class="keyword">class</span>.getDeclaredField(<span class="string">"value"</span>));
  } <span class="keyword">catch</span> (Exception ex) { <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); }
}
</code></pre><p>AtomicInteger内部使用变量value表示当前的整型值，这个整型变量还是volatile的，表示内存可见性，一个线程修改value之后保证对其他线程的可见性：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> <span class="keyword">value</span>;
</code></pre><p>AtomicInteger内部还封装了一下CAS，定义了一个compareAndSet方法，只需要2个参数：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>{
    <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, valueOffset, expect, update)</span></span>;
}
</code></pre><p>addAndGet方法，addAndGet方法内部使用一个死循环，先得到当前的值value，然后再把当前的值加一，加完之后使用cas原子操作让当前值加一处理正确。当然cas原子操作不一定是成功的，所以做了一个死循环，当cas操作成功的时候返回数据。这里由于使用了cas原子操作，所以不会出现多线程处理错误的问题。比如线程A得到current为1，线程B也得到current为1；线程A的next值为2，进行cas操作并且成功的时候，将value修改成了2；这个时候线程B也得到next值为2，当进行cas操作的时候由于expected值已经是2，而不是1了；所以cas操作会失败，下一次循环的时候得到的current就变成了2；也就不会出现多线程处理问题了：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> addAndGet(<span class="keyword">int</span> delta) {
    <span class="keyword">for</span> (;;) {
        <span class="keyword">int</span> current = get();
        <span class="keyword">int</span> <span class="keyword">next</span> = current + delta;
        <span class="keyword">if</span> (compareAndSet(current, <span class="keyword">next</span>))
            <span class="keyword">return</span> <span class="keyword">next</span>;
    }
}
</code></pre><p>incrementAndGet方法，跟addAndGet方法类似，只不过next值变成了current+1：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> incrementAndGet() {
    <span class="keyword">for</span> (;;) {
        <span class="keyword">int</span> current = get();
        <span class="keyword">int</span> <span class="keyword">next</span> = current + <span class="number">1</span>;
        <span class="keyword">if</span> (compareAndSet(current, <span class="keyword">next</span>))
            <span class="keyword">return</span> <span class="keyword">next</span>;
    }
}
</code></pre><p>getAndAdd方法，跟addAndGet方法一样，返回值变成了current：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> getAndAdd(<span class="keyword">int</span> delta) {
    <span class="keyword">for</span> (;;) {
        <span class="keyword">int</span> current = get();
        <span class="keyword">int</span> <span class="keyword">next</span> = current + delta;
        <span class="keyword">if</span> (compareAndSet(current, <span class="keyword">next</span>))
            <span class="keyword">return</span> current;
    }
}
</code></pre><p>缺点：</p>
<p>虽然AtomicInteger中的cas操作可以实现非阻塞的原子操作，但是会产生ABA问题，</p>
<p>参考资料：</p>
<p><a href="http://blog.csdn.net/ghsau/article/details/38471987" target="_blank" rel="external">http://blog.csdn.net/ghsau/article/details/38471987</a></p>
<p><a href="http://blog.csdn.net/aesop_wubo/article/details/7537278" target="_blank" rel="external">http://blog.csdn.net/aesop_wubo/article/details/7537278</a></p>
<p><a href="http://ifeve.com/sun-misc-unsafe/" target="_blank" rel="external">http://ifeve.com/sun-misc-unsafe/</a></p>
<p><a href="http://ifeve.com/java-atomic/" target="_blank" rel="external">http://ifeve.com/java-atomic/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java中的AtomicInteger大家应该很熟悉，它是为了解决多线程访问Integer变量导致结果不正确所设计的一个基于多线程并且支持原子操作的Integer类。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/java-AtomicInteger-analysis.jpeg" alt=""></p>]]>
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java根类Object的方法说明]]></title>
    <link href="http://fangjian0423.github.io/2016/03/12/java-Object-method/"/>
    <id>http://fangjian0423.github.io/2016/03/12/java-Object-method/</id>
    <published>2016-03-12T09:44:59.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>Java中的Object类是所有类的父类，它提供了以下11个方法：</p>
<ol>
<li>public final native Class&lt;?&gt; getClass()</li>
<li>public native int hashCode()</li>
<li>public boolean equals(Object obj)</li>
<li>protected native Object clone() throws CloneNotSupportedException</li>
<li>public String toString()</li>
<li>public final native void notify()</li>
<li>public final native void notifyAll()</li>
<li>public final native void wait(long timeout) throws InterruptedException</li>
<li>public final void wait(long timeout, int nanos) throws InterruptedException </li>
<li>public final void wait() throws InterruptedException</li>
<li>protected void finalize() throws Throwable { }</li>
</ol>
<p>下面我们一个个方法进行分析，看这些方法到底有什么作用：</p>
<h3 id="getClass方法">getClass方法</h3><p>getClass方法是一个final方法，不允许子类重写，并且也是一个native方法。</p>
<p>返回当前运行时对象的Class对象，注意这里是运行时，比如以下代码中n是一个Number类型的实例，但是java中数值默认是Integer类型，所以getClass方法返回的是java.lang.Integer：</p>
<pre><code><span class="string">"str"</span>.getClass() // <span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span>
<span class="string">"str"</span>.getClass == String.class // <span class="literal">true</span>
Number n = <span class="number">0</span>;
<span class="class"><span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> <span class="title">Number</span>&gt; <span class="title">c</span> = <span class="title">n</span>.<span class="title">getClass</span>(); // <span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Integer</span></span>
</code></pre><h3 id="hashCode方法">hashCode方法</h3><p>hashCode方法也是一个native方法。</p>
<p>该方法返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</p>
<p>哈希码的通用约定如下：</p>
<ol>
<li>在java程序执行过程中，在一个对象没有被改变的前提下，无论这个对象被调用多少次，hashCode方法都会返回相同的整数值。对象的哈希码没有必要在不同的程序中保持相同的值。</li>
<li>如果2个对象使用equals方法进行比较并且相同的话，那么这2个对象的hashCode方法的值也必须相等。</li>
<li>如果根据equals方法，得到两个对象不相等，那么这2个对象的hashCode值不需要必须不相同。但是，不相等的对象的hashCode值不同的话可以提高哈希表的性能。</li>
</ol>
<p>通常情况下，不同的对象产生的哈希码是不同的。默认情况下，对象的哈希码是通过将该对象的内部地址转换成一个整数来实现的。</p>
<p>String的hashCode方法实现如下， 计算方法是 s[0]<em>31^(n-1) + s[1]</em>31^(n-2) + … + s[n-1]，其中s[0]表示字符串的第一个字符，n表示字符串长度：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{
    <span class="keyword">int</span> h = hash;
    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) {
        <span class="keyword">char</span> val[] = value;

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) {
            h = <span class="number">31</span> * h + val[i];
        }
        hash = h;
    }
    <span class="keyword">return</span> h;
}
</code></pre><p>比如”fo”的hashCode = 102 <em> 31^1 + 111 = 3273， “foo”的hashCode = 102 </em> 31^2 + 111 * 31^1 + 111 = 101574 (‘f’的ascii码为102, ‘o’的ascii码为111)</p>
<p>hashCode在哈希表HashMap中的应用：</p>
<pre><code><span class="comment">// Student类，只重写了hashCode方法</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> Student {

    <span class="keyword">private</span> String name;
    <span class="keyword">private</span> <span class="keyword">int</span> age;

    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>{
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.age = age;
    }

    @<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> name.hashCode();
    }
}

Map&lt;Student, String&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;Student, String&gt;();
Student stu1 = <span class="keyword">new</span> Student(<span class="string">"fo"</span>, <span class="number">11</span>);
Student stu2 = <span class="keyword">new</span> Student(<span class="string">"fo"</span>, <span class="number">22</span>);
<span class="built_in">map</span>.put(stu1, <span class="string">"fo"</span>);
<span class="built_in">map</span>.put(stu2, <span class="string">"fo"</span>);
</code></pre><p>上面这段代码中，map中有2个元素stu1和stu2。但是这2个元素是在哈希表中的同一个数组项中的位置，也就是在同一串链表中。 但是为什么stu1和stu2的hashCode相同，但是两条元素都插到map里了，这是因为map判断重复数据的条件是 <strong>两个对象的哈希码相同并且(两个对象是同一个对象或者两个对象相等[equals为true])</strong>。 所以再给Student重写equals方法，并且只比较name的话，这样map就只有1个元素了。</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>{
    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;
    Student student = (Student) o;
    <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(student.name);
}
</code></pre><p>这个例子直接说明了hashCode中通用约定的第三点：</p>
<p>第三点：如果根据equals方法，得到两个对象不相等，那么这2个对象的hashCode值不需要必须不相同。但是，不相等的对象的hashCode值不同的话可以提高哈希表的性能。 –&gt; 上面例子一开始没有重写equals方法，导致两个对象不相等，但是这两个对象的hashCode值一样，所以导致这两个对象在同一串链表中，影响性能。</p>
<p>当然，还有第三种情况，那就是equals方法相等，但是hashCode的值不相等。</p>
<p>这种情况也就是违反了通用约定的第二点：</p>
<p>第二点：<strong>如果2个对象使用equals方法进行比较并且相同的话，那么这2个对象的hashCode方法的值也必须相等。</strong> 违反这一点产生的后果就是如果一个stu1实例是Student(“fo”, 11)，stu2实例是Student(“fo”, 11)，那么这2个实例是相等的，但是他们的hashCode不一样，这样是导致哈希表中都会存入stu1实例和stu2实例，但是实际情况下，stu1和stu2是重复数据，只允许存在一条数据在哈希表中。所以这一点是非常重点的，再强调一下：<strong>如果2个对象的equals方法相等，那么他们的hashCode值也必须相等，反之，如果2个对象hashCode值相等，但是equals不相等，这样会影响性能，所以还是建议2个方法都一起重写。</strong></p>
<h3 id="equals方法">equals方法</h3><p>比较两个对象是否相等。Object类的默认实现，即比较2个对象的内存地址是否相等：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>{
    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);
}
</code></pre><p>equals方法在非空对象引用上的特性：</p>
<ol>
<li>reflexive，自反性。任何非空引用值x，对于x.equals(x)必须返回true</li>
<li>symmetric，对称性。任何非空引用值x和y，如果x.equals(y)为true，那么y.equals(x)也必须为true</li>
<li>transitive，传递性。任何非空引用值x、y和z，如果x.equals(y)为true并且y.equals(z)为true，那么x.equals(z)也必定为true</li>
<li>consistent，一致性。任何非空引用值x和y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改</li>
<li>对于任何非空引用值 x，x.equals(null) 都应返回 false</li>
</ol>
<p>Object类的equals方法对于任何非空引用值x和y，当x和y引用同一个对象时，此方法才返回true。这个也就是我们常说的地址相等。</p>
<p>注意点：如果重写了equals方法，通常有必要重写hashCode方法，这点已经在hashCode方法中说明了。</p>
<h3 id="clone方法">clone方法</h3><p>创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 也为true。</p>
<p>Object类的clone方法是一个protected的native方法。</p>
<p>由于Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</p>
<h3 id="toString方法">toString方法</h3><p>Object对象的默认实现，即输出类的名字@实例的哈希码的16进制：</p>
<pre><code><span class="keyword">public</span> <span class="built_in">String</span> toString() {
    <span class="keyword">return</span> getClass()<span class="built_in">.</span>getName() + <span class="string">"@"</span> + <span class="built_in">Integer</span><span class="built_in">.</span>toHexString(hashCode());
}
</code></pre><p>toString方法的结果应该是一个简明但易于读懂的字符串。建议Object所有的子类都重写这个方法。</p>
<h3 id="notify方法">notify方法</h3><p>notify方法是一个native方法，并且也是final的，不允许子类重写。</p>
<p>唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果所有的线程都在此对象上等待，那么只会选择一个线程。选择是任意性的，并在对实现做出决定时发生。一个线程在对象监视器上等待可以调用wait方法。</p>
<p>直到当前线程放弃对象上的锁之后，被唤醒的线程才可以继续处理。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。</p>
<p>notify方法只能被作为此对象监视器的所有者的线程来调用。一个线程要想成为对象监视器的所有者，可以使用以下3种方法：</p>
<ol>
<li>执行对象的同步实例方法</li>
<li>使用synchronized内置锁</li>
<li>对于Class类型的对象，执行同步静态方法</li>
</ol>
<p>一次只能有一个线程拥有对象的监视器。</p>
<p>如果当前线程不是此对象监视器的所有者的话会抛出IllegalMonitorStateException异常</p>
<p>注意点：</p>
<p><strong>因为notify只能在拥有对象监视器的所有者线程中调用，否则会抛出IllegalMonitorStateException异常</strong></p>
<h3 id="notifyAll方法">notifyAll方法</h3><p>跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</p>
<p>同样，如果当前线程不是对象监视器的所有者，那么调用notifyAll同样会发生IllegalMonitorStateException异常。</p>
<p>以下这段代码直接调用notify或者notifyAll方法会发生IllegalMonitorStateException异常，这是因为调用这两个方法需要当前线程是对象监视器的所有者：</p>
<pre><code>Factory <span class="literal">factory</span> = <span class="keyword">new</span> Factory();
<span class="literal">factory</span>.notify();
<span class="literal">factory</span>.notifyAll();
</code></pre><h3 id="wait(long_timeout)_throws_InterruptedException方法">wait(long timeout) throws InterruptedException方法</h3><p>wait(long timeout)方法同样是一个native方法，并且也是final的，不允许子类重写。</p>
<p>wait方法会让当前线程等待直到另外一个线程调用对象的notify或notifyAll方法，或者超过参数设置的timeout超时时间。</p>
<p><strong>跟notify和notifyAll方法一样，当前线程必须是此对象的监视器所有者，否则还是会发生IllegalMonitorStateException异常。</strong></p>
<p>wait方法会让当前线程(我们先叫做线程T)将其自身放置在对象的等待集中，并且放弃该对象上的所有同步要求。出于线程调度目的，线程T是不可用并处于休眠状态，直到发生以下四件事中的任意一件：</p>
<ol>
<li>其他某个线程调用此对象的notify方法，并且线程T碰巧被任选为被唤醒的线程</li>
<li>其他某个线程调用此对象的notifyAll方法</li>
<li>其他某个线程调用Thread.interrupt方法中断线程T</li>
<li>时间到了参数设置的超时时间。如果timeout参数为0，则不会超时，会一直进行等待</li>
</ol>
<p>所以可以理解wait方法相当于放弃了当前线程对对象监视器的所有者(也就是说释放了对象的锁)</p>
<p>之后，线程T会被等待集中被移除，并且重新进行线程调度。然后，该线程以常规方式与其他线程竞争，以获得在该对象上同步的权利；一旦获得对该对象的控制权，该对象上的所有其同步声明都将被恢复到以前的状态，这就是调用wait方法时的情况。然后，线程T从wait方法的调用中返回。所以，从wait方法返回时，该对象和线程T的同步状态与调用wait方法时的情况完全相同。</p>
<p>在没有被通知、中断或超时的情况下，线程还可以唤醒一个所谓的虚假唤醒 (spurious wakeup)。虽然这种情况在实践中很少发生，但是应用程序必须通过以下方式防止其发生，即对应该导致该线程被提醒的条件进行测试，如果不满足该条件，则继续等待。换句话说，等待应总是发生在循环中，如下面的示例：</p>
<pre><code><span class="keyword">synchronized</span> (obj) {
    <span class="keyword">while</span> (&lt;condition does not hold&gt;)
        obj.wait(timeout);
        ... <span class="comment">// Perform action appropriate to condition</span>
}
</code></pre><p>如果当前线程在等待之前或在等待时被任何线程中断，则会抛出InterruptedException异常。在按上述形式恢复此对象的锁定状态时才会抛出此异常。</p>
<h3 id="wait(long_timeout,_int_nanos)_throws_InterruptedException方法">wait(long timeout, int nanos) throws InterruptedException方法</h3><p>跟wait(long timeout)方法类似，多了一个nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</p>
<p>需要注意的是 wait(0, 0)和wait(0)效果是一样的，即一直等待。</p>
<h3 id="wait()_throws_InterruptedException方法">wait() throws InterruptedException方法</h3><p>跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念。</p>
<p>以下这段代码直接调用wait方法会发生IllegalMonitorStateException异常，这是因为调用wait方法需要当前线程是对象监视器的所有者：</p>
<pre><code>Factory <span class="literal">factory</span> = <span class="keyword">new</span> Factory();
<span class="literal">factory</span>.wait();
</code></pre><p>一般情况下，wait方法和notify方法会一起使用的，wait方法阻塞当前线程，notify方法唤醒当前线程，一个使用wait和notify方法的生产者消费者例子代码如下：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyTest</span> </span>{

    public <span class="literal">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) {
        Factory <span class="literal">factory</span> = <span class="keyword">new</span> Factory();
        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(<span class="literal">factory</span>, <span class="number">5</span>)).start();
        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(<span class="literal">factory</span>, <span class="number">5</span>)).start();
        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(<span class="literal">factory</span>, <span class="number">20</span>)).start();
        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(<span class="literal">factory</span>, <span class="number">30</span>)).start();
        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(<span class="literal">factory</span>, <span class="number">10</span>)).start();
        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(<span class="literal">factory</span>, <span class="number">20</span>)).start();
        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(<span class="literal">factory</span>, <span class="number">5</span>)).start();
        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(<span class="literal">factory</span>, <span class="number">5</span>)).start();
        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(<span class="literal">factory</span>, <span class="number">20</span>)).start();
    }

}

<span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>{

    public <span class="literal">static</span> <span class="keyword">final</span> Integer MAX_NUM = <span class="number">50</span>;

    private <span class="built_in">int</span> currentNum = <span class="number">0</span>;

    public <span class="keyword">void</span> consume(<span class="built_in">int</span> <span class="built_in">num</span>) throws InterruptedException {
        synchronized (<span class="keyword">this</span>) {
            <span class="keyword">while</span>(currentNum - <span class="built_in">num</span> &lt; <span class="number">0</span>) {
                <span class="keyword">this</span>.wait();
            }
            currentNum -= <span class="built_in">num</span>;
            System.out.println(<span class="string">"consume "</span> + <span class="built_in">num</span> + <span class="string">", left: "</span> + currentNum);
            <span class="keyword">this</span>.notifyAll();
        }
    }

    public <span class="keyword">void</span> produce(<span class="built_in">int</span> <span class="built_in">num</span>) throws InterruptedException {
        synchronized (<span class="keyword">this</span>) {
            <span class="keyword">while</span>(currentNum + <span class="built_in">num</span> &gt; MAX_NUM) {
                <span class="keyword">this</span>.wait();
            }
            currentNum += <span class="built_in">num</span>;
            System.out.println(<span class="string">"produce "</span> + <span class="built_in">num</span> + <span class="string">", left: "</span> + currentNum);
            <span class="keyword">this</span>.notifyAll();
        }
    }

}

<span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
    private Factory <span class="literal">factory</span>;
    private <span class="built_in">int</span> <span class="built_in">num</span>;
    public Producer(Factory <span class="literal">factory</span>, <span class="built_in">int</span> <span class="built_in">num</span>) {
        <span class="keyword">this</span>.<span class="literal">factory</span> = <span class="literal">factory</span>;
        <span class="keyword">this</span>.<span class="built_in">num</span> = <span class="built_in">num</span>;
    }
    <span class="annotation">@Override</span>
    public <span class="keyword">void</span> run() {
        <span class="keyword">try</span> {
            <span class="literal">factory</span>.produce(<span class="built_in">num</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
    }
}


<span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
    private Factory <span class="literal">factory</span>;
    private <span class="built_in">int</span> <span class="built_in">num</span>;
    public Consumer(Factory <span class="literal">factory</span>, <span class="built_in">int</span> <span class="built_in">num</span>) {
        <span class="keyword">this</span>.<span class="literal">factory</span> = <span class="literal">factory</span>;
        <span class="keyword">this</span>.<span class="built_in">num</span> = <span class="built_in">num</span>;
    }
    <span class="annotation">@Override</span>
    public <span class="keyword">void</span> run() {
        <span class="keyword">try</span> {
            <span class="literal">factory</span>.consume(<span class="built_in">num</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>注意的是Factory类的produce和consume方法都将Factory实例锁住了，锁住之后线程就成为了对象监视器的所有者，然后才能调用wait和notify方法。</p>
<p>输出：</p>
<pre><code>produce <span class="number">5</span>, left: <span class="number">5</span>
produce <span class="number">20</span>, left: <span class="number">25</span>
produce <span class="number">5</span>, left: <span class="number">30</span>
consume <span class="number">10</span>, left: <span class="number">20</span>
produce <span class="number">30</span>, left: <span class="number">50</span>
consume <span class="number">20</span>, left: <span class="number">30</span>
consume <span class="number">5</span>, left: <span class="number">25</span>
consume <span class="number">5</span>, left: <span class="number">20</span>
consume <span class="number">20</span>, left: <span class="number">0</span>
</code></pre><h3 id="finalize方法">finalize方法</h3><p>finalize方法是一个protected方法，Object类的默认实现是不进行任何操作。 </p>
<p>该方法的作用是实例被垃圾回收器回收的时候触发的操作，就好比 “死前的最后一波挣扎”。</p>
<p>直接写个弱引用例子：</p>
<pre><code>Car car = <span class="keyword">new</span> Car(<span class="number">9999</span>, <span class="string">"black"</span>);
WeakReference&lt;Car&gt; carWeakReference = <span class="keyword">new</span> WeakReference&lt;Car&gt;(car);

<span class="keyword">int</span> i = <span class="number">0</span>;
<span class="keyword">while</span>(<span class="keyword">true</span>) {
    <span class="keyword">if</span>(carWeakReference.<span class="keyword">get</span>() != <span class="keyword">null</span>) {
        i++;
        System.<span class="keyword">out</span>.println(<span class="string">"Object is alive for "</span>+i+<span class="string">" loops - "</span>+carWeakReference);
    } <span class="keyword">else</span> {
        System.<span class="keyword">out</span>.println(<span class="string">"Object has been collected."</span>);
        <span class="keyword">break</span>;
    }
}

<span class="keyword">class</span> <span class="title">Car</span> {
    <span class="keyword">private</span> <span class="keyword">double</span> price;
    <span class="keyword">private</span> String colour;

    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params"><span class="keyword">double</span> price, String colour</span>)</span>{
        <span class="keyword">this</span>.price = price;
        <span class="keyword">this</span>.colour = colour;
    }

    <span class="comment">// get set method</span>

    @<span class="function">Override
    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span>(<span class="params"></span>) throws Throwable </span>{
        System.<span class="keyword">out</span>.println(<span class="string">"i will be destroyed"</span>);
    }
}
</code></pre><p>输出：</p>
<pre><code>....
<span class="type">Object</span> <span class="keyword">is</span> alive <span class="keyword">for</span> <span class="number">26417</span> loops - java.lang.<span class="keyword">ref</span>.<span class="type">WeakReference</span>@<span class="number">7</span>c2f1622
<span class="type">Object</span> <span class="keyword">is</span> alive <span class="keyword">for</span> <span class="number">26418</span> loops - java.lang.<span class="keyword">ref</span>.<span class="type">WeakReference</span>@<span class="number">7</span>c2f1622
<span class="type">Object</span> <span class="keyword">is</span> alive <span class="keyword">for</span> <span class="number">26419</span> loops - java.lang.<span class="keyword">ref</span>.<span class="type">WeakReference</span>@<span class="number">7</span>c2f1622
<span class="type">Object</span> <span class="keyword">is</span> alive <span class="keyword">for</span> <span class="number">26420</span> loops - java.lang.<span class="keyword">ref</span>.<span class="type">WeakReference</span>@<span class="number">7</span>c2f1622
<span class="type">Object</span> <span class="keyword">is</span> alive <span class="keyword">for</span> <span class="number">26421</span> loops - java.lang.<span class="keyword">ref</span>.<span class="type">WeakReference</span>@<span class="number">7</span>c2f1622
<span class="type">Object</span> <span class="keyword">is</span> alive <span class="keyword">for</span> <span class="number">26422</span> loops - java.lang.<span class="keyword">ref</span>.<span class="type">WeakReference</span>@<span class="number">7</span>c2f1622
<span class="type">Object</span> has been collected.
i will be destroyed
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[Java中的Object类是所有类的父类，它提供了11个方法，分别是getClass，hashCode，clone，toString，notify，notifyAll，wait，finalze等方法 ...]]>
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="jdk" scheme="http://fangjian0423.github.io/tags/jdk/"/>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Avro介绍]]></title>
    <link href="http://fangjian0423.github.io/2016/02/21/avro-intro/"/>
    <id>http://fangjian0423.github.io/2016/02/21/avro-intro/</id>
    <published>2016-02-20T17:23:22.000Z</published>
    <updated>2016-05-10T14:59:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Avro介绍">Avro介绍</h2><p>Apache Avro是一个数据序列化系统。</p>
<p>Avro所提供的属性：</p>
<p>1.丰富的数据结构<br>2.使用快速的压缩二进制数据格式<br>3.提供容器文件用于持久化数据<br>4.远程过程调用RPC<br>5.简单的动态语言结合功能，Avro 和动态语言结合后，读写数据文件和使用 RPC 协议都不需要生成代码，而代码生成作为一种可选的优化只值得在静态类型语言中实现。</p>
<h2 id="Avro的Schema">Avro的Schema</h2><p>Avro的Schema用JSON表示。Schema定义了简单数据类型和复杂数据类型。</p>
<h3 id="基本类型">基本类型</h3><p>其中简单数据类型有以下8种：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">null</td>
<td style="text-align:center">没有值</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">布尔值</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">32位有符号整数</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">64位有符号整数</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">单精度（32位）的IEEE 754浮点数</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">双精度（64位）的IEEE 754浮点数</td>
</tr>
<tr>
<td style="text-align:center">bytes</td>
<td style="text-align:center">8位无符号字节序列</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">字符串</td>
</tr>
</tbody>
</table>
<p>基本类型没有属性，基本类型的名字也就是类型的名字，比如：</p>
<pre><code>{"<span class="attribute">type</span>": <span class="value"><span class="string">"string"</span></span>}
</code></pre><h3 id="复杂类型">复杂类型</h3><p>Avro提供了6种复杂类型。分别是Record，Enum，Array，Map，Union和Fixed。</p>
<h4 id="Record">Record</h4><p>Record类型使用的类型名字是 “record”，还支持其它属性的设置：</p>
<p>name：record类型的名字(必填)</p>
<p>namespace：命名空间(可选)</p>
<p>doc：这个类型的文档说明(可选)</p>
<p>aliases：record类型的别名，是个字符串数组(可选)</p>
<p>fields：record类型中的字段，是个对象数组(必填)。每个字段需要以下属性：</p>
<ol>
<li>name：字段名字(必填)</li>
<li>doc：字段说明文档(可选)</li>
<li>type：一个schema的json对象或者一个类型名字(必填)</li>
<li>default：默认值(可选)</li>
<li>order：排序(可选)，只有3个值ascending(默认)，descending或ignore</li>
<li>aliases：别名，字符串数组(可选)</li>
</ol>
<p>一个Record类型例子，定义一个元素类型是Long的链表：</p>
<pre><code><span class="collection">{
  <span class="string">"type"</span>: <span class="string">"record"</span>, 
  <span class="string">"name"</span>: <span class="string">"LongList"</span>,
  <span class="string">"aliases"</span>: <span class="collection">[<span class="string">"LinkedLongs"</span>]</span>,                      // old name for this
  <span class="string">"fields"</span> : <span class="collection">[
    <span class="collection">{<span class="string">"name"</span>: <span class="string">"value"</span>, <span class="string">"type"</span>: <span class="string">"long"</span>}</span>,             // each element has a long
    <span class="collection">{<span class="string">"name"</span>: <span class="string">"next"</span>, <span class="string">"type"</span>: <span class="collection">[<span class="string">"null"</span>, <span class="string">"LongList"</span>]</span>}</span> // optional next element
  ]</span>
}</span>
</code></pre><h4 id="Enum">Enum</h4><p>枚举类型的类型名字是”enum”，还支持其它属性的设置：</p>
<p>name：枚举类型的名字(必填)<br>namespace：命名空间(可选)<br>aliases：字符串数组，别名(可选)<br>doc：说明文档(可选)<br>symbols：字符串数组，所有的枚举值(必填)，不允许重复数据。</p>
<p>一个枚举类型的例子：</p>
<pre><code>{ "<span class="attribute">type</span>": <span class="value"><span class="string">"enum"</span></span>,
  "<span class="attribute">name</span>": <span class="value"><span class="string">"Suit"</span></span>,
  "<span class="attribute">symbols</span>" : <span class="value">[<span class="string">"SPADES"</span>, <span class="string">"HEARTS"</span>, <span class="string">"DIAMONDS"</span>, <span class="string">"CLUBS"</span>]
</span>}
</code></pre><h4 id="Array">Array</h4><p>数组类型的类型名字是”array”并且只支持一个属性：</p>
<p>items：数组元素的schema</p>
<p>一个数组例子：</p>
<pre><code>{"<span class="attribute">type</span>": <span class="value"><span class="string">"array"</span></span>, "<span class="attribute">items</span>": <span class="value"><span class="string">"string"</span></span>}
</code></pre><h4 id="Map">Map</h4><p>Map类型的类型名字是”map”并且只支持一个属性：</p>
<p>values：map值的schema</p>
<p>Map的key必须是字符串。</p>
<p>一个Map例子：</p>
<pre><code>{"<span class="attribute">type</span>": <span class="value"><span class="string">"map"</span></span>, "<span class="attribute">values</span>": <span class="value"><span class="string">"long"</span></span>}
</code></pre><h4 id="Union">Union</h4><p>组合类型，表示各种类型的组合，使用数组进行组合。比如[“null”, “string”]表示类型可以为null或者string。</p>
<p>组合类型的默认值是看组合类型的第一个元素，因此如果一个组合类型包括null类型，那么null类型一般都会放在第一个位置，这样子的话这个组合类型的默认值就是null。</p>
<p>组合类型中不允许同一种类型的元素的个数不会超过1个，除了record，fixed和enum。比如组合类中有2个array类型或者2个map类型，这是不允许的。</p>
<p>组合类型不允许嵌套组合类型。</p>
<h4 id="Fixed">Fixed</h4><p>混合类型的类型名字是fixed，支持以下属性：</p>
<p>name：名字(必填)<br>namespace：命名空间(可选)<br>aliases：字符串数组，别名(可选)<br>size：一个整数，表示每个值的字节数(必填)</p>
<p>比如16个字节数的fixed类型例子如下：</p>
<pre><code>{"<span class="attribute">type</span>": <span class="value"><span class="string">"fixed"</span></span>, "<span class="attribute">size</span>": <span class="value"><span class="number">16</span></span>, "<span class="attribute">name</span>": <span class="value"><span class="string">"md5"</span></span>}
</code></pre><h2 id="1个Avro例子">1个Avro例子</h2><p>首先定义一个User的schema：</p>
<pre><code>{
"<span class="attribute">namespace</span>": <span class="value"><span class="string">"example.avro"</span></span>,
 "<span class="attribute">type</span>": <span class="value"><span class="string">"record"</span></span>,
 "<span class="attribute">name</span>": <span class="value"><span class="string">"User"</span></span>,
 "<span class="attribute">fields</span>": <span class="value">[
     {"<span class="attribute">name</span>": <span class="value"><span class="string">"name"</span></span>, "<span class="attribute">type</span>": <span class="value"><span class="string">"string"</span></span>},
     {"<span class="attribute">name</span>": <span class="value"><span class="string">"favorite_number"</span></span>,  "<span class="attribute">type</span>": <span class="value"><span class="string">"int"</span></span>},
     {"<span class="attribute">name</span>": <span class="value"><span class="string">"favorite_color"</span></span>, "<span class="attribute">type</span>": <span class="value"><span class="string">"string"</span></span>}
 ]
</span>}
</code></pre><p>User有3个属性，分别是name，favorite_number和favorite_color。</p>
<p>json文件内容：</p>
<pre><code>{"<span class="attribute">name</span>":<span class="value"><span class="string">"format"</span></span>,"<span class="attribute">favorite_number</span>":<span class="value"><span class="number">1</span></span>,"<span class="attribute">favorite_color</span>":<span class="value"><span class="string">"red"</span></span>}
{"<span class="attribute">name</span>":<span class="value"><span class="string">"format2"</span></span>,"<span class="attribute">favorite_number</span>":<span class="value"><span class="number">2</span></span>,"<span class="attribute">favorite_color</span>":<span class="value"><span class="string">"black"</span></span>}
{"<span class="attribute">name</span>":<span class="value"><span class="string">"format3"</span></span>,"<span class="attribute">favorite_number</span>":<span class="value"><span class="number">666</span></span>,"<span class="attribute">favorite_color</span>":<span class="value"><span class="string">"blue"</span></span>}
</code></pre><p>使用avro工具将json文件转换成avro文件：</p>
<pre><code><span class="tag">java</span> <span class="tag">-jar</span> <span class="tag">avro-tools-1</span><span class="class">.8</span><span class="class">.0</span><span class="class">.jar</span> <span class="tag">fromjson</span> <span class="tag">--schema-file</span> <span class="tag">user</span><span class="class">.avsc</span> <span class="tag">user</span><span class="class">.json</span> &gt; <span class="tag">user</span><span class="class">.avro</span>
</code></pre><p>可以设置压缩格式：</p>
<pre><code><span class="tag">java</span> <span class="tag">-jar</span> <span class="tag">avro-tools-1</span><span class="class">.8</span><span class="class">.0</span><span class="class">.jar</span> <span class="tag">fromjson</span> <span class="tag">--codec</span> <span class="tag">snappy</span> <span class="tag">--schema-file</span> <span class="tag">user</span><span class="class">.avsc</span> <span class="tag">user</span><span class="class">.json</span> &gt; <span class="tag">user2</span><span class="class">.avro</span>
</code></pre><p>将avro文件反转换成json文件：</p>
<pre><code><span class="tag">java</span> <span class="tag">-jar</span> <span class="tag">avro-tools-1</span><span class="class">.8</span><span class="class">.0</span><span class="class">.jar</span> <span class="tag">tojson</span> <span class="tag">user</span><span class="class">.avro</span>
<span class="tag">java</span> <span class="tag">-jar</span> <span class="tag">avro-tools-1</span><span class="class">.8</span><span class="class">.0</span><span class="class">.jar</span> <span class="tag">--pretty</span> <span class="tag">tojson</span> <span class="tag">user</span><span class="class">.avro</span>
</code></pre><p>得到avro文件的meta：</p>
<pre><code><span class="tag">java</span> <span class="tag">-jar</span> <span class="tag">avro-tools-1</span><span class="class">.8</span><span class="class">.0</span><span class="class">.jar</span> <span class="tag">getmeta</span> <span class="tag">user</span><span class="class">.avro</span>
</code></pre><p>输出：</p>
<pre><code>avro.codec    null
avro.<span class="keyword">schema</span>    {<span class="string">"type"</span>:<span class="string">"record"</span>,<span class="string">"name"</span>:<span class="string">"User"</span>,<span class="string">"namespace"</span>:<span class="string">"example.avro"</span>,<span class="string">"fields"</span>:[{<span class="string">"name"</span>:<span class="string">"name"</span>,<span class="string">"type"</span>:<span class="string">"string"</span>},{<span class="string">"name"</span>:<span class="string">"favorite_number"</span>,<span class="string">"type"</span>:<span class="string">"int"</span>},{<span class="string">"name"</span>:<span class="string">"favorite_color"</span>,<span class="string">"type"</span>:<span class="string">"string"</span>}]}
</code></pre><p>得到avro文件的schema：</p>
<pre><code><span class="tag">java</span> <span class="tag">-jar</span> <span class="tag">avro-tools-1</span><span class="class">.8</span><span class="class">.0</span><span class="class">.jar</span> <span class="tag">getschema</span> <span class="tag">user</span><span class="class">.avro</span>
</code></pre><p>将文本文件转换成avro文件：</p>
<pre><code><span class="tag">java</span> <span class="tag">-jar</span> <span class="tag">avro-tools-1</span><span class="class">.8</span><span class="class">.0</span><span class="class">.jar</span> <span class="tag">fromtext</span> <span class="tag">user</span><span class="class">.txt</span> <span class="tag">usertxt</span><span class="class">.avro</span>
</code></pre><h2 id="Avro使用生成的代码进行序列化和反序列化">Avro使用生成的代码进行序列化和反序列化</h2><p>以上面一个例子的schema为例讲解。</p>
<p>Avro可以根据schema自动生成对应的类：</p>
<pre><code>java -jar /path/to/avro-tools-<span class="number">1.8</span>.<span class="number">0</span><span class="class">.jar</span> compile schema user<span class="class">.avsc</span> .
</code></pre><p>user.avsc的namespace为example.avro，name为User。最终在当前目录生成的example/avro目录下有个User.java文件。</p>
<pre><code>├── <span class="tag">example</span>
│   └── <span class="tag">avro</span>
│       └── <span class="tag">User</span><span class="class">.java</span>
</code></pre><p><strong>使用Avro生成的代码创建User：</strong></p>
<pre><code><span class="keyword">User</span> <span class="title">user1</span> = new User();
user1.setName(<span class="string">"Format"</span>);
user1.setFavoriteColor(<span class="string">"red"</span>);
user1.setFavoriteNumber(<span class="number">666</span>);

<span class="keyword">User</span> <span class="title">user2</span> = new User(<span class="string">"Format2"</span>, <span class="number">66</span>, <span class="string">"blue"</span>);

<span class="keyword">User</span> <span class="title">user3</span> = User.newBuilder()
                .setName(<span class="string">"Format3"</span>)
                .setFavoriteNumber(<span class="number">6</span>)
                .setFavoriteColor(<span class="string">"black"</span>).build();
</code></pre><p>可以使用有参的构造函数和无参的构造函数，也可以使用Builder构造User。</p>
<p><strong>序列化：</strong></p>
<p>DatumWrite接口用来把java对象转换成内存中的序列化格式，SpecificDatumWriter用来生成类并且指定生成的类型。</p>
<p>最后使用DataFileWriter来进行具体的序列化，create方法指定文件和schema信息，append方法用来写数据，最后写完后close文件。</p>
<pre><code>DatumWriter&lt;User&gt; userDatumWriter = <span class="keyword">new</span> SpecificDatumWriter&lt;User&gt;(User.<span class="keyword">class</span>);
        DataFileWriter&lt;User&gt; dataFileWriter = <span class="keyword">new</span> DataFileWriter&lt;User&gt;(userDatumWriter);
dataFileWriter.create(user1.getSchema(), <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"users.avro"</span>));
dataFileWriter.<span class="keyword">append</span>(user1);
dataFileWriter.<span class="keyword">append</span>(user2);
dataFileWriter.<span class="keyword">append</span>(user3);
dataFileWriter.close();
</code></pre><p><strong>反序列化：</strong></p>
<p>反序列化跟序列化很像，相应的Writer换成Reader。这里只创建一个User对象是为了性能优化，每次都重用这个User对象，如果文件量很大，对象分配和垃圾收集处理的代价很昂贵。如果不考虑性能，可以使用 for (User user : dataFileReader) 循环遍历对象</p>
<pre><code><span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"users.avro"</span>);
DatumReader&lt;User&gt; userDatumReader = <span class="keyword">new</span> SpecificDatumReader&lt;User&gt;(User.<span class="keyword">class</span>);
DataFileReader&lt;User&gt; dataFileReader = <span class="keyword">new</span> DataFileReader&lt;User&gt;(<span class="keyword">file</span>, userDatumReader);
User user = <span class="keyword">null</span>;
<span class="keyword">while</span>(dataFileReader.hasNext()) {
    user = dataFileReader.<span class="keyword">next</span>(user);
    System.out.<span class="keyword">println</span>(user);
}
</code></pre><p>打印出：</p>
<pre><code>{"<span class="attribute">name</span>": <span class="value"><span class="string">"Format"</span></span>, "<span class="attribute">favorite_number</span>": <span class="value"><span class="number">666</span></span>, "<span class="attribute">favorite_color</span>": <span class="value"><span class="string">"red"</span></span>}
{"<span class="attribute">name</span>": <span class="value"><span class="string">"Format2"</span></span>, "<span class="attribute">favorite_number</span>": <span class="value"><span class="number">66</span></span>, "<span class="attribute">favorite_color</span>": <span class="value"><span class="string">"blue"</span></span>}
{"<span class="attribute">name</span>": <span class="value"><span class="string">"Format3"</span></span>, "<span class="attribute">favorite_number</span>": <span class="value"><span class="number">6</span></span>, "<span class="attribute">favorite_color</span>": <span class="value"><span class="string">"black"</span></span>}
</code></pre><h2 id="Avro不使用生成的代码进行序列化和反序列化">Avro不使用生成的代码进行序列化和反序列化</h2><p>虽然Avro为我们提供了根据schema自动生成类的方法，我们也可以自己创建类，不使用Avro的自动生成工具。</p>
<p><strong>创建User：</strong></p>
<p>首先使用Parser读取schema信息并且创建Schema类：</p>
<pre><code>Schema schema = <span class="keyword">new</span> Schema.Parser().parse(<span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"user.avsc"</span>));
</code></pre><p>有了Schema之后可以创建record：</p>
<pre><code>GenericRecord user1 = <span class="keyword">new</span> GenericData.Record(schema);
user1.<span class="keyword">put</span>(<span class="string">"name"</span>, <span class="string">"Format"</span>);
user1.<span class="keyword">put</span>(<span class="string">"favorite_number"</span>, <span class="number">666</span>);
user1.<span class="keyword">put</span>(<span class="string">"favorite_color"</span>, <span class="string">"red"</span>);

GenericRecord user2 = <span class="keyword">new</span> GenericData.Record(schema);
user2.<span class="keyword">put</span>(<span class="string">"name"</span>, <span class="string">"Format2"</span>);
user2.<span class="keyword">put</span>(<span class="string">"favorite_number"</span>, <span class="number">66</span>);
user2.<span class="keyword">put</span>(<span class="string">"favorite_color"</span>, <span class="string">"blue"</span>);
</code></pre><p>使用GenericRecord表示User，GenericRecord会根据schema验证字段是否正确，如果put进了不存在的字段 user1.put(“favorite_animal”, “cat”) ，那么运行的时候会得到AvroRuntimeException异常。</p>
<p><strong>序列化：</strong></p>
<p>序列化跟生成的User类似，只不过schema是自己构造的，不是User中拿的。</p>
<pre><code>Schema schema = <span class="keyword">new</span> Schema.Parser().parse(<span class="keyword">new</span> File(<span class="string">"user.avsc"</span>));
GenericRecord user1 = <span class="keyword">new</span> GenericData.Record(schema);
user1.<span class="keyword">put</span>(<span class="string">"name"</span>, <span class="string">"Format"</span>);
user1.<span class="keyword">put</span>(<span class="string">"favorite_number"</span>, <span class="number">666</span>);
user1.<span class="keyword">put</span>(<span class="string">"favorite_color"</span>, <span class="string">"red"</span>);

GenericRecord user2 = <span class="keyword">new</span> GenericData.Record(schema);
user2.<span class="keyword">put</span>(<span class="string">"name"</span>, <span class="string">"Format2"</span>);
user2.<span class="keyword">put</span>(<span class="string">"favorite_number"</span>, <span class="number">66</span>);
user2.<span class="keyword">put</span>(<span class="string">"favorite_color"</span>, <span class="string">"blue"</span>);

DatumWriter&lt;GenericRecord&gt; datumWriter = <span class="keyword">new</span> SpecificDatumWriter&lt;GenericRecord&gt;(schema);
DataFileWriter&lt;GenericRecord&gt; dataFileWriter = <span class="keyword">new</span> DataFileWriter&lt;GenericRecord&gt;(datumWriter);
dataFileWriter.create(schema, <span class="keyword">new</span> File(<span class="string">"users2.avro"</span>));
dataFileWriter.<span class="built_in">append</span>(user1);
dataFileWriter.<span class="built_in">append</span>(user2);
dataFileWriter.<span class="keyword">close</span>();
</code></pre><p><strong>反序列化：</strong></p>
<p>反序列化跟生成的User类似，只不过schema是自己构造的，不是User中拿的。</p>
<pre><code>Schema schema = <span class="keyword">new</span> Schema.Parser().parse(<span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"user.avsc"</span>));
<span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"users2.avro"</span>);
DatumReader&lt;GenericRecord&gt; datumReader = <span class="keyword">new</span> SpecificDatumReader&lt;GenericRecord&gt;(schema);
DataFileReader&lt;GenericRecord&gt; dataFileReader = <span class="keyword">new</span> DataFileReader&lt;GenericRecord&gt;(<span class="keyword">file</span>, datumReader);
GenericRecord user = <span class="keyword">null</span>;
<span class="keyword">while</span>(dataFileReader.hasNext()) {
    user = dataFileReader.<span class="keyword">next</span>(user);
    System.out.<span class="keyword">println</span>(user);
}
</code></pre><p>打印出：</p>
<pre><code>{"<span class="attribute">name</span>": <span class="value"><span class="string">"Format"</span></span>, "<span class="attribute">favorite_number</span>": <span class="value"><span class="number">666</span></span>, "<span class="attribute">favorite_color</span>": <span class="value"><span class="string">"red"</span></span>}
{"<span class="attribute">name</span>": <span class="value"><span class="string">"Format2"</span></span>, "<span class="attribute">favorite_number</span>": <span class="value"><span class="number">66</span></span>, "<span class="attribute">favorite_color</span>": <span class="value"><span class="string">"blue"</span></span>}
</code></pre><h2 id="一些注意点">一些注意点</h2><p>Avro解析json文件的时候，如果类型是Record并且里面有字段是union并且允许空值的话，需要进行转换。因为[“bytes”, “string”]和[“int”,”long”]这2个union类型在json中是有歧义的，第一个union在json中都会被转换成string类型，第二个union在json中都会被转换成数字类型。</p>
<p>所以如果json值的null的话，在avro提供的json中直接写null，否则使用只有一个键值对的对象，键是类型，值的具体的值。</p>
<p>比如：</p>
<pre><code>{
"<span class="attribute">namespace</span>": <span class="value"><span class="string">"example.avro"</span></span>,
 "<span class="attribute">type</span>": <span class="value"><span class="string">"record"</span></span>,
 "<span class="attribute">name</span>": <span class="value"><span class="string">"User"</span></span>,
 "<span class="attribute">fields</span>": <span class="value">[
     {"<span class="attribute">name</span>": <span class="value"><span class="string">"name"</span></span>, "<span class="attribute">type</span>": <span class="value"><span class="string">"string"</span></span>},
     {"<span class="attribute">name</span>": <span class="value"><span class="string">"favorite_number"</span></span>,  "<span class="attribute">type</span>": <span class="value">[<span class="string">"int"</span>,<span class="string">"null"</span>]</span>},
     {"<span class="attribute">name</span>": <span class="value"><span class="string">"favorite_color"</span></span>, "<span class="attribute">type</span>": <span class="value">[<span class="string">"string"</span>,<span class="string">"null"</span>]</span>}
 ]
</span>}
</code></pre><p>在要转换成json文件的时候要写成这样：</p>
<pre><code>{"<span class="attribute">name</span>":<span class="value"><span class="string">"format"</span></span>,"<span class="attribute">favorite_number</span>":<span class="value">{"<span class="attribute">int</span>":<span class="value"><span class="number">1</span></span>}</span>,"<span class="attribute">favorite_color</span>":<span class="value">{"<span class="attribute">string</span>":<span class="value"><span class="string">"red"</span></span>}</span>}
{"<span class="attribute">name</span>":<span class="value"><span class="string">"format2"</span></span>,"<span class="attribute">favorite_number</span>":<span class="value"><span class="literal">null</span></span>,"<span class="attribute">favorite_color</span>":<span class="value">{"<span class="attribute">string</span>":<span class="value"><span class="string">"black"</span></span>}</span>}
{"<span class="attribute">name</span>":<span class="value"><span class="string">"format3"</span></span>,"<span class="attribute">favorite_number</span>":<span class="value">{"<span class="attribute">int</span>":<span class="value"><span class="number">66</span></span>}</span>,"<span class="attribute">favorite_color</span>":<span class="value"><span class="literal">null</span></span>}
</code></pre><h2 id="Spark读取Avro文件">Spark读取Avro文件</h2><p>直接遍历avro文件，得到GenericRecord进行处理：</p>
<pre><code>val conf = new <span class="function"><span class="title">SparkConf</span><span class="params">()</span></span>.<span class="function"><span class="title">setMaster</span><span class="params">(<span class="string">"local"</span>)</span></span>.<span class="function"><span class="title">setAppName</span><span class="params">(<span class="string">"AvroTest"</span>)</span></span>

val sc = new <span class="function"><span class="title">SparkContext</span><span class="params">(conf)</span></span>

val rdd = sc<span class="class">.hadoopFile</span>[AvroWrapper[GenericRecord], NullWritable, AvroInputFormat[GenericRecord]](this<span class="class">.getClass</span><span class="class">.getResource</span>(<span class="string">"/"</span>)<span class="class">.toString</span> + <span class="string">"users.avro"</span>)

val nameRdd = rdd.<span class="function"><span class="title">map</span><span class="params">(s =&gt; s._1.datum()</span></span>.<span class="function"><span class="title">get</span><span class="params">(<span class="string">"name"</span>)</span></span>.toString)

nameRdd.<span class="function"><span class="title">collect</span><span class="params">()</span></span>.<span class="function"><span class="title">foreach</span><span class="params">(println)</span></span>
</code></pre><h2 id="使用Avro需要注意的地方">使用Avro需要注意的地方</h2><p>笔者使用Avro的时候暂时遇到了下面2个坑。先记录一下，以后遇到新的坑会更新这篇文章。</p>
<p>1.如果定义了unions类型的字段，而且unions中有null选项的schema，比如如下schema：</p>
<pre><code>{
"<span class="attribute">namespace</span>": <span class="value"><span class="string">"example.avro"</span></span>,
 "<span class="attribute">type</span>": <span class="value"><span class="string">"record"</span></span>,
 "<span class="attribute">name</span>": <span class="value"><span class="string">"User2"</span></span>,
 "<span class="attribute">fields</span>": <span class="value">[
     {"<span class="attribute">name</span>": <span class="value"><span class="string">"name"</span></span>, "<span class="attribute">type</span>": <span class="value"><span class="string">"string"</span></span>},
     {"<span class="attribute">name</span>": <span class="value"><span class="string">"favorite_number"</span></span>,  "<span class="attribute">type</span>": <span class="value">[<span class="string">"null"</span>,<span class="string">"int"</span>]</span>},
     {"<span class="attribute">name</span>": <span class="value"><span class="string">"favorite_color"</span></span>, "<span class="attribute">type</span>": <span class="value">[<span class="string">"null"</span>,<span class="string">"string"</span>]</span>}
 ]
</span>}
</code></pre><p>这样的schema，如果不使用Avro自动生成的model代码进行insert，并且insert中的model数据有null数据的话。然后用spark读avro文件的话，会报org.apache.avro.AvroTypeException: Found null, expecting int … 这样的错误。</p>
<p>这一点很奇怪，但是使用Avro生成的Model进行insert的话，sprak读取就没有任何问题。 很困惑。</p>
<p>2.如果使用了Map类型的字段，avro生成的model中的Map的Key默认类型为CharSequence。这种model我们insert数据的话，用String是没有问题的。但是spark读取之后要根据Key拿这个Map数据的时候，永远得到的是null。</p>
<p>stackoverflow上有一个页面说到了这个问题。<a href="http://stackoverflow.com/questions/19728853/apache-avro-map-uses-charsequence-as-key" target="_blank" rel="external">http://stackoverflow.com/questions/19728853/apache-avro-map-uses-charsequence-as-key
</a></p>
<p>需要在map类型的字段里加上”avro.java.string”: “String”这个选项, 然后compile的时候使用-string参数即可。</p>
<p>比如以下这个schema：</p>
<pre><code>{
"<span class="attribute">namespace</span>": <span class="value"><span class="string">"example.avro"</span></span>,
 "<span class="attribute">type</span>": <span class="value"><span class="string">"record"</span></span>,
 "<span class="attribute">name</span>": <span class="value"><span class="string">"User3"</span></span>,
 "<span class="attribute">fields</span>": <span class="value">[
     {"<span class="attribute">name</span>": <span class="value"><span class="string">"name"</span></span>, "<span class="attribute">type</span>": <span class="value"><span class="string">"string"</span></span>},
     {"<span class="attribute">name</span>": <span class="value"><span class="string">"favorite_number"</span></span>,  "<span class="attribute">type</span>": <span class="value">[<span class="string">"null"</span>,<span class="string">"int"</span>]</span>},
     {"<span class="attribute">name</span>": <span class="value"><span class="string">"favorite_color"</span></span>, "<span class="attribute">type</span>": <span class="value">[<span class="string">"null"</span>,<span class="string">"string"</span>]</span>},
     {"<span class="attribute">name</span>": <span class="value"><span class="string">"scores"</span></span>, "<span class="attribute">type</span>": <span class="value">[<span class="string">"null"</span>, {"<span class="attribute">type</span>": <span class="value"><span class="string">"map"</span></span>, "<span class="attribute">values</span>": <span class="value"><span class="string">"string"</span></span>, "<span class="attribute">avro.java.string</span>": <span class="value"><span class="string">"String"</span></span>}]</span>}
 ]
</span>}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[Apache Avro是一个数据序列化系统, 提供丰富的数据结构，使用快速的压缩二进制数据格式，提供容器文件用于持久化数据 ...]]>
    
    </summary>
    
      <category term="avro" scheme="http://fangjian0423.github.io/tags/avro/"/>
    
      <category term="big data" scheme="http://fangjian0423.github.io/tags/big-data/"/>
    
      <category term="avro" scheme="http://fangjian0423.github.io/categories/avro/"/>
    
  </entry>
  
</feed>
